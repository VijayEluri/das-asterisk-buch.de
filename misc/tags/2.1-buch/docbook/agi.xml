<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="kapitel-agi" lang="de" revision="$Revision$">
  <!--
% Copyright (c) 2006 - Stefan Wintermeyer <sw@amooma.de>
% Copyright (c) 2009 - Philipp Kempgen <philipp.kempgen@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de
-->

  <title>Asterisk Gateway Interface (AGI)<indexterm significance="preferred">
      <primary>AGI</primary>
    </indexterm><indexterm significance="preferred">
      <primary>Asterisk Gateway Interface</primary>
    </indexterm></title>

  <para>Das Asterisk Gateway Interface (AGI) ist vergleichbar mit CGI auf
  Webservern. Es sind externe Programme, die innerhalb des Dialplans (der
  <filename>extensions.conf</filename>) aufgerufen werden. AGI-Skripte können
  mit Asterisk interagieren und Befehle ausführen. AGI-Skripte können
  prinzipiell in allen Programmier- und Skriptsprachen (z. B. Shell-Skript)
  geschrieben werden, die mit den Standard-Sockets unter Unix umgehen können.
  Die folgenden Beschreibungen gelten also nur als Beispiele für eine
  Implementierung. Für die Befehlsreferenz siehe <xref
  linkend="agi-commands" />.</para>

  <section id="agi-datenstroeme">
    <title>Datenströme</title>

    <para>Für AGI-Skripte ist ein Verständnis des Unix-Datenstrom-Models
    unabdingbar. Im Anhang dieses Buches finden Sie Informationen zu diesem
    Prinzip.</para>

    <section id="agi-stdin">
      <title>STDIN</title>

      <para>Das AGI-Skript bekommt über den <quote>standard input</quote>
      (STDIN) einige Informationen von Asterisk. Das Format sieht
      folgendermaßen aus:<programlisting>agi_request: programmname.php
agi_channel: Zap/1-2
agi_language: de
agi_callerid: Hans Beispiel
agi_context: extern
agi_extension: 1234
agi_priority: 2
</programlisting>Nach dem Übergeben dieser Grundinformationen sendet Asterisk
      noch eine Leerzeile, um dem AGI-Skript mitzuteilen, dass die Übertragung
      beendet ist.</para>

      <section id="agi-headers">
        <title>AGI-Header</title>

        <para>Die folgende Aufstellung listet alle von Asterisk
        weitergegebenen Header auf:</para>

        <itemizedlist>
          <listitem>
            <para><code>agi_request</code></para>

            <para>Der Dateiname des aufgerufenen AGI-Programms</para>
          </listitem>

          <listitem>
            <para><code>agi_channel</code></para>

            <para>Der Channel</para>
          </listitem>

          <listitem>
            <para><code>agi_language</code></para>

            <para>Die eingestellte Sprache (z. B. <code>en</code> für Englisch
            oder <code>de</code> für Deutsch)</para>
          </listitem>

          <listitem>
            <para><code>agi_type</code></para>

            <para>Die Channel-Art (z. B. <code>sip</code> für SIP oder
            <code>zap</code> für ISDN)</para>
          </listitem>

          <listitem>
            <para><code>agi_uniqueid</code></para>

            <para>Eine im System unique (einmalige) ID für das Gespräch</para>
          </listitem>

          <listitem>
            <para><code>agi_callerid</code></para>

            <para>Die Caller-ID (z. B. <code>Hans Meier
            &lt;2000&gt;</code>)</para>
          </listitem>

          <listitem>
            <para><code>agi_context</code></para>

            <para>Der Ursprungs-Context</para>
          </listitem>

          <listitem>
            <para><code>agi_extension</code></para>

            <para>Die Ursprungs-Extension</para>
          </listitem>

          <listitem>
            <para><code>agi_priority</code></para>

            <para>Die Priorität in der Extension beim Aufruf des
            AGI-Skripts</para>
          </listitem>

          <listitem>
            <para><code>agi_accountcode</code></para>

            <para>Abrechnungscode</para>
          </listitem>

          <listitem>
            <para><code>agi_calleridname</code></para>

            <para>Name aus der Caller-ID (z. B. <code>Hans
            Meier</code>)</para>
          </listitem>

          <listitem>
            <para><code>agi_callingpres</code></para>

            <para>Die Caller-ID im ZAP-Channel</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="agi-stdout">
      <title>STDOUT</title>

      <para>Nachdem das AGI-Skript die Grundinformationen von Asterisk
      erhalten hat, beginnt es mit seiner Arbeit und gibt Befehle über
      <quote>standard out</quote> (STDOUT) zurück an Asterisk. Um sich diese
      Kommunikation anzuschauen, kann man im CLI mit <command>set verbose
      5</command> den Verbosity-Level entsprechend hochsetzen.</para>
    </section>

    <section id="agi-stderr">
      <title>STDERR</title>

      <para><quote>Standard error</quote> (STDERR) ist der formale Weg, um
      Fehler- oder Debug-Meldungen vom AGI-Skript auf die Console (das CLI)
      von Asterisk zu bringen.</para>
    </section>
  </section>

  <section id="agi-verzeichnisse">
    <title>Verzeichnisse und Rechte</title>

    <para>AGI-Skripte werden von Asterisk standardmäßig im Verzeichnis
    <filename>/var/lib/asterisk/agi-bin</filename>/ gesucht.</para>

    <para>Achten Sie darauf, dass das entsprechende Skript von Asterisk auch
    ausgeführt werden darf. Dies wird durch den Aufruf des Befehls
    <command>chmod 755 <replaceable>skriptname</replaceable></command>
    gewährleistet.</para>
  </section>

  <section id="agi-aufruf-im-dialplan">
    <title>Aufruf eines AGI-Skripts im Dialplan</title>

    <para>Ein AGI-Skript wird im Dialplan über die Applikation
    <code>agi</code> aufgerufen. Die kann wie folgt aussehen:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,AGI(mein-agi-programm.php)
exten =&gt; 1234,3,Hangup()</programlisting></para>
  </section>

  <section>
    <title>Beispiele in verschiedenen Programmiersprachen</title>

    <para>Im Folgenden werden AGI-Programme in einigen exemplarischen
    Programmiersprachen erklärt.</para>

    <section id="agi-perl">
      <title>Perl</title>

      <para>In der Standard-Asterisk-Installation ist ein Test-AGI-Skript mit
      dem Namen <filename>agi-test.agi</filename> <footnote>
          <para>Die Dateiendung <filename>agi</filename> ist dabei nicht
          zwingend notwendig. Man könnte die Datei auch
          <filename>agi-test.pl</filename> nennen.</para>
        </footnote>im Verzeichnis
      <filename>/var/lib/asterisk/agi-bin/</filename> abgespeichert. Anhand
      dieses Perl-Programms werden wir die grundsätzliche Arbeit mit
      AGI-Skripten beschreiben.</para>

      <para>Das Skript wird dabei in der <filename>extensions.conf</filename>
      wie folgt aufgerufen:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,AGI(agi-test.agi)
exten =&gt; 1234,3,Hangup()</programlisting></para>

      <section id="agi-perl-agi-test.agi">
        <title>Schritt-für-Schritt-Analyse des agi-test.agi-Skripts</title>

        <para>Wir besprechen das Beispiel-Skript zeilen- oder
        abschnittsweise.<programlisting>#!/usr/bin/perl
use strict;</programlisting>Die ersten zwei Zeilen sagen dem ausführenden
        Betriebssystem, dass es sich um ein Perl-Programm handelt, das mit dem
        Interpreter <filename>/usr/bin/perl</filename> ausgeführt werden soll.
        <code>use strict</code> bewirkt eine konsequentere Behandlung von
        Fehlern innerhalb des Perl-Programms.<programlisting>$|=1;</programlisting>Diese
        kleine Zeile bringt Perl dazu, die Ausgabe von Text nicht zu puffern.
        So können wir sicher sein, dass alle Ausgaben auch unmittelbar an
        Asterisk übergeben und nicht erst in einem Buffer zwischengespeichert
        werden.<programlisting># Setup some variables
my %AGI; my $tests = 0; my $fail = 0; my $pass = 0;</programlisting>Hier
        werden verschiedene Variablen definiert. Das Hash <code>%AGI</code>
        nimmt die initialen Eingaben von Asterisk auf. Die restlichen
        Variablen zählen die Gesamtanzahl der Tests, die Anzahl der
        fehlgeschlagenen Tests und die Anzahl der funktionierenden
        Tests.<programlisting>while(&lt;STDIN&gt;) {
  chomp;
  last unless length($_);
  if (/^agi_(\w+)\:\s+(.*)$/) {
    $AGI{$1} = $2;
  }
}</programlisting>Die eben eingelesenen Werte werden zum Debuggen auf STDERR,
        also im Endeffekt auf dem CLI ausgegeben:<programlisting>print STDERR "AGI Environment Dump:\n";
foreach my $i (sort keys %AGI) {
        print STDERR " -- $i = $AGI{$i}\n";
}
</programlisting>Danach geht es mit <code>checkresult</code>
        weiter:<programlisting>sub checkresult {
  my ($res) = @_;
  my $retval;
  $tests++;
  chomp $res;
  if ($res =~ /^200/) {
    $res =~ /result=(-?\d+)/;
    if (!length($1)) {
      print STDERR "FAIL ($res)\n";
      $fail++;
    } else {
      print STDERR "PASS ($1)\n";
      $pass++;
    }
  } else {
    print STDERR "FAIL (unexpected result '$res')\n";
    $fail++;
  }
}</programlisting>Die Subroutine <code>checkresult</code> liest das Ergebnis
        eines Befehls an Asterisk aus und bestimmt, ob der Test erfolgreich
        war oder nicht. Entsprechend werden die Variablen <code>$fail</code>
        und <code>$pass</code> hochgezählt. Nachdem die Grundlagen gelegt
        sind, können die einzelnen Tests beginnen: Die Datei
        <filename>beep.gsm</filename> wird abgespielt.<programlisting>print STDERR "1.  Testing 'sendfile'...";
print "STREAM FILE beep \"\"\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Der Text "hello world" wird an den
        Anrufer geschickt. Das funktioniert natürlich nur, wenn das Protokoll
        und das Endgerät diese Funktion unterstützen.<programlisting>print STDERR "2.  Testing 'sendtext'...";
print "SEND TEXT \"hello world\"\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Das Bild "asterisk-image" wird an
        den Anrufer geschickt. Auch diese Funktion ist vom Protokoll und dem
        Endgerät abhängig.<programlisting>print STDERR "3.  Testing 'sendimage'...";
print "SEND IMAGE asterisk-image\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Die Zahl 192837465 wird dem Anrufer
        vorgelesen:<programlisting>print STDERR "4.  Testing 'saynumber'...";
print "SAY NUMBER 192837465 \"\"\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Dieser Befehl wartet 1000
        Millisekunden auf die Eingabe von DTMF-Tönen durch den
        Anrufer:<programlisting>print STDERR "5.  Testing 'waitdtmf'...";
print "WAIT FOR DIGIT 1000\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Ein 3000 Millisekunden langes
        GSM-Soundfile mit dem Namen <filename>testagi.gsm</filename> wird
        aufgenommen. Die Aufnahme kann durch die Eingabe der Zahlen 1, 2, 3
        oder 4 unterbrochen werden.<programlisting>print STDERR "6.  Testing 'record'...";
print "RECORD FILE testagi gsm 1234 3000\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Das soeben aufgenommene Soundfile
        wird abgespielt:<programlisting>print STDERR "6a.  Testing 'record' playback...";
print "STREAM FILE testagi \"\"\n";
my $result = &lt;STDIN&gt;;
&amp;checkresult($result);</programlisting>Nun erfolgt die Ausgabe auf dem
        CLI, wie viele Tests funktioniert oder nicht funktioniert
        haben:<programlisting>print STDERR "================== Complete ======================\n";
print STDERR "$tests tests completed, $pass passed, $fail failed\n";
print STDERR "==================================================\n";</programlisting><warning>
            <para>Bei vielen AGI-Befehlen sehen Sie den folgenden
            Aufbau:<programlisting>fwrite(STDOUT,"BEFEHL $value \"\"\n");
#                            ^^^^^^^</programlisting>Der in dieser Zeile
            unterschlängelte Teil (zwischen <code>$value</code> und
            <code>);</code>) ist zwingend erforderlich, damit der Befehl
            korrekt ausgeführt wird. Es handelt sich hierbei um ein Argument
            ohne Inhalt, das durch zwei gequotete Anführungszeichen
            dargestellt wird. Abgeschlossen wird der gesamte Befehl durch ein
            <quote>line feed</quote> (ein Zeilenende-Zeichen), in diesem Fall
            ein <code>\n</code>.</para>
          </warning></para>
      </section>
    </section>

    <section id="agi-php">
      <title>PHP</title>

      <para>PHP ist zu einer der populärsten Programmiersprachen für
      Webapplikationen geworden.<footnote>
          <para>Böse Zungen sprechen auch vom BASIC des 21. Jahrhunderts.
          ;-)</para>
        </footnote> Da man aber aktuelle PHP-Versionen auch für den Aufruf von
      Programmen auf der Kommandozeile benutzen kann, ist PHP eine für
      AGI-Skripte gut geeignete Sprache. Als Beispiel benutzen wir ein kleines
      PHP-Programm (<filename>lotto.php</filename>), das 6 zufällige Zahlen
      von 1 bis 49 auswählt und dem Anrufer vorspricht. Die Beschreibung der
      einzelnen Schritte erfolgt im Quellcode.<programlisting>#!/usr/bin/php -q
&lt;?php

# Sicherheitseinstellung. Das Skript läuft nicht 
# laenger als 8 Sekunden.
#################################################
set_time_limit(8);


# Output Buffer wird deaktiviert
# Alternativ könnten wir nach jeder Ausgabe
# fflush(STDOUT); aufrufen.
#################################################
ob_implicit_flush();


# PHP Error Reporting wird deaktiviert
#################################################
error_reporting(0);


# Für die Kommunikation mit Asterisk benötigen 
# wir STDIN und STDOUT Filehandles
#################################################
if (!defined('STDIN'))
  define('STDIN' , fopen('php://stdin' , 'r'));
if (!defined('STDOUT'))
  define('STDOUT', fopen('php://stdout', 'w'));
if (!defined('STDERR'))
  define('STDERR', fopen('php://stderr', 'w'));


# Die von Asterisk übergebenen Variablen und 
# Werte werden ausgelesen und im Array $agi 
# gespeichert.
#################################################

$agi = array();

while (!feof(STDIN))
{
  $tmp = trim(fgets(STDIN,4096));
  if (($tmp == '') || ($tmp == "\n"))
    break;
  $var1 = split(':',$tmp);
  $name = str_replace('agi_','',$var1[0]);
  $agi[$name] = trim($var1[1]);
}


# Ein Array mit 6 zufälligen und nicht 
# doppelten Zahlen von 1 bis 49 wird generiert.
#################################################

$Lottozahlen = array();
do {
  $Zahl = rand(1,49);
  if (array_search($Zahl, $Lottozahlen) == FALSE) {
    $Lottozahlen[] = $Zahl;
  }
} while (count($Lottozahlen) &lt; 6);


# Vor der ersten Ansage wird eine Sekunde 
# gewartet.
#################################################
fwrite(STDOUT,"EXEC Wait 1 \"\"\n");
fflush(STDOUT);


# Die Zahlen werden nacheinander vorgelesen. 
# Zwischen den einzelnen Zahlen gibt es immer 
# eine Pause von einer Sekunde.
#################################################
foreach ($Lottozahlen as $value) {
  fwrite(STDOUT,"SAY NUMBER $value \"\"\n");
  fflush(STDOUT);
  fwrite(STDOUT,"EXEC Wait 1 \"\"\n");
  fflush(STDOUT);
}

?&gt;</programlisting>Das Programm <filename>lotto.php</filename> muss im
      Verzeichnis <filename>/var/lib/asterisk/agi-bin/</filename>
      abgespeichert werden und wird in der
      <filename>extensions.conf</filename> wie folgt aufgerufen:</para>

      <programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,AGI(lotto.php)
exten =&gt; 1234,3,Hangup()</programlisting>

      <section id="agi-phpagi">
        <title>phpAGI</title>

        <para>Wenn Sie PHP und AGI einsetzen, aber nicht das Rad neu erfinden
        wollen, können Sie die fertige PHP-Klasse phpAGI benutzen.
        Informationen und die dazugehörigen Dateien finden Sie auf der
        Homepage des Projekts <ulink
        url="http://phpagi.sourceforge.net/"><citetitle>http://phpagi.sourceforge.net/</citetitle></ulink>.</para>

        <para>Das folgende mit phpAGI mitgelieferte Programm gibt schnell
        einen Überblick über die Funktionsaufrufe<footnote>
            <para>Für die Benutzung von <code>text2wav</code> muss ein
            Text-to-Speech-System (z. B. <emphasis>Festival</emphasis>)
            installiert und konfiguriert sein.</para>
          </footnote><programlisting>&lt;?php
/**
* @package phpAGI_examples
* @version 2.0
*/

function my_ip(&amp;$agi, $peer)
   {
    $ip = 'unknown';
    $asm = $agi-&gt;new_AsteriskManager();
    if($asm-&gt;connect())
    {
      $peer = $asm-&gt;command("sip show peer $peer");
      $asm-&gt;disconnect();
    
      if(!strpos($peer['data'], ':'))
        echo $peer['data'];
      else
      {
        $data = array();
        foreach(explode("\n", $peer['data']) as $line)
        {
          $a = strpos('z'.$line, ':') - 1;
          if($a &gt;= 0) $data[trim(substr($line, 0, $a))] = trim(substr($line, $a + 1));
        }
      }
    
      if(isset($data['Addr-&gt;IP']))
      {
        $ip = explode(' ', trim($data['Addr-&gt;IP']));
        $ip = $ip[0];
      }
    }
    $agi-&gt;text2wav("Your IP address is $ip");
  }
?&gt;</programlisting></para>
      </section>
    </section>

    <section id="adhearsion">
      <title>Ruby und Adhearsion</title>

      <para>Obwohl <ulink url="http://www.ruby-lang.org">Ruby</ulink> eine für
      EDV-Verhältnisse alte Programmiersprache ist, hat sie erst in den
      letzten Jahren (hauptsächlich durch <ulink
      url="http://rubyonrails.org/">Ruby on Rails</ulink>) eine große
      Popularität erlangt. <ulink
      url="http://adhearsion.com/">Adhearsion</ulink> ist für Ruby und
      Asterisk dabei das Gleiche, was Ruby on Rails für Ruby und
      Webapplikationen ist. Das Thema ist dabei so spannend, dass man darüber
      ein eigenes Buch schreiben könnte. Auch hier werden wir im Laufe der
      Zeit auf der <ulink url="http://das-asterisk-buch.de">Webseite zum
      Buch</ulink> Updates nachreichen.</para>

      <section id="adhearsion-installation">
        <title>Installation</title>

        <para>Wie es sich für ein gutes Open-Source-Projekt gehört, ist auch
        die Dokumentation von Adhearsion reichlich verzweigt und oft
        unvollständig. Glücklicherweise ist wenigstens die Installation
        denkbar einfach, weil es zu Adhearsion ein fertiges
        <emphasis>gem</emphasis> gibt (für Ruby-Neulinge: gem ist ein
        Paketmanagement-Mechanismus für Ruby). Entsprechend kann die
        Installation mit <command>gem install adhearsion</command> vollzogen
        werden.</para>
      </section>

      <section id="adhearsion-setup">
        <title>Einfaches Setup</title>

        <para>Mit der Benutzung von Adhearsion wird der Dialplan von Asterisk
        recht übersichtlich und kurz. Man muss nur bei jedem eingehenden
        Context die folgende Zeile einfügen:<programlisting>exten =&gt; _.,1,AGI(agi://127.0.0.1)
</programlisting></para>

        <para>Damit übernimmt Adhearsion die Kontrolle über alle Gespräche,
        die in diesem Context geführt werden. Natürlich kann man aber auch
        einen traditionellen Dialplan mit Adhearsion mischen.</para>

        <para>Eine Adhearsion-Applikation muss ähnlich wie bei Ruby on Rails
        erst generiert werden. Dies erfolgt mit dem Programm
        <filename><application>ahn</application></filename>, das mit
        <command>ahn create applikationsname</command> aufgerufen wird.
        Beispiel:<screen>stefan@pbx:~$ <emphasis role="bold"><command>ahn create apfelmus_app</command></emphasis>
      create  
      create  components/simon_game
      create  components/disabled/stomp_gateway
      create  components/ami_remote
      create  components/restful_rpc/spec
      create  config
      create  .ahnrc
      create  components/simon_game/simon_game.rb
      create  components/ami_remote/ami_remote.rb
      create  components/disabled/stomp_gateway/stomp_gateway.rb
      create  components/disabled/stomp_gateway/config.yml
      create  components/disabled/stomp_gateway/README.markdown
      create  components/restful_rpc/restful_rpc.rb
      create  components/restful_rpc/config.yml
      create  components/restful_rpc/README.markdown
      create  components/restful_rpc/example-client.rb
      create  components/restful_rpc/spec/restful_rpc_spec.rb
      create  config/startup.rb
      create  dialplan.rb
      create  events.rb
      create  README
      create  Rakefile
stefan@pbx:~$ <emphasis role="bold"><command>cd apfelmus_app</command></emphasis>
stefan@pbx:~/apfelmus_app$ </screen></para>

        <para>Gestartet wird die Applikation dann mit <command>ahn start
        .</command><screen>stefan@pbx:~/apfelmus_app$ <emphasis role="bold"><command>ahn start .</command></emphasis>
 INFO ahn: Adhearsion initialized!</screen></para>

        <para>Ab diesem Zeitpunkt übernimmt Adhearsion die Kontrolle über
        Anrufe. Sie können dabei auf dem Bildschirm mitverfolgen, was
        passiert.</para>
      </section>

      <section id="adhearsion-beispiel">
        <title>Beispielprogramm</title>

        <para>Der Adhearsion-Dialplan oder besser gesagt das Ruby-Programm
        wird in der Datei <filename>dialplan.rb</filename> definiert. Hier ein
        einfaches Beispiel:<programlisting>intern {
  case extension
  when 22
    play "hello-world"
    hangup
  else
    dial "SIP/#{extension}"
  end
}</programlisting></para>

        <para><code>intern</code> ist in diesem Beispiel der benutzte Context,
        aus dem Adhearsion aufgerufen wurde.</para>
      </section>
    </section>

    <section id="agi-andere-programmiersprachen">
      <title>Andere Programmiersprachen</title>

      <para>Wie am Anfang dieses Kapitels schon erwähnt wurde, kann man
      AGI-Programme in jeder beliebigen Programmiersprache schreiben. Fertige
      Bibliotheken finden sich z. B. für:</para>

      <itemizedlist>
        <listitem>
          <para>Java</para>
        </listitem>

        <listitem>
          <para>Perl</para>
        </listitem>

        <listitem>
          <para>PHP</para>
        </listitem>

        <listitem>
          <para>Python</para>
        </listitem>

        <listitem>
          <para>Ruby</para>
        </listitem>

        <listitem>
          <para>C</para>
        </listitem>
      </itemizedlist>

      <para>Am einfachsten ist eine Suche in der Suchmaschine Ihrer Wahl nach
      den Schlüsselwörtern <quote>AGI</quote> und dem Namen der
      Programmiersprache.</para>
    </section>
  </section>
</chapter>
