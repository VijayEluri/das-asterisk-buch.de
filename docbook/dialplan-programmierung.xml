<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-programmieren" lang="de"
         revision="$Revision: 1.11 $">
  <!--% Copyright (c) 2006 - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Programmieren im Dialplan</title>

  <para>Die Erstellung von intelligenten Funktionen oder Programmen kann
  in Asterisk extern über ein AGI Skript oder intern in der
  <filename>extensions.conf</filename> erfolgen. In diesem Kapitel
  beschäftigen wir uns mit dieser internen Variante.</para>

  <para>In der Konfigurationsdatei <filename>extensions.conf</filename>
  wird der so genannte Dialplan definiert. Dabei ähnelt der Dialplan
  häufig einem BASIC Programm. Der Admin kann in einer einfachen
  Skriptsprache Programmabläufe und damit auch das Routing von
  Telefonaten erstellen. Ohne diesen Dialplan kann weder raus- noch
  reintelefoniert werden!</para>

  <section id="der-context">
    <title>Context</title>

    <para>Der Dialplan wird in verschiedene Abschnitte unterteilt. Diese
    Abschnitte heissen im Asterisk Jargon Contexte. Am Anfang eines
    Dialplanes muss es immer einen <code>[general]</code> Context für
    allgemeine Konfigurationen geben. Danachfolgende Contexte können
    beliebig genannt werden. Die Contexte bilden das Verbindungsstrück
    zwischen der Definition eines Telefones (z.B. SIP oder ISDN) und dem
    Dialplan. Für ein Telefon wird immer ein Context definiert. Beispiel
    aus einer sip.conf: <programlisting>[2000]
type=friend
context=interne-telefone
secret=1234
host=dynamic</programlisting>Das SIP-Telefon mit der Nummer 2000 ruft in
    dieser Konfiguration immer den Context <code>interne-telefone</code>
    auf. Wenn also ein Benutzer mit dem Telefon 2000 eine bestimmte
    Nummer wählt, dann sucht Asterisk im Context
    <code>interne-telefone</code> nach der entsprechenden Extension
    (also der dazu passenden Regel). Ist diese Extension nicht
    vorhanden, passiert auch nichts.</para>

    <section id="context-syntax">
      <title>Syntax</title>

      <para>Ein Context selbst wird eingeleitet als Text in einer
      eckigen Klammer. ''Text'' ist hierbei ein sinnvoller Name, der den
      Context benennt und als spätere Referenz für denselben verwendet
      wird. Alle Zeilen nach einer solchen Einleitung bis zum nächsten
      Context werden als Bestandteil (Regeln, Anweisungen) dieses
      Contextes behandelt:<programlisting>[general]

[interne-telefone]
Regeln, Anweisungen, ...

[apfelmus]
Regeln, Anweisungen, ...</programlisting></para>
    </section>
  </section>

  <section id="die-extension">
    <title>Extension</title>

    <para>Die einzelnen Dialplan-Programme werden Asterisk intern
    Extensions genannt. Eine Extension wird nicht kompiliert, sondern
    bei jedem Durchlauf von Asterisk interpretiert. Das Einlesen erfolgt
    einmalig automatisch während des Startens des Asterisk
    Daemons.<footnote>
        <para>Eine Ausnahme stellt hier die Asterisk RealTime
        Architecture (ARA) da. In einem ARA-System wird der Dialplan in
        einer Datenbank (z.B. MySQL) abgespeichert und dort von Asterisk
        bei jedem Anruf neu eingelesen (also nicht nur einmal beim
        Starten von Asterisk). So können Dialpläne auch im laufenden
        Betrieb ständig geändert werden. Nährere Informationen zu ARA
        finden Sie unter <ulink
        url="http://www.voip-info.org/wiki/view/Asterisk+RealTime"><citetitle>http://www.voip-info.org/wiki/view/Asterisk+RealTime</citetitle></ulink></para>
      </footnote> Das Neu-Einlesen des Dialplanes kann aber auch im
    laufenden Betrieb im Command Line Interface durch den Befehl
    <command>reload now</command> bzw. durch den Befehl
    <command>extensions reload</command> forciert werden.</para>

    <section id="extension-syntax">
      <title>Syntax</title>

      <para>Eine Extension besteht immer aus folgenden Teilen:</para>

      <itemizedlist>
        <listitem>
          <para>Name oder Nummer der Extension</para>
        </listitem>

        <listitem>
          <para>Priorität (also der Programmzeilenzähler)</para>
        </listitem>

        <listitem>
          <para>Applikation. Das ist die Anweisung, die Asterisk
          ausführen soll.</para>
        </listitem>
      </itemizedlist>

      <para><programlisting>exten =&gt; Name,Prioritaet,Applikation()</programlisting></para>
    </section>

    <section id="die-prioritaet">
      <title>Priorität</title>

      <para>Eine typische Extension besteht aus mehreren Schritten.
      Damit Asterisk diese Schritte in der richtigen Reihenfolge
      ausführen kann, braucht es eine Art Zähler. Das erinnert ein wenig
      an frühe BASIC-Programme, die auch am Anfang einer jeden Zeile
      einen solchen Zähler hatten. Dieser Zähler heißt bei Asterisk
      Priorität. Prioritäten werden der Reihenfolge nach abgearbeitet
      (es wird immer +1 gezählt). Wenn die nächste logische Priorität
      (Lücken sind nicht zulässig!) nicht definiert ist bricht Asterisk
      ab.</para>

      <section id="prioritaet-hello-world">
        <title>Ein hello-world Beispiel</title>

        <para>Die folgende Extension wird immer ausgelöst, wenn ein
        Telefon mit dem Context <code>apfelmus</code> die Nummer 8888
        anruft. Asterisk nimmt dann ab, spielt den Sprachbaustein
        hello-world ab und legt auf.<programlisting>[apfelmus]
exten =&gt; 8888,1,Answer()
exten =&gt; 8888,2,Playback(hello-world)
exten =&gt; 8888,3,Hangup()</programlisting></para>
      </section>

      <section id="n-prioritaet">
        <title>n-Priorität</title>

        <para>Seit der Asterisk Version 1.2.0 ist es möglich,
        Prioritäten nicht nur streng mit Zahlen, sondern auch mit dem
        Platzhalter <code>n</code> zu belegen. Der n-Zähler fungiert
        hierbei als ein automatischer Programmzähler. Jedesmal, wenn die
        Programmsteuerung auf die n-Priorität stößt, addiert sie 1 zum
        letzten Wert der Priorität. Dies ist dann hilfreich, falls Sie
        viele aufeinander folgende Regeln definiert haben und Sie eine
        Regel einfügen möchten, denn dann müssen Sie nicht mehr die
        Zähler der nachfolgenden Regeln neu nummerieren. Wenn eine
        normale Extension wie folgt aussieht:</para>

        <programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Wait(2)
exten =&gt; 1234,3,Play(carried-away-by-monkeys)
exten =&gt; 1234,4,Wait(2)
exten =&gt; 1234,5,Hangup()</programlisting>

        <para>kann man die gleiche Extension auch mit der n-Priorität
        definieren:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,n,Wait(2)
exten =&gt; 1234,n,Play(carried-away-by-monkeys)
exten =&gt; 1234,n,Wait(2)
exten =&gt; 1234,n,Hangup()</programlisting></para>

        <para>Dies kann nicht nur an der zweiten Priorität, sondern an
        einer beliebigen Stelle passieren:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Wait(2)
exten =&gt; 1234,3,Play(carried-away-by-monkeys)
exten =&gt; 1234,n,Wait(2)
exten =&gt; 1234,n,Hangup()</programlisting></para>

        <para>Die meisten Beispiele in diesem Buch verwenden die
        traditionelle Art (also ohne die <code>n</code>-Priorität), weil
        es Applikationen (z.B. <code>Dial()</code>) gibt, die eine
        bestimmte Anzahl von Prioritäten (nämlich 101) hochzählen, falls
        ein bestimmtes Ereignis eintritt. Dies ist mit der n-Priorität
        nicht mehr einfach abbildbar.</para>
      </section>

      <section id="prioritaeten-label">
        <title>Prioritäten mit Label</title>

        <para>Es gibt aber auch noch die Möglichkeit, für
        <code>n</code>-Prioritäten Label zu vergeben. Damit sind z.B.
        solche Konstrukte möglich:<programlisting>...
exten =&gt; s,n,GotoIf($[${ACCEPT} = 1 ] ?<emphasis role="bold">yes</emphasis>:<emphasis
              role="bold">no</emphasis>)
exten =&gt; s,n<emphasis role="bold">(yes)</emphasis>,SetVar(MACRO_RESULT=CONTINUE)
exten =&gt; s,n<emphasis role="bold">(no)</emphasis>,System(/bin/rm ${ARG1})</programlisting></para>
      </section>
    </section>

    <section id="regular-expression">
      <title>Regular Expressions</title>

      <para>Mit unserem bisherigen Wissen, müssen wir pro möglicher
      Rufnummer immer eine eigene Extension schreiben. Dies würde schon
      nach kurzer Zeit sehr lange und fehleranfällige Dialpläne nach
      sich ziehen. Sollen z.B. die Rufnummern 100 bis 109 jeweils immer
      den hello-world Sprachbaustein abspielen, so würde die
      extensions.conf wie folgt aussehen:<programlisting>[general]

[apfelmus]
exten =&gt; 100,1,Answer()
exten =&gt; 100,2,Playback(hello-world)
exten =&gt; 100,3,Hangup()

exten =&gt; 101,1,Answer()
exten =&gt; 101,2,Playback(hello-world)
exten =&gt; 101,3,Hangup()

exten =&gt; 102,1,Answer()
exten =&gt; 102,2,Playback(hello-world)
exten =&gt; 102,3,Hangup()

exten =&gt; 103,1,Answer()
exten =&gt; 103,2,Playback(hello-world)
exten =&gt; 103,3,Hangup()

exten =&gt; 104,1,Answer()
exten =&gt; 104,2,Playback(hello-world)
exten =&gt; 104,3,Hangup()

exten =&gt; 105,1,Answer()
exten =&gt; 105,2,Playback(hello-world)
exten =&gt; 105,3,Hangup()

exten =&gt; 106,1,Answer()
exten =&gt; 106,2,Playback(hello-world)
exten =&gt; 106,3,Hangup()

exten =&gt; 107,1,Answer()
exten =&gt; 107,2,Playback(hello-world)
exten =&gt; 107,3,Hangup()

exten =&gt; 108,1,Answer()
exten =&gt; 108,2,Playback(hello-world)
exten =&gt; 108,3,Hangup()

exten =&gt; 109,1,Answer()
exten =&gt; 109,2,Playback(hello-world)
exten =&gt; 109,3,Hangup()
</programlisting></para>

      <para>Unter Verwendung einer regular Expression<tip>
          <para>Definition Regular Expression:</para>

          <para>"Reguläre Ausdrücke (Abk. RegExp oder Regex, engl.
          regular expressions) dienen der Beschreibung von
          (Unter-)Mengen von Zeichenketten mit Hilfe syntaktischer
          Regeln. Sie finden vor allem in der Softwareentwicklung
          Verwendung; für fast alle Programmiersprachen existieren
          Implementierungen." (zitiert aus <ulink
          url="http://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck"><citetitle>http://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck</citetitle></ulink>)</para>
        </tip> sieht der gleiche Dialplan gleich viel handlicher
      aus:<programlisting>[general]

[apfelmus]
exten =&gt; _10X,1,Answer()
exten =&gt; _10X,2,Playback(hello-world)
exten =&gt; _10X,3,Hangup()
</programlisting></para>

      <section id="regular-expression-syntax">
        <title>Syntax</title>

        <para>Eine regular Expression wird immer mit einem Unterstrich
        (_) vor der Expression eingeleitet:<programlisting>exten =&gt; _Regular Expression,Prioritaet,Applikation</programlisting></para>

        <para>Eine regular Expression kann in Asterisk aus den folgenden
        Elementen<footnote>
            <para>Es gibt noch weitere Elemente die im deutschen
            Sprachraum aber im allgemeinen wenig Sinn machen. Aus diesem
            Grund werden sie hier nicht aufgeführt.</para>
          </footnote> bestehen:</para>

        <itemizedlist>
          <listitem>
            <para><code>X</code></para>

            <para>Beliebige Zahl von 0 bis 9.</para>
          </listitem>

          <listitem>
            <para><code>[A-B]</code></para>

            <para>Beliebige Zahl von A bis B. Beispiel für alle Zahlen
            von 1 bis 5:</para>

            <para><programlisting>exten =&gt; _[1-5],1,NoOp(Test)</programlisting></para>
          </listitem>

          <listitem>
            <para><code>[AB]</code></para>

            <para>Die Zahlen A und B. Beispiel für die Zahlen 54 und
            57:<programlisting>exten =&gt; _5[47],1,NoOp(Test)</programlisting></para>
          </listitem>

          <listitem>
            <para><code>.</code></para>

            <para>Beliebige Anzahl von Zeichen (mindestens aber eines).
            Alle Rufnummern die mit einer 0 beginnen können mit
            folgender Extension behandelt werden:<programlisting>exten =&gt; _0.,1,NoOp(Test)</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section id="grundlegende-applikationen">
    <title>Grundlegende Applikationen</title>

    <para>Um die Programmierbeispiele in diesem Kapitel halbwegs
    sinnvoll zu gestalten, benötigen wir folgende Applikationen:</para>

    <itemizedlist>
      <listitem>
        <para><code>Answer()</code></para>

        <para>Die <code>Answer()</code>-Applikation dient dazu einen
        Verbindungsversuch zu akzeptieren. Wenn ein Channel klingelt,
        dann kann <code>Answer()</code> den virtuellen Hörer
        abnehmen.</para>
      </listitem>

      <listitem>
        <para><code>Hangup()</code></para>

        <para><code>Hangup()</code> ist das Gegenstück zu
        <code>Answer()</code>. Die Verbindung wird getrennt, der
        virtuelle Hörer aufgelegt.</para>
      </listitem>

      <listitem>
        <para><code>Playback(Soundfile)</code></para>

        <para>Mit <code>Playback()</code> kann man Sounddateien
        abspielen. Diese finden sich (wenn kein anderes Verzeichnis
        angegeben worden ist) im Verzeichnis
        <filename>/var/lib/asterisk/sounds/</filename>. Die Dateiendung
        wird dabei nicht angegeben (Asterisk sucht sich den optimalen
        Codec selbstständig raus).</para>
      </listitem>

      <listitem>
        <para><code>Wait(Zahl)</code></para>

        <para>Mit <code>Wait()</code> kann man eine Pause abrufen. Die
        Zahl in der Klammer gibt die Anzahl der zu wartenden Sekunden
        an.</para>
      </listitem>

      <listitem>
        <para><code>NoOp(String)</code></para>

        <para>Die Applikation <code>NoOp()</code> macht nichts. NoOP
        steht für No-Operation. Sie ist aber ein praktisches Tool, um
        Dialpläne zu debuggen. Der Inhalt des übergebenen Strings wird
        auf dem CLI (Console) ausgegeben. Im CLI muss dafür aber der
        Verbose Level auf mindestens 4 eingestellt sein (einfach im CLI
        <command>set verbose 4</command> eingeben).</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="variablen">
    <title>Variablen</title>

    <para>Variablen sind Platzhalter für konkrete Werte. Diese konkreten
    Werte sind abhängig von der Definition der Variablen, also dem Typ,
    und können bei Asterisk Zahlen, Buchstaben und Buchstabenfolgen
    sein. Variablen dienen dazu das kompilierte Programm flexibler zu
    gestalten und für unterschiedliche oder wechselnde Einsatzzwecke
    anzupassen. Die Verwendung von Variablen ermöglicht erst den
    individuellen Einsatz eines Programms, ohne die erneute Übersetzung
    des Programmcodes in ein ausführbares Programm.<tip>
        <para>Wer noch nie programmiert hat oder mit Variablen in
        Berührung gekommen ist, sollte sich an dieser Stelle kurz bei
        <ulink
        url="http://de.wikipedia.org/wiki/Variable_%28Programmierung%29"><citetitle>http://de.wikipedia.org/wiki/Variable_%28Programmierung%29</citetitle></ulink>
        in die Materie einlesen.</para>
      </tip> Variablen haben bei Asterisk unterschiedliche Reichweiten.
    Es gibt lokale (im Asterisk Jargon Channel-Variablen genannt)
    Variablen, die Werte nur für den jeweiligen und aktiven Channel
    (also das aktuelle Gespräch) setzen und globale Variablen, die Werte
    für alle Channels setzen. Die bereits von Asterisk vorgesehenen
    Variablen haben wir ja in Form der Parameter in den
    Konfigurationsdateien schon ausführlich kennen gelernt. Neben diesen
    gibt es auch die Möglichkeit eigene Variablen zu definieren und
    diese in den Konfigurationsdateien zu verwenden.</para>

    <section id="variablen-auslesen">
      <title>Variablen in einer Extension auslesen</title>

      <para>Der Wert einer Variable kann immer in der Syntax
      <code>${VARIABLENNAME}</code> ausgelesen werden. Es gibt Variablen
      die vom Asterisk System automatisch gesetzt werden. So wird z.B.
      die angerufene Nummer immer in der Variable <code>EXTEN</code>
      abgespeichert. In Kombination von regular Expressions und Einsatz
      von Variablen kann man somit einen langen Dialplan häufig stark
      komprimieren.</para>

      <para>Beispiel vorher:<programlisting>exten =&gt; 100,1,Dial(SIP/100)
exten =&gt; 101,1,Dial(SIP/101)
exten =&gt; 102,1,Dial(SIP/102)
exten =&gt; 103,1,Dial(SIP/103)
exten =&gt; 104,1,Dial(SIP/104)
exten =&gt; 105,1,Dial(SIP/105)
exten =&gt; 106,1,Dial(SIP/106)
exten =&gt; 107,1,Dial(SIP/107)
exten =&gt; 108,1,Dial(SIP/108)
exten =&gt; 109,1,Dial(SIP/109)
</programlisting></para>

      <para>Beispiel nachher:<programlisting>exten =&gt; _10X,1,Dial(SIP/${EXTEN})</programlisting></para>
    </section>

    <section id="variablen-allgemeines">
      <title>Allgemeines</title>

      <para>Variablennamen müssen nicht wie in unseren Beispielen groß
      geschrieben werden und sind auch nicht an Groß- und
      Kleinschreibung gebunden. Die Großschreibung von Variablen führt
      aber meistens zu besser lesbarem Code, da Sie bereits an der
      Schreibweise erkennen können, dass es sich um eine Variable
      handelt. Umgekehrt bedeutet das aber auch, dass Groß- und
      Kleinschreibung nicht für die Unterscheidung von Variablen
      verwendet werden kann (z.B. EXTEN, Exten, ExTen referenzieren alle
      nur eine Variable).</para>

      <section id="var-strings">
        <title>Strings</title>

        <para>Strings (als Variablen, die keine Zahlen, sondern Text
        enthalten) sollten immer in Anführungszeichen gesetzt werden.
        Asterisk akzeptiert sie aber auch ohne diese Markierung. So sind
        die folgenden zwei Zeilen im Ergebnis gleich:<programlisting>exten =&gt; 1234,1,Set(OBST=Apfel)
exten =&gt; 1234,2,Set(OBST="Apfel")</programlisting></para>

        <para>Sollte der String ein Komma oder ein Leerzeichen
        enthalten, dann <emphasis>müssen</emphasis> Sie
        Anführungszeichen verwenden, da diese sonst als Kommandos und
        nicht als Strings interpretiert werden:<programlisting>exten =&gt; 1234,1,Set(OBSTSORTEN="Apfel, Birne, usw.")</programlisting></para>
      </section>

      <section id="var-quoting">
        <title>Quoting</title>

        <para>Bei einer Variablen, die Zeichen oder Zeichenfolgen
        (Wörter, Text) als Werte enthält, kann es vorkommen, dass man
        bestimmte Zeichen verwenden möchte, die bereits für andere
        Funktionen reserviert sind. Wollen Sie zum Beispiel ein
        Underscore-Zeichen als Bestandteil des Variablenwertes
        verwenden, müssen Sie es besonders kennzeichnen, bzw. maskieren.
        Diese Kennzeichnung nennt man beim Programmieren
        <phrase>escapen</phrase>. Folgende Zeichen müssen auf jeden Fall
        maskiert (''escaped'') werden:<programlisting>[ ] $ " \</programlisting></para>

        <para>Das Quoting in der <filename>extensions.conf</filename>
        erfolgt mit einem vorangestellten <code>\</code>
        (Backslash).</para>

        <para>Beispiel:</para>

        <programlisting>exten =&gt; 1234,1,Set(BETRAG="10,00 US \$")</programlisting>
      </section>

      <section id="var-integer">
        <title>Integer</title>

        <para>Bestehen Variablen aus einer Ganzzahl (Integer) so kann
        diese maximal 18 Stellen betragen. Bei Zahlen, die größer sind,
        tritt ein Fehler auf, der im Logfile protokolliert wird.<tip>
            <para>Wer mit größeren oder Kommazahlen (Real) arbeiten
            will, kann dies mit einem AGI-Skript realisieren (siehe AGI
            Kapitel).</para>
          </tip></para>
      </section>
    </section>

    <section id="globale-var-globals">
      <title>Globale Variablen in der extensions.conf definieren</title>

      <para>Eine globale Variable kann am Anfang der
      <filename>extensions.conf</filename> gesetzt werden. Dies muss im
      besonderen Context <code>[globals]</code> erfolgen (er folgt dem
      Context <code>[general]</code>).</para>

      <para>Beispiel:<programlisting>[general]


[globals]
KLINGELZEIT=90

[from-intern]
exten =&gt; _XXX,1,Dial(SIP/${EXTEN},${KLINGELZEIT})
exten =&gt; _XXX,2,Voicemail(u${EXTEN})
exten =&gt; _XXX,102,Voicemail(u${EXTEN})</programlisting></para>
    </section>

    <section id="global-var-set">
      <title>Variablen mit Set() definieren</title>

      <para>Die Applikation <code><code>Set()</code></code> wird benutzt
      um eine Variable in einer Extension zu setzen.</para>

      <section>
        <title>Syntax</title>

        <para><code>Set(Variablenname=Wert[|Variablenname2=Wert2][|Option])</code></para>

        <para>Als Option kann ein <parameter><code>g</code></parameter>
        angegeben werden. Mit diesem <parameter>g</parameter> kann mit
        <code>Set()</code> eine globale Variable gesetzt werden. Ohne
        diese Option geht Asterisk immer von lokalen Channel-Variablen
        aus.</para>

        <para>Beispiel:</para>

        <programlisting>; Eine globale Variable setzen:
exten =&gt; 10,1,Set(KLINGELZEIT=90|g)

; Eine Channel Variable setzen:
exten =&gt; 10,2,Set(LIEBLINGSOBSTSORTE="Apfel")

; Zwei Channel Variablen auf einmal setzen:
exten =&gt; 10,3,Set(VAR1=10|VAR2=23)

; Die Variablen auf dem CLI ausgeben
exten =&gt; 10,4,NoOp(KLINGELZEIT = ${KLINGELZEIT})
exten =&gt; 10,5,NoOp(LIEBLINGSOBSTSORTE = ${LIEBLINGSOBSTSORTE})
exten =&gt; 10,6,NoOp(VAR1 = ${VAR1})
exten =&gt; 10,7,NoOp(VAR2 = ${VAR2})</programlisting>
      </section>
    </section>

    <section id="var-vererbung">
      <title>Vererbung von Channel Variablen</title>

      <para>Wird im Lauf eines Gespräches ein weiterer Channel
      aufgebaut, so hat dieser natürlich wieder eigene
      Channel-Variablen.</para>

      <section id="var-einstufige-vererbung">
        <title>Einstufige Vererbung</title>

        <para>Will man eine Channel-Variable übergeben, aber keine
        globale Variable dafür benutzen, so kann man der
        Channel-Variable ein <code>_</code> (Underscore) voransetzen.
        Diese Channel-Variable wird dann an den nächsten Channel
        vererbt. Dabei wird der Underscore entfernt. Die Vererbung kann
        also nur einmal erfolgen.</para>

        <para>Beispiel:<programlisting>exten =&gt; 1234,2,Set(_KUCHENSORTE="Marmorkuchen")</programlisting></para>
      </section>

      <section id="var-mehrstufige-vererbung">
        <title>Mehrstufige Vererbung</title>

        <para>Will man eine Channel-Variable beliebig oft vererben, so
        muss man zwei <code>_</code> (Underscore)-Zeichen vor die
        Variable setzten. Die zwei Underscore-Zeichen werden dann immer
        mitvererbt.</para>

        <warning>
          <para>Asterisk unterscheidet die Namen von Variablen, die mit
          einem Underscore anfangen, nicht von Variablen, die keinen
          Underscore haben. So wird im folgenden Beispiel aus der
          vererbbaren Channel-Variable <code>KUCHENSORTE</code> eine
          normale (nicht vererbbare) Channel-Variable:<programlisting>exten =&gt; 1234,1,Set(__KUCHENSORTE="Marmorkuchen")
exten =&gt; 1234,2,Set(KUCHENSORTE="Marmorkuchen")</programlisting></para>
        </warning>

        <para>Beispiel:<programlisting>exten =&gt; 1234,2,Set(__KUCHENSORTE="Nusskuchen")</programlisting></para>

        <para>Bei einem Abruf einer vererbten Channel-Variable ist es
        egal, ob man die Underscores voranstellt oder nicht. Die beiden
        folgenden Zeilen geben zwei mal den gleichen Wert im CLI
        aus:<programlisting>exten =&gt; 1234,1,NoOp(${__KUCHENSORTE})
exten =&gt; 1234,2,NoOp(${KUCHENSORTE})</programlisting></para>
      </section>
    </section>

    <section id="feste-channel-var">
      <title>Feste Channel Variablen</title>

      <para>Die folgende Liste enthält die wichtigsten fest
      einprogrammierten Channel-Variablen, die nicht in der
      <filename>extensions.conf</filename> überschrieben, aber
      ausgelesen werden können:<footnote>
          <para>Eine komplette Liste aller vordefinierten Variablen
          finden Sie in der Datei <filename>doc/README.variables</filename> (1.2) / <filename>doc/channelvariables.txt</filename> (1.4)</para>
        </footnote>Die für das jeweilige Thema interessanten Variablen
      werden aber im Buch immer in jedem Kapitel extra
      aufgeführt.<footnote>
          <para>Ein klassisches Henne-Ei-Problem.</para>
        </footnote></para>

      <para><variablelist termlength="10">
          <?dbfo list-presentation="blocks"?>

          <?dbhtml list-presentation="list"?>

          <varlistentry>
            <term><code>${ANSWEREDTIME}</code></term>

            <listitem>
              <para>Die Gesamtzeit (in Sekunden) seitdem das Gespräch
              zustande gekommen ist.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${BLINTRANSFER}</code></term>

            <listitem>
              <para>Der Name des Channels auf der anderen Seite eines
              Blind-Transfers.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CALLERID(all|name|num)}</code></term>

            <listitem>
              <para>CallerID des Anrufers (wenn diese übermittelt
              wurde).<variablelist spacing="compact" termlength="8">
                  <varlistentry>
                    <term><code>number</code></term>

                    <listitem>
                      <simpara>Nummer des Anrufers</simpara>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term><code>name</code></term>

                    <listitem>
                      <simpara>Name des Anrufers</simpara>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term><code>all</code></term>

                    <listitem>
                      <simpara>Name und Nummer im Format
                      <code><replaceable>Name</replaceable>
                      &lt;<replaceable>Nummer</replaceable>&gt;</code>,
                      z.B. <code>Fritz Meier
                      &lt;2000&gt;</code></simpara>
                    </listitem>
                  </varlistentry>
                </variablelist></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CHANNEL}</code></term>

            <listitem>
              <para>Name des aktuellen Channels.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CONTEXT}</code></term>

            <listitem>
              <para>Name des aktuellen Contextes.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EPOCH}</code></term>

            <listitem>
              <para>Aktueller Unix Style Epoch.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EXTEN}</code></term>

            <listitem>
              <para>Aktuell gewählte Extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${ENV(VARIABLENNAME)}</code></term>

            <listitem>
              <para>Umgebungsvariable <code>VARIABLENNAME</code></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${HANGUPCAUSE}</code></term>

            <listitem>
              <para>Grund für das Beenden (hangup) eines
              Gespräches.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${INVALID_EXTEN}</code></term>

            <listitem>
              <para>Wird in der <code>i</code>-Extension benutzt und
              enthält die gewählte Extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${LANGUAGE}</code></term>

            <listitem>
              <para>Aktuell eingestellte Sprache (z.B. <code>de</code>
              für Deutsch).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${PRIORITY}</code></term>

            <listitem>
              <para>Aktuelle Priorität innerhalb der Extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${TRANSFER_CONTEXT}</code></term>

            <listitem>
              <para>Context eines weiterverbundenen Gespräches.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${UNIQUEID}</code></term>

            <listitem>
              <para>Im System einzigartige (unique) ID für das aktuelle
              Gespräch.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>

    <section id="variablenmanipulation">
      <title>Variablenmanipulation</title>

      <para>Variablen an sich eröffnen ihren Nutzen erst dann, wenn man
      sie zur Laufzeit verändern kann. Mit Hilfe dieser Variabilität
      lassen sich komplexe Verhaltensweisen steuern und vorsehen.</para>

      <section id="var-substring">
        <title>Substring</title>

        <para>In der Regel bezeichnen Strings eine Aneinanderreihung
        einzelner Zeichen (character). Die Größe eines Strings bestimmt
        sich durch die Anzahl der identifizierbaren einzelnen Zeichen.
        Zum Beispiel besteht der String <quote>Apfelbaum</quote> aus 9
        Zeichen. Ein String kann grundsätzlich in so genannte
        Teilstrings zerlegt werden, also Strings, die, wenn man sie
        wieder aneinanderreiht den ursprünglichen String ergeben. Im
        genannten Beispiel könnten wir den String
        <quote>Apfelbaum</quote> in die Teilstrings <quote>Apfel</quote>
        und <quote>baum</quote> zerlegen aber auch <quote>Apf</quote>
        und <quote>elbaum</quote> sind korrekte Teilstrings. Ein String
        hat theoretisch keine begrenzte Größe, er kann beliebig viele
        Zeichen enthalten, der gesamte Text dieses Buches könnte als ein
        String aufgefasst werden. Natürlich wäre das dann nicht mehr
        sehr handlich, dennoch, ist der Vorgang des Zerlegens eines
        Strings in Teilstrings eine Standardprozedur beim Programmieren
        von Anwendungen. In vielen Programmiersprachen heißt die hier
        beschriebene Funktionalität <emphasis>Substring</emphasis>. Mit
        einer Substring-Funktion kann man Teile eines Strings
        ausschneiden und das Ergebnis in einer anderen Variablen
        abspeichern. In Asterisk gibt es keine eigenständige Routine für
        diese Substring-Funktion, sondern hierfür wird ein
        <code>:</code> (Doppelpunkt) nach dem Variablennamen eingesetzt.
        Vom Inhalt der Variablen, also dem String, wird dann eine
        vorgegebene Anzahl von Zeichen (Länge) als Teilstring
        abgetrennt.</para>

        <section id="var-substring-syntax">
          <title>Syntax</title>

          <para><synopsis>${<replaceable>VARIABLENNAME</replaceable>[:<replaceable>Anfang</replaceable>[:<replaceable>Laenge</replaceable>]]}</synopsis></para>
        </section>

        <section id="var-substring-beispiel">
          <title>Beispiele</title>

          <para>Bei einer Telefonanlage wird traditionell eine führende
          0 (Null) gewählt, um eine Amtsleitung zu bekommen. Die zu
          wählende Telefonnummer darf diese 0 aber nicht enthalten. Wird
          die Nummer <code>0030 227 32320</code> gewählt, so kann man
          mit folgender Zeile die eigentliche Rufnummer in die Variable
          <varname>${RUFNUMMER}</varname> abspeichern.<footnote>
              <para>Für alle neugierigen Leser: Das ist die
              Telefonnummer des Parlamentsarchives des Deutschen
              Bundestages in Berlin.</para>
            </footnote> <programlisting>exten =&gt; _0X.,1,Set(RUFNUMMER=${EXTEN:1})</programlisting></para>

          <para>Wenn die Angabe der Länge fehlt, wird automatisch der
          Rest des Strings genommen.</para>

          <para>Wenn wir die letzten 5 Ziffern der gewählten Nummer
          benötigen, dann erreichen wir das mit einer negativen Zahl.
          Bei der oben gewählten Nummer würde die folgende Zeile den
          Wert 32320 in der Variablen <varname>${DURCHWAHL}</varname>
          abspeichern.<programlisting>exten =&gt; _0X.,1,Set(DURCHWAHL=${EXTEN:-5})</programlisting></para>

          <para>Möchten wir die Vorwahl in einer separaten Variable
          abspeichern, so erreichen wir dies durch:<programlisting>exten =&gt; _0X.,1,Set(VORWAHL=${EXTEN:1:3})</programlisting>Diese
          Zeile geht davon aus, dass die Vorwahl 3-stellig ist und
          speichert sie in der Variable
          <varname>${VORWAHL}</varname>.<footnote>
              <para>Leider macht diese Variante in Deutschland wenig
              Sinn, da es unterschiedlich lange Vorwahlen gibt. Mehr
              Informationen zur deutschen Vorwahl finden Sie unter
              <ulink
              url="http://de.wikipedia.org/wiki/Telefonvorwahl_%28Deutschland%29"><citetitle>http://de.wikipedia.org/wiki/Telefonvorwahl_%28Deutschland%29</citetitle></ulink></para>
            </footnote></para>

          <para>Nehmen wir an, wir möchten bei Telefonaten zur Nummer
          <code>00012024562121</code> nach Amerika die einzelnen
          Bestandteile herausfiltern:<footnote>
              <para>Um Ihnen das Gespräch nach Amerika zu sparen: Dies
              ist die Nummer der Besucherzentrale des Weißen Hauses in
              Washington DC. ;-)</para>
            </footnote><programlisting>exten =&gt; _0001X.,1,Set(INTERNATIONALEVORWAHL=${EXTEN:3:1})
exten =&gt; _0001X.,2,Set(ORTSVORWAHL=${EXTEN:4:3})
exten =&gt; _0001X.,3,Set(RUFNUMMER=${EXTEN:7})
exten =&gt; _0001X.,4,Set(DURCHWAHL=${EXTEN:-4}</programlisting></para>
        </section>
      </section>
    </section>
  </section>

  <section id="besondere-extensions">
    <title>Besondere Extensions</title>

    <para>Da sämtliche Programmierlogik über Extensions programmiert
    werden muss, benötigen wir noch eine Reihe von besonderen und vom
    System vorbelegte Extensions.</para>

    <section id="h-extension">
      <title>Die h-Extension</title>

      <para>Das <code>h</code> steht bei dieser Standard-Extension für
      Hangup (Auflegen). Sie wird aufgerufen, sobald ein Gespräch
      beendet wurde. Dabei muss berücksichtig werden, dass dann
      logischerweise der Wert der Variable <varname>${EXTEN}</varname>
      nicht mehr die ursprüngliche Extension, sondern den Wert
      <code>h</code> enthält.</para>

      <section id="h-extension-beispiel">
        <title>Beispiel</title>

        <para>Sollen in der globalen Variable GESPRAECHE immer die
        Anzahl der aktuell geführten Gespräche gespeichert werden, so
        muss diese beim Aufbau eines Gesprächs um 1 erhöht und beim
        Abbau eines Gesprächs (also beim Auflegen) wieder um 1
        runtergezählt werden. Der folgende Dialplan zeigt die
        Grundidee:<programlisting>[global]
GESPRAECHE=0

[from-intern]
exten =&gt; _X.,1,Set(GESPRAECHE=$[${GESPRAECHE} + 1]|g)
exten =&gt; _X.,2,Dial(SIP/${EXTEN})

exten =&gt; h,1,Set(GESPRAECHE=$[${GESPRAECHE} - 1]|g)</programlisting></para>
      </section>
    </section>

    <section id="i-extension">
      <title>Die i-Extension</title>

      <para>Um einen Context "wasserdicht" zu machen, wird die
      <code>i</code>-Extension benutzt. Das <code>i</code> steht dabei
      für invalid (ungültig) und behandelt alle im entsprechenden
      Context nicht definierten Zielrufnummern. Auch hier wird in der
      Variable <code>EXTEN</code> natürlich nicht mehr die angewählte
      Nummer abgebildet. Diese ist mit der Variable
      <code>INVALID_EXTEN</code> abrufbar.</para>

      <section id="i-extension-beispiel">
        <title>Beispiel</title>

        <para>In der Apfelmus GmbH können aus der Abteilung B nur die
        Rufnummern 100 bis 199 angerufen werden. Alle anderen Gespräche
        führen zur Ansage des that-is-not-rec-phn-num
        Bausteines.<footnote>
            <para>Der Sprachbaustein in der Datei
            <filename>that-is-not-rec-phn-num.gsm</filename> im spricht
            den folgenden Text: "That is not a recognized phone
            number".</para>
          </footnote><programlisting>[abteilung-b]
exten =&gt; _1XX,1,Dial(${EXTEN})

exten =&gt; i,1,NoOp(Undefinierte Nummer ${INVALID_EXTEN} wurde gewaehlt.)
exten =&gt; i,2,Answer()
exten =&gt; i,3,Playback(that-is-not-rec-phn-num)
exten =&gt; i,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="o-und-a-extension">
      <title>Die o- und a-Extension</title>

      <para>Wurde in der Konfigurationsdatei
      <filename>voicemail.conf</filename> der Eintrag
      <code>operator=yes</code> gesetzt, so kann innerhalb der
      Voicemailbox durch Drücken der <code>0</code> (Null) die
      <code>o</code>-Extension aufgerufen werden (<code>o</code> für
      Operator).</para>

      <para>Durch Drücken der Stern-Taste (<code>*</code>) kommt man
      hingegen in die <code>a</code>-Extension (abort, Abbruch).</para>
    </section>

    <section id="t-extension">
      <title>Die t- und T-Extension</title>

      <para>Bei den <code>t</code>- und <code>T</code>-Extensions
      handelt es sich jeweils um Timeout-Extensions, also
      Zeitüberschreitungen.</para>

      <section id="klein-t-extension">
        <title>t-Extension</title>

        <para>Erfolgt nach einer bestimmten Zeit in einem IVR-Menü keine
        Eingabe, so wird die <code>t</code>-Extension aufgerufen.</para>

        <para>Beispiel:<programlisting>[hauptmenue]
exten =&gt; 10,1,Answer()
exten =&gt; 10,n,Background(marryme)             ; "Heiraten? 1 für ja, 2 für nein"

exten =&gt; 1,1,Playback(thank-you-cooperation)  ; 1 =&gt; "Danke"
exten =&gt; 1,n,Hangup()

exten =&gt; 2,1,Playback(hangup-try-again)       ; 2 =&gt; "Nochmal probieren"
exten =&gt; 2,n,Hangup()

exten =&gt; t,1,Hangup()                         ; keine Eingabe =&gt; auflegen</programlisting></para>
      </section>

      <section id="gross-t-extension">
        <title>T-Extension</title>

        <para>Die <code>T</code>-Extension wird nach einem Absolute
        Timeout aufgerufen. Dieser kann mit <code>Set(TIMEOUT(absolute)
        = &lt;Sekunden&gt;)</code> gesetzt werden. Der Timeout wird
        immer dann gestartet, wenn der Zähler neu gesetzt wird (es wird
        also nicht automatisch ab Anfang des Gespräches gezählt). Mit
        <code>Set(TIMEOUT(absolute) = 0)</code> wird dieser Timeout
        wieder deaktiviert.</para>

        <para>Beispiel:<programlisting>exten =&gt; 20,1,Answer()
exten =&gt; 20,2,Set(TIMEOUT(absolute) = 120)
exten =&gt; 20,3,Playback(hello-world)
exten =&gt; 20,4,Wait(1)
exten =&gt; 20,5,Goto(3)

exten =&gt; T,1,Wait(1)
exten =&gt; T,2,Playback(thank-you-for-calling)
exten =&gt; T,3,Wait(1)
exten =&gt; T,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="s-extension">
      <title>Die s-Extension</title>

      <para>Der erste Parameter einer Regel (Extension) ist immer der
      Name bzw. die Nummer. Was passiert aber, falls der Anruf auf einer
      klassischen analogen Leitung eintrifft und Asterisk gar nicht
      wissen kann, an wen der Anruf gerichtet ist? Dies ist dann der
      Fall, wenn Sie Asterisk mittels eines analogen Anschlusses an das
      Festnetz anschließen und die Rufnummerweitergabe aus dem Festnetz
      an den analogen Teilnehmeranschluss nicht erfolgt. Für dieses und
      alle anderern Szenarien, in denen der eingehende Anruf ohne eine
      Zielrufnummer ankommt, gibt es die
      <code>s</code>-Extension.<warning>
          <para>Wenn Sie ein ATA-Device, also einen Analog to VoIP
          Adapter benutzen, so benötigen Sie dafür keine
          <code>s</code>-Extension. Die Zielrufnummer müssen Sie hierbei
          im Adapter (meist über ein Webinterface) konfigurieren.</para>
        </warning></para>

      <para>Beispiel:</para>

      <programlisting>exten =&gt; s,1,Answer()
exten =&gt; s,2,Wait(1)
exten =&gt; s,3,Play(carried-away-by-monkeys)
exten =&gt; s,4,Wait(1)
exten =&gt; s,5,Hangup()</programlisting>
    </section>
  </section>

  <xi:include href="applikationen.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="funktionen.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />
</chapter>