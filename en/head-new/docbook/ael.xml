<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="ael" lang="de" revision="$Revision: 1821 $">
  <!--
% Copyright (c) 2009 
% - Philipp Kempgen <philipp.kempgen@amooma.de>
% - Stefan Wintermeyer <stefan.wintermeyer@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de
-->

  <chapterinfo>
    <date>$Revision: 1821 $</date>

    <authorgroup>
      <author>
        <firstname>Philipp</firstname>

        <surname>Kempgen</surname>
      </author>

      <author>
        <firstname>Stefan</firstname>

        <surname>Wintermeyer</surname>
      </author>
    </authorgroup>

    <keywordset>
      <keyword>AEL</keyword>

      <keyword>Asterisk Extension Language</keyword>
    </keywordset>
  </chapterinfo>

  <title>Asterisk Extension Language</title>

  <indexterm significance="preferred">
    <primary>AEL</primary>
  </indexterm>

  <indexterm significance="preferred">
    <primary>Asterisk Extension Language</primary>
  </indexterm>

  <indexterm>
    <primary>Dialplan</primary>

    <secondary>AEL</secondary>
  </indexterm>

  <indexterm>
    <primary>extensions.ael</primary>
  </indexterm>

  <para>As of version 1.4, Asterisk offers two ways of composing the dialplan.
  There is the traditional <filename>extensions.conf</filename> format
  described in <xref linkend="dialplan-basics" /> and <xref
  linkend="chapter-programming" />, and then there is the newer AEL, or
  <quote>Asterisk Extension Language</quote>, which uses the filename
  <filename>extensions.ael</filename>.</para>

  <para>AEL will be of particular interest to those Asterisk users who find
  large <filename>extensions.conf</filename> files difficult to read. AEL
  looks more like a <quote>real</quote> scripting language. They are not
  mutually exclusive, either: it's possible to use both, defining contexts in
  one or the other file. If both files are present,
  <filename>extensions.conf</filename> will simply overwrite identical
  portions of <filename>extensions.ael</filename> when the dialplan is
  loaded.</para>

  <para>Asterisk comes packaged with a command-line utility for converting AEL
  files into the traditional extensions.conf format called
  <command><filename>aelparse</filename></command> (see <xref
  linkend="aelparse" />).</para>

  <note>
    <para>When referring to AEL, we mean AEL2. The first version was
    experimental.</para>
  </note>

  <section id="ael-cli">
    <sectioninfo>
      <keywordset>
        <keyword>ael</keyword>

        <keyword>cli</keyword>
      </keywordset>
    </sectioninfo>

    <title>CLI commands for AEL</title>

    <indexterm>
      <primary>AEL</primary>

      <secondary>CLI</secondary>
    </indexterm>

    <para>The most important Asterisk CLI command for AEL is
    <command><literal>ael reload</literal></command><indexterm>
        <primary>AEL</primary>

        <secondary>reload</secondary>
      </indexterm>. It reads <filename>extensions.ael</filename> into memory
    and is useful if you've made changes to
    <filename>extensions.ael</filename> and wish to apply them without
    restarting Asterisk.</para>

    <screen>*CLI&gt; <command>ael reload</command> </screen>

    <para>The <command><literal>dialplan show</literal></command> command
    described in <xref linkend="dialplan-show" /> displays the aggregate
    dialplan as loaded by Asterisk from <filename>extensions.conf</filename>
    and <filename>extensions.ael</filename>. The source of each dialplan rule
    is displayed in a line, in square brackets, preceding the rule. For rules
    originating from extensions.conf, the line looks like this:</para>

    <para><screen>[ Context 'office-incoming' created by 'pbx_config' ]</screen>or
    for rules originating from extensions.ael, the line looks like
    this:</para>

    <para><screen>[ Context 'queues' created by 'pbx_ael' ]</screen></para>
  </section>

  <section id="aelparse">
    <sectioninfo>
      <keywordset>
        <keyword>aelparse</keyword>

        <keyword>AEL</keyword>
      </keywordset>
    </sectioninfo>

    <title>aelparse</title>

    <indexterm significance="preferred">
      <primary>aelparse</primary>
    </indexterm>

    <para>Asterisk versions as of 1.4 come packaged with the command-line
    utility <command><filename>aelparse</filename></command>. You can use this
    utility to quickly convert <filename>extensions.ael</filename> files into
    <filename>extensions.conf</filename> format, should that ever be
    necessary. Programmers may think of it as a kind of test compiler for AEL,
    a somewhat higher-level "language" than that used in
    <filename>extensions.conf</filename>.</para>

    <para>By default, aelparse reads
    <filename>/etc/asterisk/extensions.ael</filename> unless called with the
    option <literal>-d</literal>, in which case it looks for
    <filename>extensions.ael</filename> in the local directory. If it is
    invoked without option <literal>-n</literal>, it will spit out a lot of
    information that is mostly useful to the Asterisk developers. Use
    <literal>-n</literal> for more concise output, or <literal>-q</literal>
    for output that shows only warnings and errors.</para>

    <tip>
      <para><command><filename>aelparse</filename></command> is useful for
      hunting syntax errors in <filename>extensions.ael</filename>.</para>
    </tip>

    <para>With option <literal>-w</literal>, aelparse dumps the output into
    the file <filename>extensions.conf.aeldump</filename> in the local
    directory.<screen>asterisk:/etc/asterisk# <emphasis role="bold"><command>aelparse -q -w</command></emphasis>
LOG: lev:4 file:ael2_parse  line:543 func: main  19 contexts, 25 extensions, 62 priorities</screen></para>
  </section>

  <section id="extensions.ael">
    <sectioninfo>
      <keywordset>
        <keyword>extensions.ael</keyword>
      </keywordset>
    </sectioninfo>

    <title>Comparing extensions.conf with extensions.ael</title>

    <indexterm>
      <primary>extensions.ael</primary>
    </indexterm>

    <para>The following examples will show you how AEL compares with the
    standard <filename>extensions.conf</filename>. In doing so, we're assuming
    that you're already comfortable with dialplan programming.</para>

    <para>First, you'll see right away that the formatting of extensions is
    different. The structure of extensions.ael is a lot more like a
    programming language. For example, the following two code blocks are
    functionally equivalent. We've made the equivalent portions bold to
    illustrate this.</para>

    <para>Here's a typical context, as it would be written in
    <filename>extensions.conf</filename>:</para>

    <programlisting><emphasis role="bold">[my-phones]</emphasis>
<emphasis role="bold">exten =&gt; 20,1,</emphasis>Answer()
<emphasis role="bold">exten =&gt; 20,n,</emphasis>Playback(beep)
<emphasis role="bold">exten =&gt; 20,n,</emphasis>Hangup()
</programlisting>

    <para>The same result can be achieved in
    <filename>extensions.ael</filename> with this:</para>

    <programlisting><emphasis role="bold">context my-phones {</emphasis>
  <emphasis role="bold">20 =&gt; {</emphasis>
    Answer();
    Playback(beep);
    Hangup();
  <emphasis role="bold">}</emphasis>
<emphasis role="bold">}</emphasis></programlisting>

    <section id="ael-command-termination">
      <title>Line termination</title>

      <para>AEL commands must always end with the
      <quote><code>;</code></quote> (semi-colon) character, since multiple
      commands may appear on a single line. For readability, however, most
      people put each command on a separate line.</para>
    </section>

    <section id="ael-contexts-extensions-priorities">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>contexts</keyword>

          <keyword>extensions</keyword>

          <keyword>priorities</keyword>
        </keywordset>
      </sectioninfo>

      <title>Contexts, Extensions, Priorities</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Contexts, Extensions, Priorities</secondary>
      </indexterm>

      <para>The description of contexts, extensions and priorities is what
      makes AEL different from its predecessor. AEL uses curly braces
      (<quote><code>{ ... }</code></quote>). Numbered priorities
      (<literal>1</literal>, <literal>n</literal>) are no longer required, and
      so we are spared the dubious charms of BASIC style programming in which
      every line must be numbered, as well as the tedious effort of writing
      the same extension number for every priority. In the simple examples
      below, the AEL versions often appear longer, but its advantages can
      really make themselves felt with large dialplans.</para>

      <para>Here's a simple set of extensions in extensions.conf:</para>

      <programlisting><emphasis role="bold">[internal-users]</emphasis>

<emphasis role="bold">exten =&gt; 21,1,</emphasis>Dial(SIP/anna)
<emphasis role="bold">exten =&gt; 21,n,</emphasis>VoiceMail(anna)

<emphasis role="bold">exten =&gt; 22,1,</emphasis>Dial(SIP/lisa)
<emphasis role="bold">exten =&gt; 22,n,</emphasis>VoiceMail(lisa)

<emphasis role="bold">exten =&gt; _3X,1,</emphasis>Dial(SIP/${EXTEN})
</programlisting>

      <para>The same extensions would look like this in
      <filename>extensions.ael</filename>:</para>

      <programlisting><emphasis role="bold">context internal-users {</emphasis>
  <emphasis role="bold">21 =&gt; {</emphasis>
    Dial(SIP/anna);
    VoiceMail(anna);
  <emphasis role="bold">}</emphasis>
  <emphasis role="bold">22 =&gt; {</emphasis>
    Dial(SIP/lisa);
    VoiceMail(lisa);
  <emphasis role="bold">}</emphasis>
  <emphasis role="bold">_3X =&gt; {</emphasis>
    Dial(SIP/${EXTEN});
  <emphasis role="bold">}</emphasis>
<emphasis role="bold">}</emphasis></programlisting>

      <para>For extensions which only need a single command, you can skip one
      level of curly braces and your diaplan would still work:</para>

      <programlisting>context default {
  23 =&gt; Playback(hello-world);
}</programlisting>

      <para>Don't get used to this practice, though. It's best to include them
      always, even when they might be superfluous:</para>

      <programlisting>context default {
  23 =&gt; <emphasis role="bold">{</emphasis>
    Playback(hello-world);
  <emphasis role="bold">}</emphasis>
}</programlisting>

      <para>Most extensions do require multiple commands and consistency is
      your friend when writing code. There are only a few cases where the
      short form is appropriate (<code>jump</code>, see <xref
      linkend="ael-labels-goto-jump" />).</para>

      <warning>
        <para>The opening curly brace <quote><code>{</code></quote> of a code
        block must appear on the same line, not on a line of its own!</para>
      </warning>
    </section>

    <section id="ael-comments">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>comments</keyword>
        </keywordset>
      </sectioninfo>

      <title>Comments</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Comments</secondary>
      </indexterm>

      <para>In extensions.conf, comments are preceded by a
      semi-colon:<programlisting><emphasis role="bold">;</emphasis> a comment
exten =&gt; 10,1,Dial(SIP/anna) <emphasis role="bold">;</emphasis> Dial
</programlisting></para>

      <para>Comments in AEL are denoted with two forward slashes,
      <quote><code>//</code></quote>:</para>

      <para><programlisting><emphasis role="bold">//</emphasis> a comment
10 =&gt; {
  Dial(SIP/anna);  <emphasis role="bold">//</emphasis> Dial
}</programlisting><warning>
          <para>Programmers: don't use the C comment style
          (<quote><code>/*<replaceable> ... </replaceable>*/</code></quote>).
          Every comment line must begin with its own
          <quote><code>//</code></quote> comment marker.</para>
        </warning></para>
    </section>

    <section id="ael-include-contexts">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>includes</keyword>

          <keyword>include</keyword>

          <keyword>context</keyword>
        </keywordset>
      </sectioninfo>

      <title>Includes</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Includes</secondary>
      </indexterm>

      <para>We can include contexts within contexts, just described in <xref
      linkend="dialplan-includes" /> and <xref linkend="time-includes" />. A
      typical use of includes in extensions.conf would look like this:</para>

      <programlisting>[sales]
exten =&gt; 2001,1,Dial(SIP/anna)
exten =&gt; 2002,1,Dial(SIP/brock)

[warehouse]
exten =&gt; 3001,1,Dial(SIP/lisa)

[day]
<emphasis role="bold">include =&gt;</emphasis> sales
<emphasis role="bold">include =&gt;</emphasis> warehouse
</programlisting>

      <para>Doing the same in AEL works this way:</para>

      <programlisting>context sales {
  2001 =&gt; {
    Dial(SIP/anna);
  }
  2002 =&gt; {
    Dial(SIP/brock);
  }
}

context warehouse {
  3001 =&gt; {
    Dial(SIP/lisa);
  }
}

context day {
  <emphasis role="bold">includes {</emphasis>
    sales;
    warehouse;
  <emphasis role="bold">}</emphasis>
}
</programlisting>

      <warning>
        <para>Be careful to write <quote><code>includes</code></quote> and not
        <quote><code>include</code></quote> in AEL!</para>
      </warning>
    </section>

    <section id="ael-global-variables">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>global</keyword>

          <keyword>variables</keyword>

          <keyword>globals</keyword>
        </keywordset>
      </sectioninfo>

      <title>Global variables</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>global variables</secondary>
      </indexterm>

      <para>In AEL, global variables (see <xref
      linkend="programmer-howto-variables" />) are set in a special
      <code>globals</code> block.</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting><emphasis role="bold">[globals]</emphasis>
CAKE=marblecake
RINGTIME=60
</programlisting></entry>

              <entry><programlisting><emphasis role="bold">globals {</emphasis>
  CAKE=marblecake;
  RINGTIME=60;
<emphasis role="bold">}</emphasis></programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="ael-expressions-assignments">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>expressions</keyword>

          <keyword>assignments</keyword>
        </keywordset>
      </sectioninfo>

      <title>Expressions and variable assignment</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>expressions and assignment</secondary>
      </indexterm>

      <para>AEL handles expressions in control structures (such as
      <code>if()</code>, <code>while()</code>, the break condition in
      <code>for()</code> and the right-hand side of variable assignments) as
      though they were contained in a
      <code>$[<replaceable>...</replaceable>]</code> expression (see <xref
      linkend="glossary-expressions" />).</para>

      <para>This seems complicated at first glance but this behavior is common
      in other languages. For variable assignments in Asterisk it is atypical,
      however, and can easily lead to strange errors (AEL isn't a full
      programming language yet!) For this reason, we recommend against writing
      variable assignments this way:</para>

      <programlisting>context test {
  123 =&gt; {
    <emphasis role="bold">result=10/2</emphasis>;
    NoOp(result is ${result});
  }
}</programlisting>

      <para>For predictable results, it's better to use <code>Set()</code>
      (see <xref linkend="applications-set" />) as you might in
      <filename>extensions.conf</filename>:</para>

      <programlisting>context test {
  123 =&gt; {
    <emphasis role="bold">Set(result=$[ 10 / 2 ])</emphasis>;
    NoOp(result is ${result});
  }
}</programlisting>

      <para>For constructions which use <code>if()</code>,
      <code>while()</code> <emphasis>etc</emphasis>, however, the new behavior
      is nevertheless desirable because it spares having to use the clunky
      <quote><code>$[<replaceable> ... </replaceable>]</code></quote>. In
      <filename>extensions.conf</filename>, we would use ExecIf():</para>

      <para><programlisting>exten =&gt; 50,1,Set(a=test)
exten =&gt; 50,n,<emphasis role="bold">ExecIf($["${a}" = "101"]</emphasis>,SayDigits,123)
</programlisting>In <filename>extensions.ael</filename>, the end result is
      cleaner:</para>

      <para><programlisting>50 =&gt; {
  Set(a=test);
  <emphasis role="bold">if ("${a}" = "test")</emphasis> {
    SayDigits(123);
  }
}</programlisting></para>
    </section>

    <section id="ael-labels-goto-jump">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>label</keyword>

          <keyword>labels</keyword>
        </keywordset>
      </sectioninfo>

      <title>Labels, goto and jump</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>labels, goto, jump</secondary>
      </indexterm>

      <para>The hardened <filename>extensions.conf</filename> programmer is
      forced to get used to moving around dialplan by jumping to priorities or
      pre-defined labels using applications such as <code>Goto()</code>,
      <code>GotoIf()</code>, <code>Gosub()</code> and
      <code>GosubIf()</code>:</para>

      <programlisting>[example]

; go to a label in the same extension
;
exten =&gt; 10,1<emphasis role="bold">(begin)</emphasis>,NoOp()
exten =&gt; 10,n,Wait(1)
exten =&gt; 10,n,SayNumber(1)
exten =&gt; 10,n,NoOp(endlessloop)
exten =&gt; 10,n,<emphasis role="bold">Goto(begin)</emphasis>

; go to a label in a different extension
; in the same context
exten =&gt; 20,1,SayNumber(20)
exten =&gt; 20,n,<emphasis role="bold">Goto(10,begin)</emphasis>

; go to a label in a different
; context
exten =&gt; 30,1,SayNumber(30)
exten =&gt; 30,n,<emphasis role="bold">Goto(cntxt2,40,forty)</emphasis>

[cntxt2]

exten =&gt; 40,1<emphasis role="bold">(forty)</emphasis>,NoOp()
exten =&gt; 40,n,SayNumber(40)

exten =&gt; 50,1,<emphasis role="bold">Goto(40,1)</emphasis>
exten =&gt; 60,1,<emphasis role="bold">Goto(example,10,1)</emphasis>
</programlisting>

      <para>In AEL, a label always appears inside an extension and on its own
      line. Don't forget the colon (<quote><code>:</code></quote>) at the end
      of the line:</para>

      <para><programlisting>context example {
  
  // go to a label in the same extension
  //
  10 =&gt; {
   <emphasis role="bold">begin:</emphasis>
    Wait(1);
    SayNumber(10);
    NoOp(endlessloop);
    <emphasis role="bold">goto begin</emphasis>;
  }
  
  // go to a label in a different extension
  // in the same context
  //
  20 =&gt; {
    SayNumber(20);
    <emphasis role="bold">goto 10|begin</emphasis>;
  }
  
  // go to a label in a different context
  //
  30 =&gt; {
    SayNumber(30);
    <emphasis role="bold">goto cntxt2|40|forty</emphasis>;
  }
}

context cntxt2 {
  
  40 =&gt; {
   <emphasis role="bold">forty:</emphasis>
    SayNumber(40);
  }
  50 =&gt; <emphasis role="bold">jump 40</emphasis>;
  60 =&gt; <emphasis role="bold">jump 10@example</emphasis>;
}</programlisting></para>

      <para>In the above example we see a different syntax for the "goto"
      construction. In <filename>extensions.conf</filename>, we had to use the
      <code>Goto()</code> application (see <xref
      linkend="applications-goto" />) but in AEL, it's been replaced by the
      command <code>goto</code> (if you really want to keep using
      <code>Goto()</code>, you can, but why?)</para>

      <para>A comparison of the syntax for <code>Goto()</code> and
      <code>goto</code> shows us they are functionally the same:<informaltable
          colsep="0" frame="none" pgwide="1" rowsep="0" tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="1*" />

            <colspec align="left" colnum="2" colwidth="2*" />

            <tbody valign="top">
              <row>
                <entry><filename>extensions.conf</filename></entry>

                <entry><synopsis><emphasis role="bold"><code>Goto(</code></emphasis>[[<replaceable>context</replaceable><emphasis
                      role="bold"><code>,</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>,</code></emphasis>]<replaceable>label</replaceable><emphasis
                      role="bold"><code>)</code></emphasis></synopsis></entry>
              </row>

              <row>
                <entry><filename>extensions.ael</filename></entry>

                <entry><synopsis><emphasis role="bold"><code>goto </code></emphasis>[[<replaceable>context</replaceable><emphasis
                      role="bold"><code>|</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>|</code></emphasis>]<replaceable>label</replaceable></synopsis></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>The concept of jumping to a specific priority is moot in AEL,
      since priorities aren't used; still, you might have a need to jump to
      another extension, be it in the same or another context. For this
      purpose, AEL includes the additional command
      <code>jump</code>.<informaltable colsep="0" frame="none" pgwide="1"
          rowsep="0" tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="1*" />

            <colspec align="left" colnum="2" colwidth="2*" />

            <tbody valign="top">
              <row>
                <entry><filename>extensions.conf</filename></entry>

                <entry><synopsis><emphasis role="bold"><code>Goto(</code></emphasis>[<replaceable>context</replaceable><emphasis
                      role="bold"><code>,</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>,</code></emphasis><emphasis
                      role="bold"><code>1</code></emphasis><emphasis
                      role="bold"><code>)</code></emphasis></synopsis></entry>
              </row>

              <row>
                <entry><filename>extensions.ael</filename> (replaces priority
                jumping)</entry>

                <entry><synopsis><emphasis role="bold"><code>jump </code></emphasis><replaceable>extension</replaceable>[<emphasis
                      role="bold"><code>@</code></emphasis><replaceable>context</replaceable>]</synopsis></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>In the following sections (<xref linkend="ael-conditionals" /> and
      <xref linkend="ael-loops" />) you'll see that AEL doesn't really need to
      rely on <code>goto</code> statements for control flow, since it has real
      control structures.</para>
    </section>

    <section id="ael-conditionals">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>conditionals</keyword>

          <keyword>if</keyword>

          <keyword>switch</keyword>
        </keywordset>
      </sectioninfo>

      <title>Conditionals</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>if, switch</secondary>
      </indexterm>

      <para>Conditionals are structures which let you control program
      execution.</para>

      <para>AEL has both <emphasis role="bold"> <code>if</code> </emphasis>
      and <emphasis role="bold"> <code>switch</code> </emphasis> commands.
      This is a big advantage because it makes an AEL dialplan much more
      readable. The more complex your program logic, the more obvious this
      advantage becomes.</para>

      <section>
        <title><code>if</code></title>

        <para>In <filename>extensions.conf</filename>, we have to label
        targets explicitly:<programlisting>exten =&gt; 90,1,Dial(SIP/anna)
exten =&gt; 90,n,<emphasis role="bold">GotoIf($["${DIALSTATUS}" = "BUSY"]?b:n)</emphasis>

exten =&gt; 90,10(b),Answer()
exten =&gt; 90,11,Playback(hello-world)
exten =&gt; 90,12,Voicemail(anna,b)
exten =&gt; 90,13,<emphasis role="bold">Goto</emphasis>(end)

exten =&gt; 90,20(n),Dial(SIP/lisa)
exten =&gt; 90,21,Playback(beeperr)
exten =&gt; 90,22,<emphasis role="bold">Goto</emphasis>(end)
exten =&gt; 90,30(end),NoOp(done)
</programlisting>In <filename>extensions.ael</filename>, the
        <command>if</command> statement has fewer parentheses:</para>

        <programlisting>90 =&gt; {
  Dial(SIP/anna);
  <emphasis role="bold">if ("${DIALSTATUS}" = "BUSY") {</emphasis>
    Answer();
    Playback(hello-world)
    Voicemail(anna,b);
  <emphasis role="bold">}</emphasis>
  <emphasis role="bold">else {</emphasis>
    Dial(SIP/lisa);
    Playback(beeperr);
  <emphasis role="bold">}</emphasis>
  NoOp(done);
}</programlisting>

        <para>Someone used to programming in AEL will find jumping around a
        diaplan with <code>GotoIf()</code> cumbersome, to say nothing of the
        confusion caused by a statement like <code>GotoIf($["${DIALSTATUS}" =
        "BUSY"]?b:n)</code>. Are all the brackets closed?</para>

        <warning>
          <para>Again, the opening curly brace must stand on the same line as
          the <code>if</code> statement, not on its own line.</para>
        </warning>
      </section>

      <section>
        <title><code>switch</code></title>

        <para>In AEL, the <command>switch</command> command lets you easily
        build code that can handle more than one case. In
        <filename>extensions.conf</filename>, a construction which does the
        same thing as a <code>switch</code> command is a confusing
        mess:</para>

        <programlisting>exten =&gt; 70,1,Dial(SIP/anna)
exten =&gt; 70,n,<emphasis role="bold">Goto(70-${DIALSTATUS},10)</emphasis>
exten =&gt; 70,n(end),NoOp(done)

exten =&gt; 70-<emphasis role="bold">BUSY</emphasis>,10,NoOp(busy)
exten =&gt; 70-<emphasis role="bold">BUSY</emphasis>,11,<emphasis role="bold">Goto</emphasis>(end)

exten =&gt; 70-<emphasis role="bold">NOANSWER</emphasis>,10,NoOp(no answer)
exten =&gt; 70-<emphasis role="bold">NOANSWER</emphasis>,11,<emphasis
            role="bold">Goto</emphasis>(end)

exten =&gt; <emphasis role="bold">_</emphasis>70-<emphasis role="bold">.</emphasis>,10,NoOp(something else)
exten =&gt; <emphasis role="bold">_</emphasis>70-<emphasis role="bold">.</emphasis>,11,<emphasis
            role="bold">Goto</emphasis>(end)
</programlisting>

        <para>In extensions.ael, by contrast, the result is clean and
        elegant:</para>

        <para><programlisting>70 =&gt; {
  Dial(SIP/anna);
  <emphasis role="bold">switch ("${DIALSTATUS}") {</emphasis>
    <emphasis role="bold">case "BUSY":</emphasis>
      NoOp(busy);
      <emphasis role="bold">break</emphasis>;
    <emphasis role="bold">case "NOANSWER":</emphasis>
      NoOp(no answer);
      <emphasis role="bold">break</emphasis>;
    <emphasis role="bold">default:</emphasis>
      NoOp(something else);
  <emphasis role="bold">}</emphasis>
  
  NoOp(done);
}</programlisting>Trying to do a <emphasis>nested</emphasis> <code>if</code>
        or <code>switch</code> in <filename>extensions.conf</filename> would
        be incomprehensible and impossible to maintain. Now we can really
        start to see the advantages of AEL!</para>

        <warning>
          <para>Don't forget the <code>break</code> statements in the
          <code>case</code> branches! If you omit these, Asterisk will just
          run them sequentially, be it to the next case branch or to
          <code>default</code>.</para>
        </warning>

        <para>In addition to case comparison, <code>switch</code> also lets
        you use <code>pattern</code> statements to do explicit pattern
        matching. Here's what pattern matching looks like in our
        <filename>extensions.conf</filename>:</para>

        <para><programlisting>exten =&gt; _70,1,NoOp(dialed: ${EXTEN})
exten =&gt; _70,n,<emphasis role="bold">Goto(70-${EXTEN},10)</emphasis>

exten =&gt; 70-<emphasis role="bold">703</emphasis>,10,NoOp(703)
exten =&gt; 70-<emphasis role="bold">703</emphasis>,11,<emphasis role="bold">Goto</emphasis>(end)

exten =&gt; 70-<emphasis role="bold">704</emphasis>,10,NoOp(704)
exten =&gt; 70-<emphasis role="bold">704</emphasis>,11,<emphasis role="bold">Goto</emphasis>(end)

exten =&gt; <emphasis role="bold">_</emphasis>70-<emphasis role="bold">70[5-8]</emphasis>,10,NoOp(70[5-8]);
exten =&gt; <emphasis role="bold">_</emphasis>70-<emphasis role="bold">70[5-8]</emphasis>,11,<emphasis
              role="bold">Goto</emphasis>(end)

exten =&gt; <emphasis role="bold">_</emphasis>70-<emphasis role="bold">.</emphasis>,10,NoOp(something else)
exten =&gt; <emphasis role="bold">_</emphasis>70-<emphasis role="bold">.</emphasis>,11,<emphasis
              role="bold">Goto</emphasis>(end)

exten =&gt; 70,n(end),NoOp(done) </programlisting></para>

        <para>In extensions.ael, the pattern syntax is the same, but it is
        preceded by a <code>pattern</code> statement and treated just like a
        case:</para>

        <para><programlisting>_70. =&gt; {
  NoOp(dialed: ${EXTEN});
  <emphasis role="bold">switch (${EXTEN}) {</emphasis>
    <emphasis role="bold">case 703:</emphasis>
      NoOp(703);
      <emphasis role="bold">break</emphasis>;
    <emphasis role="bold">case 704:</emphasis>
      NoOp(704);
      <emphasis role="bold">break</emphasis>;
    <emphasis role="bold">pattern 70[5-8]:</emphasis>
      NoOp(70[5-8]);
      <emphasis role="bold">break</emphasis>;
    <emphasis role="bold">default:</emphasis>
      NoOp(something else);
  <emphasis role="bold">}</emphasis>
  
  NoOp(done);
}</programlisting></para>
      </section>

      <section>
        <title><code>ifTime</code></title>

        <para>The standard application <code>GotoIfTime()</code> (see <xref
        linkend="applications-gotoiftime" />) is replaced with the
        <code>ifTime</code> command.</para>

        <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                       tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="5*" />

            <colspec align="left" colnum="2" colwidth="4*" />

            <tbody valign="top">
              <row>
                <entry> </entry>

                <entry><programlisting>20 =&gt; {
  <emphasis role="bold">ifTime (</emphasis>08:00-18:00|mon-fri|*|*<emphasis
                      role="bold">) {</emphasis>
    Dial(SIP/20);
  <emphasis role="bold">} else {</emphasis>
    Playback(announcement-closed);
    Voicemail(20,s);
  <emphasis role="bold">}</emphasis>
}</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The time syntax is the same as for <code>GotoIfTime()</code>.
        You can accomplish the same thing with the <code>IFTIME()</code>
        function (<xref linkend="functions-iftime" />), though the result is
        not as readable:</para>

        <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                       tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="5*" />

            <colspec align="left" colnum="2" colwidth="4*" />

            <tbody valign="top">
              <row>
                <entry> </entry>

                <entry><programlisting>20 =&gt; {
  <emphasis role="bold">if (</emphasis>${IFTIME(08:00-18:00|mon-fri|*|*?1:0)}<emphasis
                      role="bold">) {</emphasis>
    Dial(SIP/20);
  <emphasis role="bold">} else {</emphasis>
    Playback(announcement-closed);
    Voicemail(20,s);
  <emphasis role="bold">}</emphasis>
}</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section>
        <title><code>random</code></title>

        <para>The <code>random(){...}</code> command takes a value from 1 to
        99. This value is the percentage chance that the subsequent code block
        will be executed. <programlisting>20 =&gt; {
  <emphasis role="bold">random (</emphasis>42<emphasis role="bold">) {</emphasis>
    NoOp(42 % Chance);
  <emphasis role="bold">} else {</emphasis>
    NoOp(58 % Chance);
  <emphasis role="bold">}</emphasis>
}</programlisting></para>

        <para>You can accomplish the same objective with an <code>if</code>
        command and the <code>RAND()</code> function (<xref
        linkend="functions-rand" />) with slightly more code:</para>

        <programlisting>20 =&gt; {
  <emphasis role="bold">if (</emphasis>${RAND(0,100)} &lt; 42<emphasis
            role="bold">) {</emphasis>
    NoOp(42 % Chance);
  <emphasis role="bold">} else {</emphasis>
    NoOp(58 % Chance);
  <emphasis role="bold">}</emphasis>
}</programlisting>
      </section>
    </section>

    <section id="ael-loops">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>loops</keyword>

          <keyword>for</keyword>

          <keyword>while</keyword>
        </keywordset>
      </sectioninfo>

      <title>Loops</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>for, while</secondary>
      </indexterm>

      <para>Like conditionals, loops are control structures.</para>

      <para>AEL has classic <emphasis role="bold"><code>for</code></emphasis>
      and <emphasis role="bold"><code>while</code></emphasis> loops, which
      behave just as they do in other programming languages.</para>

      <section>
        <title><code>while</code></title>

        <para>A <code>while</code> command in AEL is used in much the same way
        as the <code>While()</code> (<xref linkend="applications-while" />)
        and <code>EndWhile()</code> (<xref linkend="applications-endwhile" />)
        applications.</para>

        <para>The <code>break</code> and <code>continue</code> statements
        found in some other languages can also be used in AEL loops. This
        corresponds to the <code>ExitWhile()</code> (<xref
        linkend="applications-exitwhile" />) and <code>ContinueWhile()</code>
        (<xref linkend="applications-continuewhile" />) in
        <filename>extensions.conf</filename>:<programlisting>exten =&gt; 40,1,Set(x=5)
exten =&gt; 40,n,<emphasis role="bold">While($[${x} &lt;= 9])</emphasis>
exten =&gt; 40,n,NoOp(x ist ${x})
exten =&gt; 40,n,ExecIf($[${x} &gt; 5],<emphasis role="bold">ExitWhile</emphasis>)
exten =&gt; 40,n,Playback(beep)
exten =&gt; 40,n,<emphasis role="bold">Set(x=$[${x} + 1])</emphasis>
exten =&gt; 40,n,<emphasis role="bold">EndWhile()</emphasis>
exten =&gt; 40,n,NoOp(done)
</programlisting>In <filename>extensions.ael</filename>, the
        <code>break</code> statement jumps to the end of the loop block,
        <code>continue</code> to the start. In this example, we use
        <code>break</code>:</para>

        <para><programlisting>30 =&gt; {
  x=0;
  <emphasis role="bold">while (${x} &lt;= 9) {</emphasis>
    NoOp(x ist ${x});
    if (${x} &gt; 5) {
      <emphasis role="bold">break</emphasis>;
    }
    Playback(beep);
    <emphasis role="bold">y=${x} + 1</emphasis>;
  <emphasis role="bold">}</emphasis>
  NoOp(done);
}</programlisting></para>

        <note>
          <para>In this example, we needed more lines in AEL; if we had added
          another command to the if condition in our while loop,
          <code>ExecIf()</code> would not be enough anymore and we would be
          forced to use a more complex construction with
          <code>GotoIf()</code>. Our <filename>extensions.conf</filename>
          would be a lot longer.</para>
        </note>
      </section>

      <section>
        <title><code>for</code></title>

        <para>AEL also gives us <code>for</code> loops. This has no
        corresponding application in the <filename>extensions.conf</filename>
        format, though every <code>for</code> loop may be written as a
        <code>while</code> loop:</para>

        <programlisting>exten =&gt; 40,1,<emphasis role="bold">Set(x=5)</emphasis>
exten =&gt; 40,n,<emphasis role="bold">While($[${x} &lt;= 5])</emphasis>
exten =&gt; 40,n,NoOp(x ist ${x})
exten =&gt; 40,n,Playback(beep)
exten =&gt; 40,n,<emphasis role="bold">Set(x=$[${x} + 1])</emphasis>
exten =&gt; 40,n,<emphasis role="bold">EndWhile()</emphasis>
exten =&gt; 40,n,NoOp(done)
</programlisting>

        <para>Even here, <filename>extensions.ael</filename> is more
        compact:</para>

        <para><programlisting>40 =&gt; {
  <emphasis role="bold">for (x=0; ${x}&lt;=5; x=${x}+1) {</emphasis>
    NoOp(x ist ${x});
    Playback(beep);
  <emphasis role="bold">}</emphasis>
  NoOp(done);
}</programlisting></para>
      </section>
    </section>

    <section id="ael-macros">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>macro</keyword>
        </keywordset>
      </sectioninfo>

      <title>Macros</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>macros</secondary>
      </indexterm>

      <para>In extensions.conf, macros or macro-like functions can be achieved
      with <code>Macro()</code> (<xref linkend="applications-macro" />) or
      <code>Gosub()</code> (<xref linkend="applications-gosub" />). Our
      example uses <code>Macro()</code>:</para>

      <para><programlisting><emphasis role="bold">[macro-countdown]</emphasis>
exten =&gt; s,1,Set(c=${ARG1})
exten =&gt; s,n,While($[ ${c} &gt; 0])
exten =&gt; s,n,SayNumber(${c})
exten =&gt; s,n,Set(c=$[ ${c} - 1 ])
exten =&gt; s,n,EndWhile()

[default]
exten =&gt; 123,1,<emphasis role="bold">Macro(countdown,3)</emphasis>
exten =&gt; 124,1,<emphasis role="bold">Macro(countdown,5)</emphasis>
</programlisting></para>

      <para>In AEL, we don't have to choose. It has the <code>macro</code>
      command:</para>

      <para><programlisting><emphasis role="bold">macro countdown( count ) {</emphasis>
  for (c=${count}; ${c}&gt;0; c=${c}-1) {
    SayNumber(${c});
  }
<emphasis role="bold">}</emphasis>

context default {
  123 =&gt; {
    <emphasis role="bold">&amp;countdown(3)</emphasis>;
  }
  124 =&gt; <emphasis role="bold">&amp;countdown(5)</emphasis>;
}</programlisting>The AEL compiler converts <code>macro</code> into a
      <code>Gosub()</code> subroutine internally; fortunately, it's not one we
      have to maintain.</para>
    </section>

    <section id="ael-hints">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>hints</keyword>

          <keyword>hint</keyword>
        </keywordset>
      </sectioninfo>

      <title>Hints</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>hints</secondary>
      </indexterm>

      <para>We cover the implementation of hints in AEL in depth in <xref
      linkend="blf-hints-pickup" />. Here's a simple example to demonstrate
      the proper syntax. In extensions.conf, hints look like this:</para>

      <para><programlisting>[internal-users]
exten =&gt; 21,<emphasis role="bold">hint,SIP/anna</emphasis>
exten =&gt; 21,1,Dial(SIP/anna)

exten =&gt; 22,<emphasis role="bold">hint,SIP/lisa</emphasis>
exten =&gt; 22,1,Dial(SIP/lisa)
</programlisting>In AEL, the hint can encapsulate a reference to the
      device:</para>

      <para><programlisting>context internal-users {
  <emphasis role="bold">hint(SIP/anna)</emphasis> 21 =&gt; {
    Dial(SIP/anna);
  }
  <emphasis role="bold">hint(SIP/lisa)</emphasis> 22 =&gt; {
    Dial(SIP/lisa);
  }
}</programlisting>Here is a similar example, this time using a pattern. In
      extensions.conf, that would look like this:</para>

      <para><programlisting>[internal-users]
exten =&gt; 21,<emphasis role="bold">hint,SIP/21</emphasis>
exten =&gt; 22,<emphasis role="bold">hint,SIP/22</emphasis>

exten =&gt; _2X,1,Dial(SIP/${EXTEN})
</programlisting>In extensions.ael, it would look like this:</para>

      <para><programlisting>context internal-users {
  <emphasis role="bold">hint(SIP/21)</emphasis> 21 =&gt; {}
  <emphasis role="bold">hint(SIP/22)</emphasis> 22 =&gt; {}
  
  _2X =&gt; {
    Dial(SIP/${EXTEN});
  }
}</programlisting>Notice that the pattern is now outside the hint
      parentheses.</para>
    </section>

    <section id="ael-match-caller-id">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>caller-id</keyword>
        </keywordset>
      </sectioninfo>

      <title>Filtering by caller ID</title>

      <para>In <filename>extensions.conf</filename>, the ever-popular
      <quote>ex-girlfriend extension</quote> looks like this:</para>

      <para><programlisting>exten =&gt; 10<emphasis role="bold">/6135303122</emphasis>,1,NoOp(ex-girlfriend)
exten =&gt; 10<emphasis role="bold">/6135303122</emphasis>,n,Busy()

exten =&gt; 10,1,Dial(SIP/dave)
exten =&gt; 10,n,Voicemail(dave)
</programlisting>The AEL syntax that accomplishes the same thing looks like
      this:</para>

      <para><programlisting>10<emphasis role="bold">/6135303122</emphasis> =&gt; {
  NoOp(ex-girlfriend);
  Busy();
}
10 =&gt; {
  Dial(SIP/dave);
  Voicemail(dave);
}</programlisting>If a call comes in from the ex-girlfriend (with the caller
      ID <literal>6135303122</literal>), it is routed to
      <literal>Busy()</literal>. Everybody else gets connected to Dave's
      phone.</para>

      <para>Patterns are allowed here too. With <code>/_613</code> you can
      match the entire area code.</para>
    </section>
  </section>

  <section id="extensions.ael-oder-conf">
    <title>Choosing between extensions.ael and extensions.conf</title>

    <para>Asterisk application developers are left to decide which format is
    the right one. The development roadmap once hinted that AEL would replace
    extensions.conf, but since then Digium has been careful about declaring in
    favor of one over the other. One thing is certain: you cannot understand
    Asterisk well unless you understand <filename>extensions.conf</filename>,
    not least because the bulk of the documentation available on the web is
    written for <filename>extensions.conf</filename>.</para>

    <para>If you don't spend a lot of time doing dialplan programming, you're
    probably better off sticking with <filename>extensions.conf</filename>, at
    least for the foreseeable future. For application developers who work with
    Asterisk a lot, however, AEL has too many time- and headache-saving
    features to justify not trying it out. Even if Digium were to end support
    for AEL (which is highly unlikely) there is always
    <command>aelparse</command> to enable a return to the old
    <filename>.conf</filename> world.</para>
  </section>
</chapter>
