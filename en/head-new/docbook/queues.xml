<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="warteschleifen" lang="en" revision="$Revision: 1387 $">
  <!--% Copyright (c) 2006 
% - Stefan Wintermeyer <sw@amooma.de>
% - Philipp Kempgen <pkempgen@uni-koblenz.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
-->

  <!--% translated from the German by Stephen Bosch <sbosch@vodacomm.ca>-->

  <!--% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Queues<indexterm significance="preferred">
      <primary>Queues</primary>
    </indexterm><indexterm significance="preferred">
      <primary>Call Center</primary>
    </indexterm></title>

  <simpara>A call queue lets you place callers on hold automatically if you
  don't have someone available to answer the phone right away (most of us call
  this "being on hold"). Many customers detest queues. Sadly, there is
  scarcely a business around these days that does not make use of them;
  perhaps they are better than the alternative, which is to not take the call
  at all. Whatever your stance on them, the are part of communications
  reality, so we will describe the configuration and operation of queues in
  Asterisk here.<footnote>
      <simpara>An example queue setup using AEL (Asterisk Extension Language)
      is described in
      <filename>doc/queues-with-callback-members.txt</filename> in Asterisk
      1.4.</simpara>
    </footnote></simpara>

  <para>Four files are important for queues:<variablelist termlength="18">
      <varlistentry>
        <term><filename>queues.conf</filename></term>

        <listitem>
          <simpara>Defines the queues.</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><filename>agents.conf</filename></term>

        <listitem>
          <simpara>Defines agents; these are the staff who take
          calls.</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><filename>musiconhold.conf</filename></term>

        <listitem>
          <simpara>Defines the hold music.</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><filename>extensions.conf</filename></term>

        <listitem>
          <simpara>The dialplan. Calls are directed to the queue using
          <command><code>Queue()</code></command> and agents are added using
          <command><code>AgentLogin()</code></command> or
          <code><command>AgentCallbackLogin()</command></code>.</simpara>
        </listitem>
      </varlistentry>
    </variablelist></para>

  <simpara>A common cause of misunderstanding is the confusion of "queue
  members" with callers. Queue members are always and only agents or queue
  devices, never callers.</simpara>

  <tip>
    <para>For simplicity's sake, we use the term "agents" primarily. You call
    queue members "agents". For someone who comes from the call center
    business, that's a bit confusing, since queue members can also be normal
    SIP extensions.</para>

    <para>You are not required to use agents; instead, you can simply assign
    specific SIP devices to the queue. You do this by writing <code>member
    =&gt; SIP/1001</code> to <filename>queues.conf</filename>, for example;
    alternatively, you can assign the interface dynamically in the dialplan
    with the command <command><code>AddQueueMember()</code></command>. See
    <xref linkend="applications-addqueuemember" />.</para>
  </tip>

  <simpara>Agents may belong to more than one queue, and we want our agents to
  be able to log in at any station (also called "hot-desking").</simpara>

  <simpara>You configure agents in the <filename>agents.conf</filename>
  file:</simpara>

  <para><programlisting>[agents]
;    agent_number,password,name
agent =&gt; 1001,1234,Ron Popeil
agent =&gt; 1002,1234,Don Dinglehopper</programlisting></para>

  <para>Configured agents are added to specific queues in the
  <filename>queues.conf</filename> file:<programlisting>[support-queue]
member =&gt; Agent/1001   ; Add agent 1001 to the support-queue
member =&gt; Agent/1002   ;   ... 1002 ...</programlisting></para>

  <para>The queue itself is invoked through an extension line in
  <filename>extensions.conf</filename>:<programlisting>exten =&gt; 20,1,Queue(support-queue)   ; =&gt; queue
exten =&gt; 25,1,AgentLogin()              ; login after call</programlisting></para>

  <para>This is how it works: agents log in by dialing extension 25, hear
  pleasant music and await callers. Calls to extension 20 are passed into the
  queue and are answered on a first-in, first-out basis. The agent hears a
  tone, and the first caller is connected.</para>

  <section id="warteschleifen-musikextension">
    <title>Extension for testing hold music</title>

    <para>We add the following extension to
    <filename>extensions.conf</filename> for testing to see that the
    music-on-hold is functioning as we expect:<programlisting>exten =&gt; 222,1,Answer()                  
; answer
exten =&gt; 222,n,Set(MUSICCLASS()=default) 
; set music-on-hold class to "default"
exten =&gt; 222,n,WaitMusicOnHold(20)       
; play music-on-hold for 20 seconds
exten =&gt; 222,n,Hangup()                  
; hang-up</programlisting></para>
  </section>

  <section id="musiconhold.conf">
    <title><filename>musiconhold.conf</filename><indexterm
        significance="preferred">
        <primary><filename>musiconhold.conf</filename></primary>
      </indexterm><indexterm significance="preferred">
        <primary>Music on Hold</primary>
      </indexterm></title>

    <simpara>Let's begin with the simplest part: setting up
    music-on-hold.</simpara>

    <sidebar>
      <simpara>Note that the music you use for music-on-hold may be subject
      licensing fees. If you want to be sure you are using music lawfully, you
      can obtain use licenses from the performer's rights organization in your
      country:</simpara>

      <simpara>In the United States, contact:</simpara>

      <itemizedlist>
        <listitem>
          <para>The American Society of Composers, Authors and Publishers
          (ASCAP) <citetitle><ulink
          url="???">http://www.ascap.com</ulink></citetitle></para>
        </listitem>

        <listitem>
          <para>Broadcast Music, Inc. (BMI) <citetitle><ulink
          url="???">http://www.bmi.com</ulink></citetitle></para>
        </listitem>

        <listitem>
          <para>SESAC <citetitle><ulink
          url="???">http://www.sesac.com</ulink></citetitle></para>
        </listitem>
      </itemizedlist>

      <simpara>In Canada, contact:</simpara>

      <itemizedlist>
        <listitem>
          <para>The Society of Composers, Authors and Music Publishers of
          Canada (SOCAN) <citetitle><ulink
          url="???">http://www.socan.ca</ulink></citetitle></para>
        </listitem>
      </itemizedlist>

      <simpara>In the United Kingdom, contact:</simpara>

      <itemizedlist>
        <listitem>
          <para>The MCPS-PRS Alliance <citetitle><ulink
          url="???">http://www.mcps-prs-alliance.co.uk</ulink></citetitle></para>
        </listitem>
      </itemizedlist>

      <simpara>In Australia and New Zealand, contact:</simpara>

      <itemizedlist>
        <listitem>
          <para>The Australasian Performing Right Association
          <citetitle><ulink
          url="???">http://www.apra.com.au</ulink></citetitle></para>
        </listitem>

        <listitem>
          <para>The Australasian Performing Right Association (NZ)
          <citetitle><ulink
          url="???">http://www.apra.com.nz</ulink></citetitle></para>
        </listitem>
      </itemizedlist>

      <simpara>respectively. Generally, license fees for use of music in
      waiting areas and on telephone systems are quite reasonable, so this
      option is worth considering. Alternatively, you can obtain royalty-free
      music from a variety of Internet sources. Finally, you may use the three
      tracks provided with Asterisk.</simpara>
    </sidebar>

    <simpara>Allowed configuration settings are described in the sample
    <filename>musiconhold.conf</filename>. Additional information on MP3 music
    support through <command>mpg123</command> may be found in
    <filename>doc/README.mp3</filename> (1.2) /
    <filename>doc/mp3.txt</filename> (1.4). The optimum sample rate for MP3
    files is 8000 Hz, mono.</simpara>

    <para>Here is the simplest possible configuration, using only one music
    class (<code>default</code>):<programlisting>[default]
mode=quietmp3
directory=/var/lib/asterisk/mohmp3</programlisting>Now we stop and start
    Asterisk, for example, using <command>asterisk -rx "restart
    now"</command>, to activate the new extension and the audio streams (a
    reload is not sufficient). Now, if you call extension 222 (as defined
    above), you should hear music-on-hold.</para>

    <para>Still, the following is a better configuration, for which we create
    another music directory <filename>moh-native</filename> in
    <filename>/var/lib/asterisk/</filename>:<programlisting>[default]
mode=files   ; Read music files in an Asterisk native format
directory=/var/lib/asterisk/moh-native
random=yes   ; Play music files in random order</programlisting>For this, it
    is necessary to convert the source MP3 files into an Asterisk compatible
    format, which can be accomplished using <command>sox</command> and
    <command>lame</command>.</para>

    <para><command>sox</command> (<ulink
    url="http://sox.sourceforge.net/">http://sox.sourceforge.net/</ulink>) is
    available as a Debian package, and is installed thus:<screen><prompt>$  </prompt>apt-get install sox</screen></para>

    <para>For MacOS X, if you have installed Darwinports (<ulink
    url="http://darwinports.opendarwin.org/">http://darwinports.opendarwin.org/</ulink>
    or <ulink url="http://darwinports.com/">http://darwinports.com/</ulink>)
    there is also a package:<screen><prompt>$  </prompt>port install sox</screen></para>

    <para>Many other distributions have sox packages; in the absence of
    packages, you must install it from source.</para>

    <simpara><command>lame</command> (<ulink
    url="http://lame.sourceforge.net/">http://lame.sourceforge.net/</ulink>)
    is not available as a Debian package, so we must download and install it
    using the familiar <command>./configure</command>, <command>make</command>
    and <command>make install</command> commands.</simpara>

    <para>For MacOS X, there is a Darwinports package (see
    <command>sox</command>):<screen><prompt>$  </prompt>port install lame</screen>
    or via Fink (<ulink
    url="http://fink.sourceforge.net/">http://fink.sourceforge.net/</ulink>):<screen><prompt>$  </prompt>fink install lame</screen>Of
    course, you can do this with the FinkCommander GUI also.</para>

    <para>Once you've installed the necessary applications, you can create the
    music files this way:</para>

    <para><screen><prompt>$  </prompt>lame --decode music.mp3 music.wav
<prompt>$  </prompt>sox -V music.wav -r 8000 -c 1 -w music.raw
<prompt>$  </prompt>sox -V music.wav -r 8000 -c 1 -w music.gsm</screen>This
    converts our (dummy, only for demonstration)
    <filename>music.mp3</filename> file into WAV, and then into RAW and GSM
    formats (with a sample rate of 8 kHz). We can also make versions of the
    file in alaw and ulaw formats (by using the <filename>.al</filename> and
    <filename>.ul</filename> file extensions with <command>sox</command>) -
    Asterisk will automatically choose the sound file requiring the least
    processing. The important common factor is that the sample rate always be
    8000 Hz.</para>

    <important>
      <para>If you do not specify <code>autoload</code> in
      <filename>modules.conf</filename>, you must ensure that the modules for
      the formats you wish to use here are loaded <emphasis>before</emphasis>
      <filename>res_musiconhold</filename>.</para>
    </important>

    <para>For our test, we copied the WAV files provided in
    <filename>moh/</filename> to <filename>moh-native/</filename>, transcoded
    them to RAW and GSM formats using <command>sox</command>, and then deleted
    the WAV files (which caused us problems) from the
    directory:<programlisting><prompt>$  </prompt>cd /var/lib/asterisk/moh-native/
<prompt>$  </prompt>for i in *.wav; do \
sox $i -r 8000 -c 1 $(basename $i .wav).raw; \
sox $i -r 8000 -c 1 $(basename $i .wav).gsm; \
done
<prompt>$  </prompt>rm *.wav</programlisting></para>

    <para>For CPU-critical installations (<emphasis>e.g.</emphasis>, large
    installations), you should take time to read
    <filename>contrib/utils/README.rawplayer</filename>, which may be found in
    the Asterisk source directory.</para>

    <para>Additional music classes may be defined. For example, in addition to
    <code>[default]</code>, you might choose to classify by genre,
    <emphasis>e.g.</emphasis> <code>[rock]</code>, and provide a different
    file path (perhaps a sub-path) where files of that genre are located. You
    might also classify by intended audience, particularly if you have custom
    files with announcements directed at specific types of customer. As
    always: don't forget to <command>reload</command>!</para>
  </section>

  <section id="queues.conf">
    <title><filename>queues.conf</filename><indexterm significance="preferred">
        <primary><filename>queues.conf</filename></primary>
      </indexterm></title>

    <simpara>Queues are defined and configured in
    <filename>queues.conf</filename>. This file is - as you are already
    familiar - divided into sections.</simpara>

    <simpara>Under <code>[general]</code>, we always set
    <code>persistentmembers = yes</code>, so that agents are re-added to their
    respective queues when Asterisk is started.</simpara>

    <simpara>Every queue goes in its own section. In our example, we are
    configuring a support queue in its own section, <code>[support]</code>.
    The following parameters are available to us:</simpara>

    <itemizedlist>
      <listitem>
        <para><code>musiconhold</code></para>

        <para>Sets the music class of the queue. We choose the
        above-configured <code>default</code>:<programlisting>musiconhold=default</programlisting></para>
      </listitem>

      <listitem>
        <para>announce</para>

        <para>Defines an audio file which is played back to the agent before a
        call is answered. This is so that an agent working in more than one
        queue will know which queue the incoming call is coming from and be
        able to answer appropriately.<programlisting>;announce = queue-support</programlisting>If
        you use this option, remember to place a corresponding announcement
        audio file in the <filename>sounds/</filename> directory,
        <emphasis>e.g.</emphasis>
        <filename>queue-support.gsm</filename>.</para>
      </listitem>

      <listitem>
        <para>strategy</para>

        <para>Sets the call distribution strategy, <emphasis>i.e.</emphasis>
        the method used to decide how incoming calls are distributed to
        agents:<variablelist termlength="13">
            <varlistentry>
              <term><code>ringall</code></term>

              <listitem>
                <simpara>Ring all agents until one answers (default)</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>roundrobin</code></term>

              <listitem>
                <simpara>Ring agents in order, until one answers.</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>leastrecent</code></term>

              <listitem>
                <simpara>Ring the agent who has been idle the
                longest.</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>fewestcalls</code></term>

              <listitem>
                <simpara>Ring the agent who has taken the least number of
                calls in this queue.</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>random</code></term>

              <listitem>
                <simpara>Ring a random agent.</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>rrmemory</code></term>

              <listitem>
                <simpara>Round-robin with memory. Begins the round-robin
                starting with the agent who is next in-line after the last
                call.</simpara>

                <note>
                  <para>Asterisk 1.6 is expected to do away with the current
                  <code>roundrobin</code> method; <code>rrmemory</code> will
                  be renamed <code>roundrobin</code>.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist></para>

        <para>Agents with a lower penalty will always be preferred in all
        strategies.<programlisting>strategy = ringall</programlisting>The
        appropriate setting depends on the circumstances; <code>ringall</code>
        can be extremely annoying for agents, while other values can lead to
        longer wait times for callers, if agents fail to answer.</para>
      </listitem>

      <listitem>
        <para>servicelevel</para>

        <para>Sets the service level threshold; <emphasis>i.e.</emphasis> sets
        the maximum wait time for callers. This is only really useful for
        statistical analysis (for example, in asking the question "How many
        calls were answered within the service level threshold of
        <replaceable>x</replaceable> seconds?").<programlisting>servicelevel = 60</programlisting></para>
      </listitem>

      <listitem>
        <para>context</para>

        <para>If set, this is the context we pass the caller to if she presses
        a single digit while waiting in the queue. This digit is treated as an
        extension and the call is taken out of the queue and routed to the
        extension in that context.<programlisting>context = supportqueue-context  ; we could set it like this

; but we will leave it commented out:
;context = supportqueue-Context</programlisting></para>
      </listitem>

      <listitem>
        <para>timeout</para>

        <para>Sets the maximum time a telephone may ring before we treat it as
        unattended.<programlisting>timeout = 15</programlisting></para>
      </listitem>

      <listitem>
        <para>retry</para>

        <para>Sets the interval (in seconds) before we ring all the agents
        again.<programlisting>retry = 5</programlisting></para>
      </listitem>

      <listitem>
        <para>weight</para>

        <para>The relative importance of the queue compared to other queues.
        If an agent is a member of multiple queues, calls from higher-weight
        queues are connected first. For example, you might give an emergency
        queue higher weight.<programlisting>weight = 0</programlisting></para>
      </listitem>

      <listitem>
        <para>wrapuptime</para>

        <para>The time interval after an agent has finished a call before the
        system will pass another call to the agent (default:
        0).<programlisting>; we allow our agent a quick pause for throat-clearing
; and a drink of water, then it's BACK TO WORK! *whip crack*
wrapuptime = 10</programlisting></para>
      </listitem>

      <listitem>
        <para>maxlen</para>

        <para>Maximum number of callers allowed to be waiting in the queue
        (default: 0 meaning unlimited).<programlisting>maxlen = 0</programlisting></para>
      </listitem>

      <listitem>
        <para>announce-frequency</para>

        <para>Sets how often a caller will hear an announcement indicating her
        position in the queue or the estimated wait time (0 turns this
        completely off).<programlisting>announce-frequency = 90</programlisting></para>
      </listitem>

      <listitem>
        <para>announce-holdtime</para>

        <para>Sets whether the estimated wait time will be announced after the
        queue position. Possible values are <code>yes</code>, <code>no</code>
        or <code>once</code>.<programlisting>announce-holdtime = yes</programlisting></para>
      </listitem>

      <listitem>
        <para>announce-round-seconds</para>

        <para>Rounding level for wait-time announcements. If 0, only minutes,
        not seconds, are announced; other possible values are 0, 1, 5, 10, 15,
        20 and 30.<footnote>
            <para>Older versions accepted other values, which could result in
            confusing announcements. See see <ulink
            url="http://bugs.digium.com/view.php?id=9514">Bug
            9514</ulink>.</para>
          </footnote>For example, when set to 30, a wait time of 2:34 will be
        rounded to 2:30.<programlisting>announce-round-seconds = 0</programlisting></para>
      </listitem>

      <listitem>
        <para>periodic-announce-frequency</para>

        <para>Sets the interval, in seconds, for periodic announcements
        (<code>periodic-announce</code>, e.g. "We thank you for your patience;
        all our agents are currently serving other callers. Please continue to
        hold").<programlisting>periodic-announce-frequency = 60</programlisting></para>
      </listitem>

      <listitem>
        <para>monitor-format</para>

        <para>When set, recording (as with the
        <command><code>Monitor()</code></command> application) is turned on
        and the recording format defined. (If not defined, recording is off.)
        You may specify <code>gsm</code>, <code>wav</code> (caution: huge
        files!) or <code>wav49</code>.<programlisting>; if you want recordings, uncomment this line:
;monitor-format = gsm</programlisting></para>

        <simpara>By default, files are named (one <filename>-in</filename> and
        one <filename>-out</filename>) according to <code>${UNIQUEID}</code>.
        You can change this as needed by putting
        <code>Set(MONITOR_FILENAME=<replaceable>filename</replaceable>)</code><code>
        before Queue()</code> in <filename>extensions.conf</filename>. We
        leave it unset in our example.</simpara>

        <simpara>For more information on call recording, see <xref
        linkend="applications-monitor" />.</simpara>
      </listitem>

      <listitem>
        <para>monitor-join</para>

        <para>Combines the
        <filename><replaceable>...</replaceable>-in</filename> and
        <filename><replaceable>...</replaceable>-out</filename> files of a
        recording into one file. Allowed values: <code>yes</code> or
        <code>no</code>.<programlisting>monitor-join = yes</programlisting>For
        more information on call recording, see <xref
        linkend="applications-monitor" />.</para>
      </listitem>

      <listitem>
        <para>joinempty</para>

        <para>Sets whether callers can be placed in a queue with no
        agents.<variablelist termlength="8">
            <varlistentry>
              <term><code>yes</code></term>

              <listitem>
                <simpara>Callers may be placed in queues without active agents
                (the queue may have no agents logged in, or agents may be
                logged in but unavailable).</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>no</code></term>

              <listitem>
                <simpara>Callers may not be placed in queues without active
                agents.</simpara>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><code>strict</code></term>

              <listitem>
                <simpara>Callers may <emphasis>not</emphasis> be placed in a
                queue without agents, but <emphasis>may</emphasis> be placed
                in a queue with <emphasis>unavailable</emphasis>
                agents.</simpara>

                <simpara>Unavailable should not be confused with busy (that
                is, on a call). An agent is unavailable if he is a member of
                the queue but not currently registered on the system (see also
                <xref linkend="queues.conf-member" />).</simpara>

                <warning>
                  <simpara>Statically defined queue members (see <xref
                  linkend="queues.conf-member" />) are always considered
                  available. If you're not mindful, callers could end up in an
                  active queue that is never answered -- that's probably bad
                  for business.</simpara>
                </warning>
              </listitem>
            </varlistentry>
          </variablelist>If the caller is not accepted into a queue,
        <code><command>Queue()</command></code> ends and execution continues
        in the next priority in the dialplan.<programlisting>joinempty = no  ; we don't want our callers waiting in empty queues.</programlisting></para>
      </listitem>

      <listitem>
        <para>leavewhenempty</para>

        <para>Sets whether waiting callers are removed from the queue when all
        the agents have logged out. Allowed values are the same as for
        <code>joinempty</code>. After leaving the queue, execution continues
        in the next priority in the dialplan.<programlisting>leavewhenempty = strict  ; don't make 'em wait</programlisting></para>
      </listitem>

      <listitem>
        <para>eventwhencalled</para>

        <para>Sets whether events are created in the Manager interface:
        <literal>AgentCalled</literal>, <literal>AgentDump</literal>,
        <literal>AgentConnect</literal>, <literal>AgentComplete</literal>.
        Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>eventwhencalled = yes</programlisting></para>
      </listitem>

      <listitem>
        <para>eventmemberstatus</para>

        <para>Sets whether QueueMemberStatus-Events are created in the Manager
        interface (use with caution -- this can generate a lot of events!).
        Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>eventmemberstatus = no</programlisting></para>
      </listitem>

      <listitem>
        <para>reportholdtime</para>

        <para>Sets whether the wait time for the incoming caller will be
        announced to the agent before the call is patched. Some people like to
        know how long a caller has been waiting, because that caller might be
        irate. Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>reportholdtime = no</programlisting></para>
      </listitem>

      <listitem>
        <para>memberdelay</para>

        <para>Sets the interval of silence (in seconds) that the caller hears
        before she is connected with an agent.<programlisting>memberdelay = 1</programlisting></para>
      </listitem>

      <listitem>
        <para>timeoutrestart</para>

        <para>Sets whether the answer-timeout of an agent is reset after a
        <literal>BUSY</literal> or <literal>CONGESTION</literal> signal. This
        can be useful for agents who are allowed to refuse
        calls.<programlisting>timeoutrestart = yes</programlisting></para>
      </listitem>

      <listitem>
        <para>autopause</para>

        <para>Sets whether an agent who has failed to answer is automatically
        paused or not.<programlisting>autopause = no</programlisting></para>
      </listitem>

      <listitem>
        <para>ringinuse</para>

        <para>Sets whether agents who are in a call will be rung. So far, the
        only channel driver which provides this information is
        SIP.<programlisting>ringinuse = no</programlisting></para>
      </listitem>

      <listitem>
        <para>member</para>

        <para>It is possible to statically define agents in
        <filename>queues.conf</filename> like so:</para>

        <para><code>member =&gt;
        <replaceable>technology</replaceable>/<replaceable>resource</replaceable>[,<replaceable>penalty</replaceable>]</code></para>

        <para>An example using a Zap channel would look like this:</para>

        <programlisting><code>member =&gt; Zap/2</code></programlisting>

        <para>This may be used more than once; see
        <filename>queues.conf</filename>. It should be employed with caution
        with <code>joinempty</code> and <code>leavewhenempty</code>, since
        these queue members are always treated as available, even if the
        telephone is unattended. The other disadvantage is that an agent is
        always bound to a specific workstation and cannot log in at another
        workstation.</para>

        <para>In our example, we prefer to use the dynamic agents and add
        agents in the format<programlisting>member =&gt; Agent/<replaceable>agentID</replaceable></programlisting>For
        two agents <code>1001</code> and <code>1002</code>, the configuration
        looks like this:<programlisting>member =&gt; Agent/1001
member =&gt; Agent/1002</programlisting>These agents must still be defined in
        <filename>agents.conf</filename> (see below). The agent number is a
        freely selectable number which uniquely identifies each agent. The
        number has nothing to do with the extensions that the agent may
        eventually use.</para>
      </listitem>
    </itemizedlist>

    <section id="queues.conf-sprachbausteine">
      <title>Announcement sound files</title>

      <para>The following parameters define which sound files are used for
      which announcement types. Usually there is no need to change this. For
      example:</para>

      <para>queue-youarenext=<replaceable>sound_filename</replaceable></para>

      <para>sets the filename for the "you are first in line" message to
      <replaceable>sound_filename</replaceable>.</para>

      <para>If these parameters are not provided, the default values (shown
      below) apply.</para>

      <itemizedlist>
        <listitem>
          <para><code>queue-youarenext=queue-youarenext</code></para>

          <para>"You are now first in line."</para>
        </listitem>

        <listitem>
          <para>queue-thereare = queue-thereare</para>

          <para>"There are" ...</para>
        </listitem>

        <listitem>
          <para>queue-callswaiting = queue-callswaiting</para>

          <para>"calls waiting."</para>
        </listitem>

        <listitem>
          <para>queue-holdtime = queue-holdtime</para>

          <para>"The current estimated hold time is"</para>
        </listitem>

        <listitem>
          <para>queue-minutes = queue-minutes</para>

          <para>"minutes"</para>
        </listitem>

        <listitem>
          <para>queue-seconds = queue-seconds </para>

          <para>"seconds"</para>
        </listitem>

        <listitem>
          <para>queue-thankyou = queue-thankyou</para>

          <para>"Thank you for your patience."</para>
        </listitem>

        <listitem>
          <para>queue-lessthan = queue-less-than</para>

          <para>"less than"</para>
        </listitem>

        <listitem>
          <para>queue-reporthold = queue-reporthold</para>

          <para>"Hold time"</para>
        </listitem>

        <listitem>
          <para>periodic-announce = queue-periodic-announce</para>

          <para>"All reps busy, wait for next available"</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="agents.conf">
    <title><filename>agents.conf</filename><indexterm significance="preferred">
        <primary><filename>agents.conf</filename></primary>
      </indexterm><indexterm>
        <primary>Agenten</primary>
      </indexterm></title>

    <simpara>Agents (who are also called queue members), are defined in
    <filename>agents.conf</filename>; additional configurations for the agents
    are also placed here. Like the other configuration files, it too is
    divided into sections.</simpara>

    <simpara>We set <code>persistentagents = yes</code> in the
    <code>[general]</code> section, so that agent logins persist (meaning they
    are stored in the Asterisk database) even if Asterisk is
    restarted.</simpara>

    <simpara>We set additional parameters in the <code>[agents]</code>
    section, where we also define the agents. The following parameters are
    available:</simpara>

    <itemizedlist>
      <listitem>
        <para>autologoff</para>

        <simpara>Sets the maximum time a telephone may ring before the agent
        is automatically logged off.</simpara>

        <simpara>Note that agents will not be logged out if the
        <code>autologoff</code> interval is longer than the queue timeout!
        (see <xref linkend="queues.conf-timeout" />) We set that to 15
        seconds, so we set <code>autologoff</code> to 14.</simpara>

        <programlisting>autologoff = 14</programlisting>
      </listitem>

      <listitem>
        <para>ackcall</para>

        <para>Sets whether agents who have logged in with
        <code>AgentCallbackLogin()</code> must press number sign
        (<code>#</code>) to accept a call. Be aware that the voice prompt in
        previous Asterisk versions did not indicate that the agent has to
        press #. Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>ackcall = no</programlisting></para>
      </listitem>

      <listitem>
        <para>endcall</para>

        <para>Sets whether agents may end calls by pressing number sign (#).
        Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>endcall = yes</programlisting></para>
      </listitem>

      <listitem>
        <para>wrapuptime</para>

        <para>Sets (same as <code>wrapuptime</code> in queues.conf; why this
        appears in both files is not clear) the wait time, this time in
        <emphasis>milliseconds</emphasis>, before an agent can be sent another
        call. Default: 5000.<programlisting>wrapuptime = 5000   ; 5 seconds to clear your throat</programlisting></para>
      </listitem>

      <listitem>
        <para>musiconhold</para>

        <para>Sets the music-on-hold class for the agents.<programlisting>musiconhold = default</programlisting></para>
      </listitem>

      <listitem>
        <para>updatecdr</para>

        <para>Adds agent information to the CDR so that we can see which agent
        answered the call. Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>updatecdr = yes</programlisting></para>
      </listitem>

      <listitem>
        <para>recordagentcalls</para>

        <para>Record agent calls. Possible values are <code>yes</code> and
        <code>no</code>. Default: <code>no</code>.<programlisting>recordagentcalls = no</programlisting></para>
      </listitem>

      <listitem>
        <para>recordformat</para>

        <para>Format for call recordings. Possible values are
        <code>gsm</code>, <code>wav</code> (caution, huge files!) or
        <code>wav49</code>. Default: <code>wav</code>.<programlisting>recordformat = gsm</programlisting></para>
      </listitem>

      <listitem>
        <para>createlink</para>

        <para>Sets whether the filename of the call recording will be written
        to the user field of the CDR, so that the call recording can be
        matched to the CDR later. Possible values are <code>yes</code> and
        <code>no</code>.<programlisting>createlink = yes</programlisting></para>
      </listitem>

      <listitem>
        <para>urlprefix</para>

        <para>If <code>createlink = yes</code>, the filename can be prefixed
        with a URL where the recording is made available on a web
        server.<programlisting>; an example might look like this:
;urlprefix = http://astbox/anrufe/</programlisting></para>
      </listitem>

      <listitem>
        <para>savecallsin</para>

        <para>Defines the path where recordings are saved. Default:
        <filename>/var/spool/asterisk/monitor</filename><programlisting>; Say we wanted to save recordings in /var/calls/:
;savecallsin = /var/calls</programlisting></para>
      </listitem>

      <listitem>
        <para>agent</para>

        <para>Defines individual agents. Can appear more than
        once.<programlisting>; Format: agent =&gt; agent_id,password,name
agent =&gt; 1001,0000,John Safran
agent =&gt; 1002,0000,Rove McManus</programlisting></para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="warteschleifen-extensions.conf">
    <title><filename>extensions.conf</filename><indexterm
        significance="normal">
        <primary><filename>extensions.conf</filename></primary>
      </indexterm></title>

    <para>Both agent and caller access to the queue are configured in the
    dialplan (<xref linkend="chapter-programming" />). Agents log in as queue
    members via particular extensions, and callers are placed into the queue
    with the <code>Queue()</code> application (<xref
    linkend="applications-queue" />).</para>

    <section>
      <title>Sending callers to the queue</title>

      <para>A minimal extension, which places callers in the queue, might look
      like this:<programlisting>exten =&gt; 20,1,Answer()                   
; answer
exten =&gt; 20,n,Set(MUSICCLASS()=default)  
; set music class "default"
exten =&gt; 20,n,Queue(support,t)           
; place call in "support" queue
exten =&gt; 20,n,Hangup()                   
; hang-up</programlisting></para>

      <para>We prefer something more complete and use this
      extension:<programlisting>exten =&gt; 20,n,Wait(2)
exten =&gt; 20,n,Answer()                   
; answer
exten =&gt; 20,n,Set(MUSICCLASS()=default)  
; set music class default
exten =&gt; 20,n,Queue(support,t)           
; place call in "support" queue
; a reminder: the option t allows the agent to 
; transfer calls to another extension
; if call can't be placed in queue,
; Queue() sets QUEUESTATUS =
; TIMEOUT | FULL | JOINEMPTY | JOINUNAVAIL |
; LEAVEEMPTY | LEAVEUNAVAIL
; and exits:
exten =&gt; 20,n,Goto(q-${QUEUESTATUS},1)  
; jump depending on QUEUESTATUS

; no agents in the queue:
; (you could also route calls to VoiceMail() here)
exten =&gt; q-JOINEMPTY,1,Wait(1)
exten =&gt; q-JOINEMPTY,n,Playback(vm-nobodyavail,noanswer)
exten =&gt; q-JOINEMPTY,n,Playback(vm-goodbye,noanswer)
exten =&gt; q-JOINEMPTY,n,Hangup()

; no agents in the queue (or only unavailable agents):
exten =&gt; q-JOINUNAVAIL,1,Goto(q-JOINEMPTY,1)   
; handle same as JOINEMPTY

; all agents have logged out:
exten =&gt; q-LEAVEEMPTY,1,Goto(q-JOINEMPTY,1)    
; handle same as JOINEMPTY

; all agents (including unavailable agents) have logged out:
exten =&gt; q-LEAVEUNAVAIL,1,Goto(q-JOINEMPTY,1)  
; handle same as JOINEMPTY

; no agent is answering:
exten =&gt; q-TIMEOUT,1,Goto(q-JOINEMPTY,1)       
; handle same as JOINEMPTY

; The number of callers in the queue has hit the maximum:
; (you could also route calls to VoiceMail() here)
exten =&gt; q-FULL,1,Busy(5)
exten =&gt; q-FULL,n,Hangup()</programlisting>If we call this extension now,
      we hear the "nobody is available" message, because no agents are logged
      in.</para>

      <tip>
        <para>If you want to pretend you have active agents for testing
        purposes, set <code>joinempty=yes</code> and
        <code>leaveempty=no</code> in <filename>queues.conf</filename>.</para>
      </tip>

      <para>Now we need to create an extension through which agents can log
      in:<programlisting>exten =&gt; 25,1,Answer()       ; answer
exten =&gt; 25,n,AgentLogin()   ; log the agent in
exten =&gt; 25,n,Hangup()       ; hang-up</programlisting></para>
    </section>

    <section>
      <title>AgentLogin() and AgentCallbackLogin()</title>

      <para><code>AgentLogin()</code> establishes an active channel, and
      incoming calls are simply switched into this active channel. This is
      analogous to having the phone off the hook and calls simply coming in
      without the agent actually having to pick up. If the agent hangs up, she
      is logged out. This also means that an agent cannot be logged in and
      make outgoing calls at the same time. As a result,
      <code>AgentLogin()</code> is only really appropriate for purely inbound
      call center groups.</para>

      <para><code>AgentCallbackLogin()</code> has the advantage of letting
      agents log in, and then having the system call back with calls from the
      queue. They remain logged in after hanging up and can make outgoing
      calls. This application is, however, deprecated as of Version 1.4. The
      example in <filename>doc/queues-with-callback-members.txt</filename>
      uses AEL (which can easily be converted into regular dialplan format) to
      identify agents, <code>AddQueueMember()</code> to dynamically add
      members to the queue and <code>Dial()</code> to call agents back.</para>

      <para>If AgentCallbackLogin() were to disappear without a replacement,
      real functionality and ease of configuration would be lost.</para>

      <tip>
        <para>Try out what you've learned. Write a dialplan which brings
        callers to an IVR menu first; for example, "For sales, press 1; for
        returns, press 2." and then pass callers to two separate queues, one
        for each department, depending on the input the caller gives.</para>
      </tip>
    </section>
  </section>

  <section id="warteschleifen-log">
    <title>Log file<indexterm significance="preferred">
        <primary>Queue log</primary>
      </indexterm><indexterm significance="preferred">
        <primary>queue_log</primary>
      </indexterm></title>

    <para>Events that happen in queues are written in a detailed format to the
    queue log (usually <filename>/var/log/asterisk/queue_log</filename>) in
    addition to the regular call detail recording. Events are recorded in
    <filename>queue_log</filename> on a line-by-line basis in the following
    format:<programlisting><replaceable>timestamp</replaceable>|<replaceable>call_id</replaceable>|<replaceable>queue</replaceable>|<replaceable>channel</replaceable>|<replaceable>event</replaceable>|<replaceable>parameter1</replaceable>[|<replaceable>parameter2</replaceable>[|<replaceable>parameter3</replaceable>]]</programlisting></para>

    <variablelist termlength="11">
      <varlistentry>
        <term><code>timestamp</code></term>

        <listitem>
          <simpara>The Unix time of the event.</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><code>call_id</code></term>

        <listitem>
          <simpara>The unique ID of the call (alphanumeric). Can be
          <code>NULL</code> or <code>NONE</code> (<emphasis>e.g.</emphasis> in
          the case of <literal>QUEUESTART</literal> events).</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><code>queue</code></term>

        <listitem>
          <simpara>The name of the queue, <emphasis>e.g.</emphasis>
          <code>support</code>. Can be <code>NULL</code> or
          <code>NONE</code>.</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><code>channel</code></term>

        <listitem>
          <simpara>The name of the bridged channel, <emphasis>e.g.</emphasis>
          <code>Agent/1001</code>. Can be <code>NULL</code> or
          <code>NONE</code>.</simpara>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><code>event</code></term>

        <listitem>
          <simpara>The name (type) of the event (see below). The parameters
          which follow depend on the event type.</simpara>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Possible events are, among others (see also
    <filename>doc/queuelog.txt</filename>):<variablelist termlength="21">
        <varlistentry>
          <term><code>ABANDON</code></term>

          <listitem>
            <simpara>The caller abandoned the queue by hanging up. Parameters:
            position, entry position, wait time.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>AGENTDUMP</code></term>

          <listitem>
            <simpara>The agent dumped the caller while listening to the queue
            announcement.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>AGENTLOGIN</code></term>

          <listitem>
            <simpara>An agent logged in. Parameters: channel
            (<emphasis>e.g.</emphasis>
            <code>SIP/127.0.0.1-0181ac00</code>).</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>AGENTCALLBACKLOGIN</code></term>

          <listitem>
            <simpara>A callback agent logged in. Parameters:
            login_extension[@context].</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>AGENTLOGOFF</code></term>

          <listitem>
            <simpara>An agent logged out. Parameters: channel, login
            time.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>AGENTCALLBACKLOGOFF</code></term>

          <listitem>
            <simpara>An agent was logged out. Parameters:
            login_extension[@context], cogin time, cause
            (<emphasis>e.g.</emphasis> autologoff).</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>COMPLETEAGENT</code></term>

          <listitem>
            <simpara>Call between caller and agent was ended by agent.
            Parameters: wait time, call time, queue entry position.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>COMPLETECALLER</code></term>

          <listitem>
            <simpara>Call between caller and agent was ended by caller.
            Parameters: wait time, call time, queue entry position.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>CONFIGRELOAD</code></term>

          <listitem>
            <simpara>Configuration was reloaded (<emphasis>e.g.</emphasis>
            with <command>asterisk -rx "reload"</command>).</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>CONNECT</code></term>

          <listitem>
            <simpara>Caller was connected to an agent. Parameters: Wait
            time.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>ENTERQUEUE</code></term>

          <listitem>
            <simpara>Caller was placed in the queue. Parameters: URL (if
            available), caller ID.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>EXITEMPTY</code></term>

          <listitem>
            <simpara>Caller was exited from the queue because no members were
            available. Parameters: queue position, entry position, wait
            time.</simpara>

            <para>See <xref linkend="queues.conf-leavewhenempty" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>EXITWITHKEY</code></term>

          <listitem>
            <simpara>Caller left the key by pressing a key. Parameters: key,
            queue position.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>EXITWITHTIMEOUT</code></term>

          <listitem>
            <simpara>Caller was in the queue too long and the timeout expired.
            Parameters: queue position.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>QUEUESTART</code></term>

          <listitem>
            <simpara>The queue was started. The <code>call_id</code>,
            <code>queue</code> and <code>channel</code> fields are set
            <code>NULL</code>.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>RINGNOANSWER</code></term>

          <listitem>
            <simpara>An available agent was called, but did not answer within
            the timeout. Parameters: ring time (in milliseconds).</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>SYSCOMPAT</code></term>

          <listitem>
            <simpara>The agent accepted a call, but the channels were not
            compatible and the call was ended.</simpara>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><code>TRANSFER</code></term>

          <listitem>
            <simpara>Caller was transferred to another extension. Parameters:
            extension, context.</simpara>
          </listitem>
        </varlistentry>
      </variablelist>Some commercial queue log analysis tools include
    QueueMetrics (http://queuemetrics.loway.it/) and Easy PABX
    (http://queuemetrics.loway.it/). See also <xref
    linkend="applications-queuelog" />.</para>

    <section id="queue-log-mysql">
      <title>Importing the queue-Log into MySQL</title>

      <para>As yet, Asterisk cannot write the queue log directly into an SQL
      database. Unfortunately, all of the widely used statistical tools assume
      and expect data to be in an SQL database. A variety of scripts seek to
      mitigate this problem (some may be found at <ulink
      url="http://www.voip-info.org/wiki/view/Asterisk+queue_log+on+MySQL">http://www.voip-info.org/wiki/view/Asterisk+queue_log+on+MySQL)</ulink>
      or are provided with the analysis tools. They all follow the same
      principle: the <filename>queue_log</filename> is replaced with a named
      pipe (FIFO); as soon as Asterisk attempts to write to the log, the log
      entry is converted and entered into the database.</para>

      <warning>
        <para>This method works in 99 % of cases. There remains the risk,
        however, that the script fails to start before Asterisk or terminates
        unexpectedly and stops reading from the named pipe, such that Asterisk
        receives a <literal>SIGPIPE</literal> when trying to write to the logs
        and crashes!</para>
      </warning>

      <para>Since there is no alternative without native Asterisk SQL support,
      we provide a sample Perl script from William Lloyd despite the
      associated risk:<footnote>
          <simpara>wlloyd at slap.net, released through the Digium
          <code>asterisk-users</code> mailing list. See: <ulink
          url="http://lists.digium.com/pipermail/asterisk-users/2005-July/109892.html">http://lists.digium.com/pipermail/asterisk-users/2005-July/109892.html</ulink></simpara>
        </footnote><programlisting>#!/usr/bin/perl -w
#
# wlloyd at slap.net

# The asterisk version indpendant way to get queue stats into Mysql,  
Postgres
# or whatever is supported by Perl DBI

# It's all about named pipes

# to setup this software
# stop asterisk
# rm /var/log/asterisk/queue_log
# mkfifo /var/log/asterisk/queue_log

# make sure permissions are setup
# chmod 777 /var/log/asterisk/queue_log

# run this program as root or under another user as you see fit.
# should start BEFORE asterisk.  Add to /etc/rc.d/rc.local or whatever

# restart asterisk

# requires a DB table like the following..
# CREATE TABLE csr_queue (
#  qname varchar(30) default NULL,
#  agent varchar(30) default NULL,
#  action text,
#  info1 text,
#  info2 text,
#  info3 text,
#  timestamp int(11) NOT NULL default '0',
#  id tinytext NOT NULL
#) TYPE=MyISAM;

use DBI;
use IO::File;

my $opt_debug = 0;

# if you want postgres change this to "Pg"
my $db_type = "mysql";
my $db_host = "127.0.0.1";
my $db_user_name = 'username';
my $db_password = 'password';
my $db_database = 'asteriskstat';

my $dbh = DBI-&gt;connect("DBI:$db_type:dbname=$db_database;host= 
$db_host;", $db_user_name, $db_password);

open(FIFO, "&lt; /var/log/asterisk/queue_log")        or die "Can't open  
queue_log : $!\n";

while (1) {

     $message = &lt;FIFO&gt;;
     next unless defined $message;   # interrupted or nothing logged
     chomp $message;

     # remove chars that will cause DB problems
     $message =~ s/\"\'//g;

     @data = split(/\|/,$message);

     # these messages are almost useless for my purposes
     next if ($data[4] eq "QUEUESTART" );
     next if ($data[4] eq "CONFIGRELOAD" );

     if (!defined($data[5])) {
       $data[5] = '';
     }
     if (!defined($data[6])) {
       $data[6] = '';
     }
     if (!defined($data[7])) {
       $data[7] = '';
     }

     my $sql = "INSERT INTO csr_queue (timestamp, id, qname, agent,  
action, info1, info2, info3) VALUES ('$data[0]', '$data[1]', '$data 
[2]', '$data[3]', '$data[4]', '$data[5]', '$data[6]', '$data[7]')";

     print "$sql \n\n" if ($opt_debug);

     $dbh-&gt;do($sql);

# if you want an actual logfile you might want to uncomment this
#        if ( open(LOG, "&gt;&gt; /var/log/asterisk/queue_log_real") ) {
#            print LOG "$message\n";
#            close(LOG);
#        } else {
#            warn "Couldn't log to /var/log/asterisk_queue_log: $!\n";
#        }
#
}

$dbh-&gt;disconnect();

exit 0;</programlisting>QueueMetrics (the free demo version) comes packaged
      with a Perl script called <filename>queueLoader.pl</filename> which will
      also load the queue log into mySQL (again - heed the warning above; if
      you do this in real time, there is a risk that Asterisk will
      crash).</para>
    </section>
  </section>
</chapter>
