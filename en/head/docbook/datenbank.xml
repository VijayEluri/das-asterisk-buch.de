<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-datenbank" lang="en" revision="$Revision$">
  <!--% Copyright (c) 2006 - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
-->

  <!--% translated from the German by Stephen Bosch <sbosch@vodacomm.ca>-->

  <!--% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>The Asterisk Database (AstDB)</title>

  <indexterm>
    <primary>Database</primary>

    <secondary>AstDB</secondary>
  </indexterm>

  <section id="datenbank-einleitung">
    <title>Introduction</title>

    <para>The problem with using variables in the dialplan is that any values
    they may contain are lost if Asterisk crashes or is restarted. This makes
    certain applications impossible. Simple features such as call forwarding
    or more sophisticated ones such as a calling card application depend on
    persistent information. For these purposes, you need a database to ensure
    that the data remains consistent across sessions. For this purpose,
    Asterisk implements a simple constant database based on the Berkeley
    DB.</para>

    <section id="datenbank-performance">
      <title>Performance</title>

      <indexterm>
        <primary>Database</primary>

        <secondary>Performance</secondary>
      </indexterm>

      <para>A frequently-asked question regarding the Asterisk database is
      "how does it perform?" There is no blanket answer; for most small
      operations, such as the call forwarding application described above, the
      native database is an excellent choice. When storing larger and more
      complex data, you should seriously consider whether an external SQL
      would be a better choice. In the vast majority of cases, however, this
      discussion is academic. The Berkeley DB upon which the Asterisk native
      database is built is stable and offers acceptable performance. Because
      it handles key-data pairs exclusively, it is in fact among the fastest
      database engines. The question of performance, then, need only be asked
      if slow database response is causing problems, or if you are building a
      large system with comprehensive features.</para>
    </section>
  </section>

  <section id="asterisk-datenbank">
    <title>The Asterisk Database</title>

    <para>Asterisk comes standard with a database built on the Berkeley DB
    (BDB)<footnote>
        <para>From the Wikipedia entry for the Berkeley DB: (BDB) is a
        high-performance, embedded database library with bindings in C, C++,
        Java, Perl, Python, Ruby, Tcl, Smalltalk and many other programming
        languages. BDB stores arbitrary key/data pairs as byte arrays, and
        supports multiple data items for a single key. BDB can support
        thousands of simultaneous threads of control or concurrent processes
        manipulating databases as large as 256 terabytes, on a wide variety of
        systems including most UNIX-like and Windows systems as well as
        real-time operating systems. [<citetitle><ulink
        url="???">http://en.wikipedia.org/wiki/Berkeley_DB</ulink></citetitle>]</para>
      </footnote> engine. This engine stores data in key/value pairs, with
    keys gathered into families. <warning>
        <para>Up until Asterisk Version 1.2, the following commands were used
        for database manipulation:</para>

        <itemizedlist>
          <listitem>
            <para><code>DBput(family/key=value)</code></para>

            <para>to save a value to the database.</para>
          </listitem>

          <listitem>
            <para><code>DBget(var=family/key)</code></para>

            <para>to read a value from the database. If the value is not
            found, the dialplan execution jumps to priority
            <replaceable>n</replaceable> + 1.</para>
          </listitem>
        </itemizedlist>

        <para>As of version 1.4, these commands are not supported. This
        chapter will cover only the new syntax, which also works in Asterisk
        1.2.</para>
      </warning>We manipulate data in the database using the <code>DB()</code>
    function (see <xref linkend="functions-db" />).</para>

    <section id="datenbank-schreiben">
      <title>Writing values to the database</title>

      <para>The <code>DB()</code> function is accessed through the
      <code><command>Set()</command></code> application. If we want to assign
      the key <code>apple</code> in the family <code>fruit</code> the value
      20, we would call <command>Set()</command> this way:<programlisting>exten =&gt; 1234,1,Set(DB(fruit/apple)=20)</programlisting></para>
    </section>

    <section id="datenbank-lesen">
      <title>Reading values from the database</title>

      <para>You can read values from the database using the <code>DB()</code>
      function with the syntax <code>${DB(family/key)}</code>. To read the
      contents of the key <code>apple</code> in the <code>fruit</code> family,
      you call the function this way:<programlisting>exten =&gt; 1234,1,NoOp(fruit/apple has the value ${DB(fruit/apple)})</programlisting></para>

      <para>If we want to store the content of this database field in the
      variable <code>howmanyapples</code>, we use
      <code><command>Set()</command></code> again:<programlisting>exten =&gt; 1234,1,Set(howmanyapples=${DB(fruit/apple)})</programlisting></para>
    </section>

    <section id="datenbank-loeschen">
      <title>Delete values (keys) from the database</title>

      <para>To delete keys, use the function <code>DBdel()</code> or the
      application <code><command>DBdeltree()</command></code> (to delete
      entire families).</para>

      <section id="datenbank-dbdel">
        <title>${DB_DELETE()}</title>

        <para>The function is called this way:<programlisting>exten =&gt; 1234,1,NoOp(${DB_DELETE(fruit/apple)})</programlisting>See
        also <xref linkend="functions-db_delete" />.</para>
      </section>

      <section id="datenbank-dbdeltree">
        <title>DBdeltree()</title>

        <para>If an entire key family is to be deleted, use
        <command><code>DBdeltree()</code></command>. The <code>fruit</code>
        family can be deleted with<programlisting>exten =&gt; 1234,1,DBdeltree(fruit)</programlisting></para>

        <para>See also: <xref linkend="applications-dbdeltree" /></para>
      </section>
    </section>
  </section>

  <section id="datenbank-via-cli">
    <title>Console (CLI) access</title>

    <indexterm>
      <primary>Database</primary>

      <secondary>CLI access</secondary>
    </indexterm>

    <para>An administrator can also access the database from the Asterisk
    console (CLI).<tip>
        <para>If you forget the syntax, you can call it up at any
        time:<screen>big-island*CLI&gt; help database
             database del  Removes database key/value
         database deltree  Removes database keytree/values
             database get  Gets database value
             database put  Adds/updates database value
            database show  Shows database contents
         database showkey  Shows database contents</screen></para>
      </tip></para>

    <important>
      <para>Note that if the key or family contain spaces, you must enclose
      the string in quotes (<code>"</code>). For example, <code>database put
      test entry "Hello World"</code>.</para>
    </important>

    <section id="datenbank-cli-schreiben">
      <title>Writing values to the database</title>

      <para>From the CLI, <code>database put <replaceable>family</replaceable>
      <replaceable>key</replaceable> <replaceable>value</replaceable></code>
      writes to the database:<screen>big-island*CLI&gt; database put fruit apple 20
Updated database successfully</screen></para>
    </section>

    <section id="datenbank-cli-lesen">
      <title>Reading values from the database</title>

      <para>From the CLI, <code>database get <replaceable>family</replaceable>
      <replaceable>key</replaceable></code> reads from the database:<screen>big-island*CLI&gt; database get fruit apple
Value: 20d*CLI&gt;</screen></para>
    </section>

    <section id="datenbank-cli-loeschen">
      <title>Delete values (keys) from the database</title>

      <para><code>database del <replaceable>family</replaceable>
      <replaceable>key</replaceable></code> and <code>database deltree
      <replaceable>family</replaceable></code> delete values from the
      database.</para>

      <section id="datenbank-cli-del">
        <title>database del</title>

        <para>To delete the key <code>apple</code> (including the value it
        contains) from the <code>fruit</code> family, call <code>database
        del</code>:<screen>big-island*CLI&gt; database del fruit apple
Database entry removed.</screen></para>
      </section>

      <section id="datenbank-cli-deltree">
        <title>database deltree</title>

        <para>Entire key families may be deleted with <code>database
        deltree</code>:<screen>big-island*CLI&gt; database deltree fruit
Database entries removed.</screen></para>
      </section>
    </section>

    <section id="datenbank-cli-anzeigen">
      <title>Displaying database contents</title>

      <para>The administrator can print the contents of the database to the
      CLI with the commands <code>database show</code> and <code>database
      showkey</code>. For example:<screen>big-island*CLI&gt; database put shoppinglist eggs 2
Updated database successfully
big-island*CLI&gt; database put shoppinglist butter 250
Updated database successfully
big-island*CLI&gt; database put shoppinglist sugar 500
Updated database successfully
big-island*CLI&gt; database show
/shoppinglist/butter                             : 250                      
/shoppinglist/eggs                               : 2                        
/shoppinglist/sugar                             : 500  
big-island*CLI&gt; database showkey butter
/shoppinglist/butter                             : 250
big-island*CLI&gt; database deltree shoppinglist
Database entries removed.</screen></para>
    </section>
  </section>

  <section id="datenbank-von-shell">
    <title>Database access from the system shell</title>

    <indexterm>
      <primary>Database</primary>

      <secondary>Shell access</secondary>
    </indexterm>

    <para>All the CLI commands may be executed from the system shell using the
    command <command>asterisk -rx
    '<replaceable>command</replaceable>'</command>, which is useful for shell
    scripting purposes. The following example shows how this is done by first
    populating values, reading them, and then deleting the keys:<screen>big-island:~# asterisk -rx 'database put test var1 23'
Updated database successfully
big-island:~# asterisk -rx 'database put test var2 42'
Updated database successfully
big-island:~# asterisk -rx 'database show test'
/test/var1                                        : 23                       
/test/var2                                        : 42                       
big-island:~# asterisk -rx 'database get test var2'
Value: 42
big-island:~# asterisk -rx 'database deltree test'
Database entries removed.</screen><important>
        <para>Again a reminder: if the family, key or value contain spaces,
        you must enclose the string in quotes (<code>"</code>)! For
        example:<screen>big-island:~# asterisk -rx 'database put test entry "Hello World"'</screen></para>
      </important></para>
  </section>

  <section id="datenbank-backup">
    <title>Database backup</title>

    <indexterm>
      <primary>Database</primary>

      <secondary>Backup</secondary>
    </indexterm>

    <para>The AstDB is stored in <filename>/var/lib/asterisk/astdb/</filename>
    by default. You can make a copy of the database once Asterisk has been
    stopped.</para>

    <para>Performing a text backup while in operation can be done from the
    shell this way:<programlisting>asterisk -rx "database show" &gt; /tmp/backup-asterisk-database.txt</programlisting>Of
    course, this makes a restore more complicated.</para>
  </section>

  <section id="section-callforwarding">
    <title>Application example: call forwarding</title>

    <indexterm>
      <primary>Example</primary>

      <secondary>CallForwarding</secondary>
    </indexterm>

    <para>Someone who wants to forward all her calls to her cell phone while
    she is away needs a call forwarding function. This can be done either from
    the device (namely, a SIP telephone) or centrally through the server. The
    latter approach is preferable, since it means we can control call
    forwarding irrespective of the device and its settings, and maintain some
    central administration over call processing. In addition, the setting is
    not lost following a power failure, and normal operation is restored
    automatically.</para>

    <section id="einfaches-callforwarding">
      <title>Simple call forwarding</title>

      <para>All employees at Widgets, Inc. are to have unrestricted call
      forwarding. To activate call forwarding, the user dials 44, followed by
      the target number; to deactivate it, she dials 44 (this time without a
      number appended). This is implemented in the dialplan as follows:</para>

      <programlisting>[from-internal]
; Call forwarding for a single physical extension
;
; activate
exten =&gt; _44X.,1,Answer()
exten =&gt; _44X.,n,Set(DB(CF/${CALLERID(num)})=${EXTEN:2})
exten =&gt; _44X.,n,SayDigits(${EXTEN:2})
exten =&gt; _44X.,n,NoOp(Call forwarding for ${CALLERID(num)} to ${EXTEN:2} activated.) 
exten =&gt; _44X.,n,Hangup()

; deactivate
exten =&gt; 44,1,Answer()
exten =&gt; 44,n,DBdel(CF/${CALLERID(num)})
exten =&gt; 44,n,Playback(auth-thankyou)
exten =&gt; 44,n,NoOp(Call forwarding for ${CALLERID(num)} deactivated.) 
exten =&gt; 44,n,Hangup()

[from-external]
exten =&gt; _X.,1,NoOp(Call from ${CALLERID(num)} for ${EXTEN})
exten =&gt; _X.,n,GotoIf($[foo${DB(CF/${EXTEN})} != foo]?normal:forward)
exten =&gt; _X.,n(normal),Dial(SIP/${EXTEN})
exten =&gt; _X.,n(forward),NoOp(Call for ${EXTEN} is being forwarded to ${DB(CF/${EXTEN})})
exten =&gt; _X.,n,Dial(local/${DB(CF/${EXTEN})})</programlisting>
    </section>

    <section id="komplexes-callforwarding">
      <title>Complex call forwarding</title>

      <para>In this scenario, all Widgets, Inc. employees are to have
      unrestricted call forwarding as before. In addition, however, we want a
      system-wide forwarding function so that all calls can be forwarded to
      another branch, say if the staff all go away on a company retreat. This
      system-wide forwarding is activated by dialing 55 plus the target
      number. For this to work, we need the system-wide forwarding to have a
      higher priority than the individual forwarding. This is implemented in
      the dialplan as follows:<programlisting>[from-internal]
; Call forwarding for a single physical extension
;
; activate
exten =&gt; _44X.,1,Answer()
exten =&gt; _44X.,n,Set(DB(CF/${CALLERID(num)})=${EXTEN:2})
exten =&gt; _44X.,n,SayDigits(${EXTEN:2})
exten =&gt; _44X.,n,NoOp(Call forwarding for ${CALLERID(num)} to ${EXTEN:2} activated.) 
exten =&gt; _44X.,n,Hangup()

; deactivate
exten =&gt; 44,1,Answer()
exten =&gt; 44,n,DBdel(CF/${CALLERID(num)})
exten =&gt; 44,n,Playback(auth-thankyou)
exten =&gt; 44,n,NoOp(Call forwarding for ${CALLERID(num)} deactivated.) 
exten =&gt; 44,n,Hangup()

; CallForwarding für die gesamte Telefonanlage
;
; activate
exten =&gt; _55X.,1,Answer()
exten =&gt; _55X.,n,Set(DB(CF/system)=${EXTEN:2})
exten =&gt; _55X.,n,SayDigits(${EXTEN:2})
exten =&gt; _55X.,n,NoOp(System-wide call forwarding to ${EXTEN:2} activated.) 
exten =&gt; _55X.,n,Hangup()

; deaktivieren
exten =&gt; 55,1,Answer()
exten =&gt; 55,n,DBdel(CF/system)
exten =&gt; 55,n,Playback(auth-thankyou)
exten =&gt; 55,n,NoOp(System-wide call forwarding deactivated.) 
exten =&gt; 55,n,Hangup()

[from-extern]
exten =&gt; _X.,1,NoOp(Call from ${CALLERID(num)} for ${EXTEN})
exten =&gt; _X.,n,GotoIf($[foo${DB(CF/system)} != foo]?cfsystem:secondrule)
exten =&gt; _X.,n(secondrule),GotoIf($[foo${DB(CF/${EXTEN})} != foo]?cfnormal:normal)
exten =&gt; _X.,n(normal),Dial(SIP/${EXTEN})
exten =&gt; _X.,n(cfnormal),NoOp(Call for ${EXTEN} is being forwarded to ${DB(CF/${EXTEN})})
exten =&gt; _X.,n,Dial(local/${DB(CF/${EXTEN})})
exten =&gt; _X.,n(cfsystem),NoOp(Call for ${EXTEN} is being forwarded to ${DB(CF/system)})
exten =&gt; _X.,n,Dial(local/${DB(CF/system)})
</programlisting></para>
    </section>
  </section>

  <section id="beispiel-callingcard">
    <title>Application example: calling card</title>

    <indexterm>
      <primary>Example</primary>

      <secondary>CallingCard</secondary>
    </indexterm>

    <para>Widgets, Inc. staff are to make private calls using a calling card
    (which, in practice, is just an access number). This card is loaded by the
    office manager using his telephone (by dialing 88, followed by a three
    digit extension and then the amount in dollars).<footnote>
        <para>To keep the example as simple and comprehensible as possible, we
        are deliberately ignoring the case of a card which must be recharged
        while it still has a balance remaining (which would require an
        addition operation), nor are we considering the case where an employee
        makes a private call from another employee's telephone. In practice,
        you would need to consider such scenarios.</para>
      </footnote> Calls are charged a flat fee of 1 dollar each. Such private
    calls can be made by dialing 99 followed by the target number. Of course,
    we don't want calls to be billed if the line is busy. An employee can
    check the balance on his card by dialing 98.<programlisting>[from-officemanager]
; Recharging the virtual card
;
exten =&gt; _88XXX.,1,Answer()
exten =&gt; _88XXX.,2,Set(DB(CallingCard/${EXTEN:2:3})=${EXTEN:5})
exten =&gt; _88XXX.,3,SayNumber(${EXTEN:5})
exten =&gt; _88XXX.,4,NoOp(Calling card for ${EXTEN:2:3} now has a balance of ${EXTEN:5} dollars.)
exten =&gt; _88XXX.,5,Hangup()

[from-internal]
; private calls
;
exten =&gt; _99.,1,GotoIf($[${DB(CallingCard/${CALLERID(num)} &gt; 0]?2:200)
exten =&gt; _99.,2,Set(DB(CallingCard/${CALLERID(num)})=$[DB(CallingCard/${CALLERID(num)}) - 1])
exten =&gt; _99.,3,Dial(local/${EXTEN:2})
exten =&gt; _99.,104,Set(DB(CallingCard/${CALLERID(num)})=$[DB(CallingCard/${CALLERID(num)}) + 1])

exten =&gt; _99.,200,NoOp(Calling card account ${CALLERID(num) is empty.)
exten =&gt; _99.,201,Answer()
exten =&gt; _99.,202,SayNumber(0)
exten =&gt; _99.,203,Hangup()

; employees can check the balance by dialing 98.
;
exten =&gt; 98,1,Answer()
exten =&gt; 98,2,SayNumber(${DB(CallingCard/${CALLERID(num)})})
exten =&gt; 98,3,Hangup()</programlisting></para>
  </section>
</chapter>