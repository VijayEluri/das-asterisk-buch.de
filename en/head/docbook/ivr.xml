<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-ivr" lang="de" revision="$Revision:573 $">
  <!--% Copyright (c) 2006 - 2007 by 
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
-->

  <!--% translated from the German by Stephen Bosch <sbosch@vodacomm.ca>-->

  <!--% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Interactive Voice Response (IVR)</title>

  <para>An interactive voice response system lets computer systems interact
  with telephone callers, who provide input to the system either by pressing
  the keypad on their telephone set (DTMF, "dual-tone multi-frequency" keying,
  aka Touch-Tone®) or by saying something (natural language speech
  recognition). Most IVR systems provide selection menus for routing calls
  without requiring operator intervention, but modern IVR systems can also be
  very complex applications that handle information or control
  equipment.</para>

  <para>The basic principle common to all IVR systems, however, is that the
  caller is read a menu and chooses options from that menu to perform actions,
  or, alternatively, enters information (in numerical format, through pressing
  the keypad). IVRs can be used to obtain stock quotations, train schedules,
  and weather reports; they can also be used for automated purchasing systems,
  such as for concert tickets. The potential applications are limited only by
  your imagination.</para>

  <para>Systems vary in their complexity. The most advanced generate spoken
  text "on-the-fly" using text-to-speech (TTS) systems and accept spoken user
  input with speech recognition. When properly implemented they can provide a
  high level of user-friendliness, but implementation is so complex that they
  are rarely used, except in larger organizations.<footnote>
      <para>LumenVox makes a speech recognition kit for Asterisk. See <ulink
      url="http://www.lumenvox.com/"><citetitle>http://www.lumenvox.com</citetitle></ulink></para>
    </footnote></para>

  <para>The simplest form of IVR is also the most common. Pre-recorded
  messages are played to the caller; the caller responds with DTMF keypad
  input, which Asterisk can recognize easily in the default install.</para>

  <para>Public opinion on IVRs is divided. Some people find them a helpful
  form of automation, while others find them exceedingly frustrating. This is
  usually the result of poor menu design or speech recognition with a high
  failure rate. A well-functioning IVR can be pleasant for the customer, but a
  poorly implemented one can scare her away.<footnote>
      <para>The increasingly multi-ethnic nature of society everywhere means
      that speech recognition should be implemented with caution, as accents
      can be problematic.</para>
    </footnote>Take care when planning an IVR system. Pay special attention to
  menu design and allow adequate time for a clean development and deployment.
  Aggressive testing and post-deployment monitoring of premature hang-ups
  should be part of your routine. Remember that IVR systems are not an end in
  themselves, nor are they a panacea. Think of your customer!</para>

  <section id="einfache-ivr">
    <title id="eine-einfache-ivr">A simple IVR</title>

    <para>The standard Asterisk sound set includes a file called
    <filename>marryme.gsm</filename>, containing the announcement "Will you
    marry me? Press 1 for yes or 2 for no."<footnote>
        <para>Allison Smith is a Canadian voice professional who is the "Voice
        of Asterisk". Its growing popularity has given her a considerable cult
        following :)</para>
      </footnote>To build a "marriage proposal" application, the following
    dialplan will suffice:<footnote>
        <para>Using this IVR for an actual marriage proposal is strongly
        discouraged.</para>
      </footnote><programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()</programlisting>If the caller dials extension 30,
    Asterisk answers and plays the file <filename>marryme.gsm</filename>.
    Through use of the <command>Background()</command> application, the user
    is allowed to enter input at any time during playback. The input is
    interpreted as an extension and the call is passed to that extension. If
    the caller presses 1, he hears "Thank you for your cooperation," after
    which Asterisk hangs up.</para>

    <section id="ivr-unterschied-playback-und-background">
      <title id="unterschied-playback-und-background">Differences between
      Playback() and Background()</title>

      <para><application><command>Playback()</command></application> (see
      <xref linkend="applikationen-playback" />) only plays back sound files;
      input is ignored.
      <application><command>Background()</command></application> (see <xref
      linkend="applikationen-background" />) plays sound files back while
      listening for caller input, which is interpreted as an extension as
      though it had been dialed as one.</para>
    </section>

    <section id="ivr-unterschied-10-und-1000">
      <title id="unterschied-10-und-1000">Difference between 10 and
      1000</title>

      <para>To address the challenge of extensions beginning with the same
      digits, let's examine the following example:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 10,1,NoOp(Test mit 10)
exten =&gt; 10,2,Hangup()

exten =&gt; 100,1,NoOp(Test mit 100)
exten =&gt; 100,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()</programlisting></para>

      <para><command>Background()</command> waits a set time after each digit
      in order to distinguish between 1, 10 and 100. Once this time
      (<parameter>TIMEOUT</parameter>) has expired, input is deemed to be
      complete.<tip>
          <para><parameter>TIMEOUT</parameter> lets you set other timeouts.
          For more information, enter <command>show function TIMEOUT</command>
          in the Asterisk CLI, or see <xref
          linkend="funktionen-timeout" /></para>
        </tip><parameter>TIMEOUT</parameter> is defined in seconds and may be
      set in the dialplan like so.<programlisting>exten =&gt; 123,1,Set(TIMEOUT(digit)=3)</programlisting></para>

      <section>
        <title>Intelligent discernment</title>

        <para>In the dialplan above, Asterisk will proceed immediately if 2 is
        pressed, but only after the timeout has expired if 1 is pressed.
        Asterisk intelligently determines whether a digit entered can match
        multiple extensions and behaves accordingly.</para>
      </section>
    </section>

    <section id="ivr-falscheingaben">
      <title id="falscheingabe-i-extension">Invalid input (the i
      extension)</title>

      <para>An invalid entry (any entry for which no extension in the dialplan
      matches) can be handled by the <code>i</code> extension. A simple
      example would look like this:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()

; Any other input is caught by the i extension.
exten =&gt; i,1,Background(sorry)
exten =&gt; i,2,Hangup()</programlisting></para>
    </section>

    <section id="ivr-pausen">
      <title id="pausen-silence">Pauses</title>

      <para>The easiest way to create pauses for input is to play back empty
      sound files. A series of silent sound files of between 1 and 9 seconds
      in length may be found in
      <filename>/var/lib/asterisk/sounds/silence/</filename>. If we need to
      allow five seconds following the prompt (a marriage proposal requires
      careful consideration, after all), here's how we can accomplish
      that:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Background(silence/5)
exten =&gt; 30,4,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()

exten =&gt; i,1,Background(marryme)
exten =&gt; i,2,Hangup()</programlisting></para>
    </section>
  </section>

  <section id="mehrstufige-ivr">
    <title id="mehrstufig-ivr">Multilevel IVR systems</title>

    <para>The problem with multilevel IVRs is that the caller has to enter
    single digits multiple times (oftentimes the same digit), but gets a
    different response depending on the menu level. Because a number can only
    be used once in a given context, the caller would be stuck on the first
    menu level. If we need multiple menus which provide different responses
    for the same digits, we must place the submenus in different contexts
    (<code>[cafeteria]</code> in our example). We jump between these contexts
    using the application <command><application>Goto()</application></command>
    (see <xref linkend="applikationen-goto" />). Let's assume you have the
    following sound files stored in
    <filename>/var/lib/asterisk/sounds/</filename>:</para>

    <itemizedlist>
      <listitem>
        <para><filename>mainmenu.gsm</filename></para>

        <para>"Press 1 for sales, 2 for service, or 3 for the
        cafeteria."</para>
      </listitem>

      <listitem>
        <para><filename>cafeteria.gsm</filename></para>

        <para>"Press 1 to hear the menu for this week or 2 to hear the menu
        for next week."</para>
      </listitem>

      <listitem>
        <para><filename>cafeteria-menu-this-week.gsm</filename></para>

        <para>"Monday: Noodles with pesto sauce. Tuesday: Pork
        chops..."</para>
      </listitem>

      <listitem>
        <para><filename>cafeteria-menu-next-week.gsm</filename></para>

        <para>"Monday: Stew, featuring noodles, basil and, um, pork
        chops..."</para>
      </listitem>
    </itemizedlist>

    <para>If sales is at extension 100 and the service department is at 150,
    the dialplan for this IVR would look like this:<programlisting>[example-ivr]
; The menu is repeated until the caller provides input.
;
exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(mainmenu)
exten =&gt; 30,3,Background(silence/3)
exten =&gt; 30,4,Goto(2)

exten =&gt; 1,1,Dial(SIP/100)

exten =&gt; 2,1,Dial(SIP/150)

; Goto() jumps to another context ([cafeteria])
;
exten =&gt; 3,1,Goto(cafeteria,100,1)

exten =&gt; i,1,Goto(30,2)

[cafeteria]
exten =&gt; 100,1,Background(cafeteria)
exten =&gt; 100,2,Background(silence/3)
exten =&gt; 100,3,Goto(1)

exten =&gt; 1,1,Playback(cafeteria-menu-this-week)
exten =&gt; 1,2,Wait(2)
exten =&gt; 1,3,Goto(1)

exten =&gt; 2,1,Playback(cafeteria-menu-next-week)
exten =&gt; 2,2,Wait(2)
exten =&gt; 2,3,Goto(1)

; Invalid input sends the caller back to the main menu
exten =&gt; i,1,Goto(example-ivr,30,2)</programlisting></para>

    <section>
      <title>IVR depth</title>

      <para>Even though it is technically possible to support an unlimited
      number of IVR levels, in practice it is advisable to keep the number of
      menu levels to a maximum of three. Many callers hang up after the third
      menu level.</para>
    </section>
  </section>

  <section id="text2speech">
    <title id="tts">Text-to-Speech (TTS)</title>

    <para>Text-to-speech is simply the conversion of written text into a
    spoken word, using speech synthesis. In our Asterisk system this means
    that an external program generates a sound file using a given text file
    (usually in ASCII format) as the source. The resulting sound file is
    played back as any other sound file would be, and the caller hears the
    text spoken out.</para>

    <para>Quality of text-to-speech engines vary widely. As a rule-of-thumb,
    the open source engines are not as sophisticated as the commercial
    ones.<tip>
        <para>Sometimes you can test high quality engines through web portals.
        IBM offers a test portal for its TTS engine at <ulink
        url="http://www.ibm.com/software/pervasive/tech/demos/tts.shtml">http://www.ibm.com/software/pervasive/tech/demos/tts.shtml</ulink>.</para>
      </tip>The TTS engine Festival (<ulink
    url="http://www.cstr.ed.ac.uk/projects/festival/">http://www.cstr.ed.ac.uk/projects/festival/</ulink>)
    is a widely used open source version, but the voices included with it
    often lack the quality necessary for professional implementation,
    particularly if you need voices in languages other than English. Many
    Asterisk developers use the engine and voices sold commercially by
    Cepstral (<ulink
    url="http://www.cepstral.com/">http://www.cepstral.com/</ulink>). As of
    this writing, the pricing was reasonable.<footnote>
        <para>Like IBM, Cepstral has a demo portal at <ulink
        url="http://www.cepstral.com/demos/">http://www.cepstral.com/demos/</ulink>.</para>
      </footnote>The solution described here builds on the Cepstral
    engine.<footnote>
        <para>For those who have worked with Festival before, these
        instructions are easily modified to work with it. This applies to
        other TTS engines as well. The implementation model is the
        same.</para>
      </footnote></para>

    <section id="installation-cepstral-tts">
      <title id="installation-cepstral">Installating Cepstral
      Text-to-Speech</title>

      <para>Download the voice from <ulink
      url="http://www.cepstral.com/downloads/">http://www.cepstral.com/downloads/</ulink>.
      The file (<filename>Cepstral_David_i386-linux_4.2.0.tar.gz</filename> in
      this example) is installed with the following commands:<programlisting>tar xvzf Cepstral_David_i386-linux_4.2.0.tar.gz
cd Cepstral_David_i386-linux_4.2.0.tar.gz
./install</programlisting></para>
    </section>

    <section id="cepstral-beispiel">
      <title id="beispiele-und-tests">Examples and tests</title>

      <para>The engine installs to <filename>/opt/swift/bin/swift</filename>
      unless otherwise specified. You can test the installation from the
      command line as follows:<screen>/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "This is a test."</screen>You
      can play the resulting file with any audio player, or through Asterisk.
      To do this, just add a few lines to
      <filename>extensions.conf</filename>:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Playback(/tmp/test)
exten =&gt; 1234,3,Hangup()</programlisting>To generate some speech output
      from within Asterisk, we use the
      <application><command>System()</command></application> application in
      the dialplan. Here is an example:<programlisting>exten =&gt; 1222,1,Answer()
exten =&gt; 1222,2,System(rm -rf /tmp/test.wav)
exten =&gt; 1222,3,System(/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Another test.")
exten =&gt; 1222,4,Playback(/tmp/test)
exten =&gt; 1222,5,Hangup()</programlisting></para>
    </section>

    <section id="cepstral-pausen">
      <title id="pausen">Pauses in text</title>

      <para>Cepstral uses SSML (Speech Synthesis Markup Language) in its
      engine. You can add speech pauses to the output by specifying them as in
      this example:<programlisting>exten =&gt; 1222,1,Answer()
exten =&gt; 1222,2,System(rm -rf /tmp/test.wav)
exten =&gt; 1222,3,System(/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Another test. &lt;break time='2500ms'/&gt; Done!")
exten =&gt; 1222,4,Playback(/tmp/test.wav)
exten =&gt; 1222,5,Hangup()</programlisting>Learn more about the SSML standard
      at <ulink
      url="http://www.w3.org/TR/speech-synthesis/">http://www.w3.org/TR/speech-synthesis/</ulink>.</para>
    </section>
  </section>
</chapter>