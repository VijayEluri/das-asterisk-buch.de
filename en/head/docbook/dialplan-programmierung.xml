<?xml version="1.0" encoding="UTF-8"?>
<chapter id="kapitel-programmieren" lang="de" revision="$Revision: 472 $">
  <!--% Copyright (c) 2006 - 2007 by
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".-->

  <!--% translated from the German by Stephen Bosch <sbosch@vodacomm.ca>-->

  <!--% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Programming in the dialplan</title>

  <para>In Asterisk, functions or programs can be implemented either
  externally, through an AGI script (in much the same way that a CGI script
  can add functionality to a web page) or internally, through functions and
  applications in the dialplan. This chapter will focus strictly on the
  internal functions; AGI is treated in depth in a separate chapter.</para>

  <para>The dialplan is defined in the <filename>extensions.conf</filename>
  configuration file. The dialplan itself looks much like a BASIC program. The
  administrator can implement features and call flow using a simple scripting
  language.</para>

  <section id="programmierer-howto">
    <title>Programming "How-to"</title>

    <indexterm>
      <primary>Howto</primary>

      <secondary>Kleines Programmierer Howto</secondary>
    </indexterm>

    <para>A major challenge in writing a book like this one is that every
    reader comes to it with a different level of previous experience. A book
    on Asterisk might be read by administrators, programmers, telephone
    specialists, and hobbyists, all with different levels of practical
    experience. To take full advantage of Asterisk, a basic level of
    programming skill and a grasp of the fundamentals is necessary. Through
    this how-to, we hope to provide the newcomer with the basic understanding
    needed to make useful dialplans, through the use of plenty of examples and
    with frequent reference to <xref linkend="applikationen" />. You will
    probably recognize some of the material from other chapters. This little
    how-to should give you the overview you need to get started.</para>

    <section id="programmierer-howto-programmstruktur">
      <title>Program structure</title>

      <para>Each telephone number defined in the Asterisk dialplan
      (<filename>/etc/asterisk/extensions.conf</filename>) is really a small
      program. In Asterisk, the program is called an "extension." An extension
      looks like this:<programlisting>exten =&gt; 1001,1,Answer()
exten =&gt; 1001,n,Playback(hello-world)
exten =&gt; 1001,n,Hangup()</programlisting></para>

      <para>Priorities may also numbered sequentially:<programlisting>exten =&gt; 1001,1,Answer()
exten =&gt; 1001,2,Playback(hello-world)
exten =&gt; 1001,3,Hangup()</programlisting>The two extensions depicted here
      are functionally identical. If you use <code>n</code>, however, it makes
      adding and deleting entries in the extension much easier later
      on.</para>
    </section>

    <section id="programmierer-howto-variablen">
      <title>Variables</title>

      <para>Use the application Set() to create and change
      variables:<programlisting>exten =&gt; 1002,1,Set(Favoriteanimal = "Tiger")
exten =&gt; 1002,n,Set(Favoritenumber = 23)</programlisting></para>

      <para>Use the syntax <code>${VARIABLENNAME}</code> to read and print
      variables. You can print variable values on the CLI with
      <code>NoOp()</code> (with verbosity level 3 and up):<programlisting>exten =&gt; 1003,1,NoOp(${Favoriteanimal})
exten =&gt; 1003,n,NoOp(${Favoritenumber})</programlisting></para>

      <para>There are different kinds of variables:<itemizedlist>
          <listitem>
            <para>Global variables</para>

            <para>Valid anywhere in the dialplan and created or modified with
            <code>Set(&lt;variable&gt;=&lt;content&gt;,g):</code><programlisting>exten =&gt; 1004,1,Set(READABLEANYWHERE = 23,g)
exten =&gt; 1004,n,NoOp(${READABLEANYWHERE})</programlisting></para>
          </listitem>

          <listitem>
            <para>Channel variables</para>

            <para>Valid only in the current channel (a channel could be a
            connection between two people having a phone conversation).
            Created or modified with
            <code>Set(&lt;variable&gt;=&lt;content&gt;)</code> (without the
            <code>g</code>):<programlisting>exten =&gt; 1005,1,Set(READABLEHEREONLY= 42)
exten =&gt; 1005,n,NoOp(${READABLEHEREONLY})</programlisting></para>
          </listitem>

          <listitem>
            <para>System variables</para>

            <para>These dynamic variables are set by Asterisk and may be
            called in the dialplan without needing to create them. A
            frequently used system variable is ${EXTEN}:<programlisting>exten =&gt; 1006,1,NoOp(Dialed number: ${EXTEN})</programlisting></para>
          </listitem>
        </itemizedlist></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="variablen" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-labels-und-goto">
      <title>Labels and Goto()</title>

      <indexterm>
        <primary>Labels</primary>
      </indexterm>

      <para><code>Goto()</code> lets you jump from one dialplan entry to
      another. If you are using <code>n</code> priorities, this can be
      problematic. The solution is to use labels to tag specific entries and
      then call the entry by label in <code>Goto()</code>.</para>

      <para>Examples:</para>

      <itemizedlist>
        <listitem>
          <para>Within an extension:<programlisting>exten =&gt; 1007,1,Answer()
exten =&gt; 1007,n(Start),Wait(1)
exten =&gt; 1007,n,Playback(hello-world)
exten =&gt; 1007,n,Goto(Start)</programlisting></para>
        </listitem>

        <listitem>
          <para>Between extensions:<programlisting>exten =&gt; 1008,1,Answer()
exten =&gt; 1008,n,Goto(1009,Ping)

exten =&gt; 1009,1(Ping),Playback(hello-world)
exten =&gt; 1009,n,Wait(2)
exten =&gt; 1009,n,Goto(1010,Pong)

exten =&gt; 1010,1(Pong),Playback(tt-weasels)
exten =&gt; 1010,n,Wait(2)
exten =&gt; 1010,n,Goto(1009,Ping)</programlisting></para>
        </listitem>

        <listitem>
          <para>Between contexts:<programlisting>[hq]
exten =&gt; 1011,1,Answer()
exten =&gt; 1011,n,Playback(hello-world)
exten =&gt; 1011,n,Goto(sales,1012,1)

[sales]
exten =&gt; 1012,1,Playback(hello-world)
exten =&gt; 1012,n,Hangup()</programlisting></para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-goto" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-while">
      <title>While() loops</title>

      <indexterm>
        <primary>While() Schleifen</primary>
      </indexterm>

      <para>Use <code>While()</code> to run loops in the
      dialplan:<programlisting>exten =&gt; 1013,1,Answer()
exten =&gt; 1013,n,Set(i=1)
exten =&gt; 1013,n,While($[${i} &lt; 10])
exten =&gt; 1013,n,SayNumber(${i})
exten =&gt; 1013,n,Wait(1)
exten =&gt; 1013,n,Set(i=$[${i} + 1])
exten =&gt; 1013,n,EndWhile()
exten =&gt; 1013,n,Hangup()</programlisting></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-while" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-gotoif">
      <title>GotoIf() conditional</title>

      <indexterm>
        <primary>GotoIf() Bedingung</primary>
      </indexterm>

      <para>You can jump to other parts of the dialplan depending on a
      specific condition being met with <code>GotoIf()</code>:<programlisting>exten =&gt; 1014,1,Answer()
exten =&gt; 1014,n,Set(Favoritestation = 0815)
exten =&gt; 1014,n,NoOp(Check to see if ${Favoritestation} is calling.)
exten =&gt; 1014,n,GotoIf($[${CALLERID(num) = ${Favoritestation}]?yes,no)

exten =&gt; 1014,n(yes),Playback(hello-world)
exten =&gt; 1014,n,Hangup()

exten =&gt; 1014,n(no),Playback(tt-monkeys)
exten =&gt; 1014,n,Hangup()</programlisting></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-gotoif" /></para>
      </formalpara>
    </section>

    <section id="programmier-howto-gosub">
      <title>Gosub() subroutines</title>

      <indexterm>
        <primary>Gosub() Unterprogramme</primary>
      </indexterm>

      <para>With <code>Gosub()</code> the call is directed to a subroutine; it
      can be returned to the intiating priority with <code>Return()</code>
      wieder zur√ºck:<programlisting>exten =&gt; 1015,1,Gosub(cid-set)
exten =&gt; 1015,n,Dial(SIP/${EXTEN})

exten =&gt; 1015,n(cid-set),Set(CALLERID(all)=Apfelmus GmbH &lt;012345678&gt;)
exten =&gt; 1015,n,Return()</programlisting></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-gosub" />, <xref
        linkend="applikationen-gosubif" />, <xref
        linkend="applikationen-return" />, <xref
        linkend="applikationen-macro" /></para>
      </formalpara>
    </section>
  </section>

  <section id="variablen">
    <title>Variables</title>

    <indexterm>
      <primary>Variablen</primary>
    </indexterm>

    <para>A variable is a placeholder for an actual value. Exactly what that
    value is depends on the kind of variable. In Asterisk, variables can
    contain numbers, letters and strings (sequences of letters and numbers).
    Variables are useful because they let us create rules for call flow that
    apply in changing circumstances and make it easier to accommodate future
    changes in the telephone application or system.<tip>
        <para>If you've never worked with variables before, we recommend you
        read an introduction to the subject at <citetitle><ulink
        url="???">http://en.wikipedia.org/wiki/Variables#In_computer_programming</ulink></citetitle>.</para>
      </tip>In Asterisk, variables have varying scope. There are local
    variables (called <emphasis>channel variables</emphasis> in Asterisk),
    which can only set values for the current, active channel, and global
    variables, which set values for all channels. We should already be
    familiar with some of the variables Asterisk sets from our exposure to
    them as configuration parameters in the Asterisk configuration files (such
    as <code>sip.conf</code>, for example). We also have the freedom to define
    our own variables and use them in configuration files.</para>

    <section id="variablen-auslesen">
      <title>Expanding variables in an extension</title>

      <para>The value of a variable can be obtained using the syntax
      <code>${VARIABLENNAME}</code>. There are variables that are
      automatically set by Asterisk. For example, the called number is always
      stored in the Asterisk system variable <code>${EXTEN}</code>. Using
      patterns and variables, it is often possible to dramatically compress a
      long dialplan.</para>

      <para>Before:<programlisting>exten =&gt; 100,1,Dial(SIP/100)
exten =&gt; 101,1,Dial(SIP/101)
exten =&gt; 102,1,Dial(SIP/102)
exten =&gt; 103,1,Dial(SIP/103)
exten =&gt; 104,1,Dial(SIP/104)
exten =&gt; 105,1,Dial(SIP/105)
exten =&gt; 106,1,Dial(SIP/106)
exten =&gt; 107,1,Dial(SIP/107)
exten =&gt; 108,1,Dial(SIP/108)
exten =&gt; 109,1,Dial(SIP/109)
</programlisting></para>

      <para>After:<programlisting>exten =&gt; _10X,1,Dial(SIP/${EXTEN})</programlisting></para>
    </section>

    <section id="variablen-allgemeines">
      <title>General</title>

      <para>Variablennamen m√ºssen nicht wie in unseren Beispielen
      gro√ügeschrieben werden und sind auch nicht an Gro√ü- und Kleinschreibung
      gebunden. Die Gro√üschreibung von Variablen f√ºhrt aber meistens zu besser
      lesbarem Code, da Sie bereits an der Schreibweise erkennen k√∂nnen, dass
      es sich um eine Variable handelt. Umgekehrt bedeutet das aber auch, dass
      Gro√ü- und Kleinschreibung nicht f√ºr die Unterscheidung von Variablen
      verwendet werden kann.<important>
          <para>Die von Asterisk selbst generierten Variablen wie ${EXTEN}
          m√ºssen immer in Gro√übuchstaben geschrieben werden.</para>
        </important></para>

      <section id="var-strings">
        <title>Strings</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Strings</secondary>
        </indexterm>

        <para>Strings (als Variablen, die keine Zahlen, sondern Text
        enthalten) sollten immer in Anf√ºhrungszeichen gesetzt werden. Asterisk
        akzeptiert sie aber auch ohne diese Markierung. So sind die folgenden
        zwei Zeilen im Ergebnis gleich:<programlisting>exten =&gt; 1234,1,Set(OBST=Apfel)
exten =&gt; 1234,2,Set(OBST="Apfel")</programlisting></para>

        <para>Sollte der String ein Komma oder ein Leerzeichen enthalten, dann
        <emphasis>m√ºssen</emphasis> Sie Anf√ºhrungszeichen verwenden, da diese
        sonst als Kommandos und nicht als Strings interpretiert
        werden:<programlisting>exten =&gt; 1234,1,Set(OBSTSORTEN="Apfel, Birne, usw.")</programlisting></para>
      </section>

      <section id="var-quoting">
        <title>Quoting</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Quoting</secondary>
        </indexterm>

        <para>Bei einer Variablen, die Zeichen oder Zeichenfolgen (W√∂rter,
        Text) als Werte enth√§lt, kann es vorkommen, dass man bestimmte Zeichen
        verwenden m√∂chte, die bereits f√ºr andere Funktionen reserviert sind.
        Wollen Sie zum Beispiel ein Underscore-Zeichen als Bestandteil des
        Variablenwertes verwenden, m√ºssen Sie es besonders kennzeichnen, bzw.
        maskieren. Diese Kennzeichnung nennt man beim Programmieren
        <phrase>escapen</phrase>. Folgende Zeichen m√ºssen auf jeden Fall
        maskiert (<quote>escaped</quote>) werden:<programlisting>[ ] $ " \</programlisting></para>

        <para>Das Quoting in der <filename>extensions.conf</filename> erfolgt
        mit einem vorangestellten <code>\</code> (Backslash).</para>

        <para>Beispiel:</para>

        <programlisting>exten =&gt; 1234,1,Set(BETRAG="10,00 US \$")</programlisting>
      </section>

      <section id="var-integer">
        <title>Integer</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Integer</secondary>
        </indexterm>

        <para>Bestehen Variablen aus einer Ganzzahl (Integer), so kann diese
        maximal 18 Stellen betragen. Bei Zahlen, die gr√∂√üer sind, tritt ein
        Fehler auf, der im Logfile protokolliert wird.<tip>
            <para>Wer mit gr√∂√üeren oder Kommazahlen (Real) arbeiten will, kann
            dies mit einem AGI-Skript realisieren (siehe <xref
            linkend="kapitel-agi" />).</para>
          </tip></para>
      </section>
    </section>

    <section id="globale-var-globals">
      <title>Globale Variablen in der <filename>extensions.conf</filename>
      definieren</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Globale Variablen in der extensions.conf ([globals])
        definieren.</secondary>
      </indexterm>

      <para>Eine globale Variable kann am Start der
      <filename>extensions.conf</filename> gesetzt werden. Dies muss im
      besonderen Context <code>[globals]</code> erfolgen (er folgt dem Context
      <code>[general]</code>).</para>

      <para>Beispiel:<programlisting>[general]

[globals]
KLINGELZEIT=90

[from-intern]
exten =&gt; _XXX,1,Dial(SIP/${EXTEN},${KLINGELZEIT})
exten =&gt; _XXX,n,VoiceMail(${EXTEN})
</programlisting></para>
    </section>

    <section id="global-var-set">
      <title>Variablen mit Set() definieren</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Set()</secondary>
      </indexterm>

      <para>Die Applikation <code> <code>Set()</code> </code> wird benutzt, um
      eine Variable in einer Extension zu setzen.<footnote>
          <para>siehe auch <xref linkend="applikationen-set" /></para>
        </footnote></para>

      <section id="set-syntax">
        <title>Syntax</title>

        <para><code>Set(Variablenname=Wert[,Variablenname2=Wert2][,Option])</code></para>

        <para>Als Option kann ein <parameter> <code>g</code> </parameter>
        angegeben werden. Mit diesem <parameter>g</parameter> kann mit
        <code>Set()</code> eine globale Variable gesetzt werden. Ohne diese
        Option geht Asterisk immer von lokalen Channel-Variablen aus.</para>

        <para>Beispiel:</para>

        <programlisting>; Eine globale Variable setzen:
exten =&gt; 10,1,Set(KLINGELZEIT=90,g)

; Eine Channel-Variable setzen:
exten =&gt; 10,2,Set(LIEBLINGSOBSTSORTE="Apfel")

; Zwei Channel-Variablen auf einmal setzen:
exten =&gt; 10,3,Set(VAR1=10,VAR2=23)

; Die Variablen auf dem CLI ausgeben
exten =&gt; 10,4,NoOp(KLINGELZEIT = ${KLINGELZEIT})
exten =&gt; 10,5,NoOp(LIEBLINGSOBSTSORTE = ${LIEBLINGSOBSTSORTE})
exten =&gt; 10,6,NoOp(VAR1 = ${VAR1})
exten =&gt; 10,7,NoOp(VAR2 = ${VAR2})</programlisting>
      </section>
    </section>

    <section id="var-vererbung">
      <title>Vererbung von Channel-Variablen</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Vererbung von Channel-Variablen</secondary>
      </indexterm>

      <para>Wird im Lauf eines Gespr√§ches ein weiterer Channel aufgebaut, so
      hat dieser nat√ºrlich wieder eigene Channel-Variablen.</para>

      <section id="var-einstufige-vererbung">
        <title>Einstufige Vererbung</title>

        <para>Will man eine Channel-Variable √ºbergeben, aber keine globale
        Variable daf√ºr benutzen, so kann man der Channel-Variable ein
        <code>_</code> (Underscore) voransetzen. Diese Channel-Variable wird
        dann an den n√§chsten Channel vererbt. Dabei wird der Underscore
        entfernt. Die Vererbung kann also nur einmal erfolgen.</para>

        <para>Beispiel:<programlisting>exten =&gt; 1234,1,Set(_KUCHENSORTE="Marmorkuchen")</programlisting></para>
      </section>

      <section id="var-mehrstufige-vererbung">
        <title>Mehrstufige Vererbung</title>

        <para>Will man eine Channel-Variable beliebig oft vererben, so muss
        man zwei <code>__</code> (Underscore)-Zeichen vor die Variable setzen.
        Die zwei Underscore-Zeichen werden dann immer mitvererbt.</para>

        <warning>
          <para>Asterisk unterscheidet die Namen von Variablen, die mit einem
          Underscore anfangen, nicht von Variablen, die keinen Underscore
          haben. So wird im folgenden Beispiel aus der vererbbaren
          Channel-Variable <code>KUCHENSORTE</code> eine normale (nicht
          vererbbare) Channel-Variable:<programlisting>exten =&gt; 1234,1,Set(__KUCHENSORTE="Marmorkuchen")
exten =&gt; 1234,n,Set(KUCHENSORTE="Marmorkuchen")</programlisting></para>
        </warning>

        <para>Beispiel:<programlisting>exten =&gt; 1234,1,Set(__KUCHENSORTE="Nusskuchen")</programlisting></para>

        <para>Bei einem Abruf einer vererbten Channel-Variable ist es egal, ob
        man die Unterstriche voranstellt oder nicht. Die beiden folgenden
        Zeilen geben zweimal den gleichen Wert im CLI aus:<programlisting>exten =&gt; 1234,1,NoOp(${__KUCHENSORTE})
exten =&gt; 1234,n,NoOp(${KUCHENSORTE})</programlisting></para>
      </section>
    </section>

    <section id="feste-channel-var">
      <title>Feste Channel-Variablen</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Feste Channel-Variablen</secondary>
      </indexterm>

      <para>Die folgende Liste enth√§lt die wichtigsten fest einprogrammierten
      Channel-Variablen, die nicht in der <filename>extensions.conf</filename>
      √ºberschrieben, aber ausgelesen werden k√∂nnen.<warning>
          <para>Eine komplette Liste aller vordefinierten Variablen finden Sie
          in der Datei <filename>doc/README.variables</filename> (Asterisk
          1.2) und <filename>doc/channelvariables.txt</filename> (Asterisk
          1.4). In dieser Liste werden nur nicht DEPRECATED Variablen
          aufgelistet. So finden Sie z.B. ein ${CALLERIDNUM} nicht in dieser
          Liste, weil dies deprecated ist (man soll anstatt die Funktion
          ${CALLERID(num)} benutzen).</para>
        </warning>Die f√ºr das jeweilige Thema relevanten Variablen werden aber
      im Buch immer in jedem Kapitel extra aufgef√ºhrt.<footnote>
          <para>Ein klassisches Henne-Ei-Problem</para>
        </footnote></para>

      <note>
        <para>Bei einigen der hier aufgef√ºhrten Variablen handelt es sich gar
        nicht um Variblen, sondern um eingebaute Funktionen. Da dies in der
        Praxis aber oft verschwimmt, werden sie hier trotzdem
        aufgelistet.</para>
      </note>

      <para><variablelist termlength="10">
          <?dbfo list-presentation="blocks"?>

          <?dbhtml list-presentation="list"?>

          <varlistentry>
            <term><code>${ANSWEREDTIME}</code></term>

            <listitem>
              <para>Die Gesamtzeit (in Sekunden) seitdem das Gespr√§ch zustande
              gekommen ist.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${BLINDTRANSFER}</code></term>

            <listitem>
              <para>Der Name des Channels auf der anderen Seite eines
              Blind-Transfers.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CHANNEL}</code></term>

            <listitem>
              <para>Name des aktuellen Channels</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CONTEXT}</code></term>

            <listitem>
              <para>Name des aktuellen Contextes</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EPOCH}</code></term>

            <listitem>
              <para>Aktueller Unix Style Epoch.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EXTEN}</code></term>

            <listitem>
              <para>Aktuell gew√§hlte Extension</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${ENV(VARIABLENNAME)}</code></term>

            <listitem>
              <para>Umgebungsvariable <code>VARIABLENNAME</code></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${HANGUPCAUSE}</code></term>

            <listitem>
              <para>Grund f√ºr das Beenden (hangup) eines Gespr√§ches</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${INVALID_EXTEN}</code></term>

            <listitem>
              <para>Wird in der <code>i</code>-Extension benutzt und enth√§lt
              die gew√§hlte Extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${PRIORITY}</code></term>

            <listitem>
              <para>Aktuelle Priorit√§t innerhalb der Extension</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${TRANSFER_CONTEXT}</code></term>

            <listitem>
              <para>Context eines weiterverbundenen Gespr√§ches</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${UNIQUEID}</code></term>

            <listitem>
              <para>Im System einzigartige (unique) ID f√ºr das aktuelle
              Gespr√§ch</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${SYSTEMNAME}</code></term>

            <listitem>
              <para>In der <filename>/etc/asterisk/asterisk.conf</filename>
              Datei eingetragener <parameter>systemname</parameter>
              Parameter.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>

    <section id="variablenmanipulation">
      <title>Variablenmanipulation</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Manipulation</secondary>
      </indexterm>

      <para>Variablen an sich er√∂ffnen ihren Nutzen erst dann, wenn man sie
      zur Laufzeit ver√§ndern kann. Mit Hilfe dieser Variabilit√§t lassen sich
      komplexe Verhaltensweisen steuern und vorsehen.</para>

      <section id="var-substring">
        <title>Substring</title>

        <para>In der Regel bezeichnen Strings eine Aneinanderreihung einzelner
        Zeichen (character). Die Gr√∂√üe eines Strings bestimmt sich durch die
        Anzahl der identifizierbaren einzelnen Zeichen. Zum Beispiel besteht
        der String <quote>Apfelbaum</quote> aus 9 Zeichen. Ein String kann
        grunds√§tzlich in so genannte Teilstrings zerlegt werden, also Strings,
        die, wenn man sie wieder aneinanderreiht, den urspr√ºnglichen String
        ergeben. Im genannten Beispiel k√∂nnten wir den String
        <quote>Apfelbaum</quote> in die Teilstrings <quote>Apfel</quote> und
        <quote>baum</quote> zerlegen, aber auch <quote>Apf</quote> und
        <quote>elbaum</quote> sind echte Teilstrings. Ein String hat
        theoretisch keine begrenzte Gr√∂√üe, er kann beliebig viele Zeichen
        enthalten, der gesamte Text dieses Buches k√∂nnte so als ein String
        aufgefasst werden. Nat√ºrlich w√§re das dann nicht mehr sehr handlich,
        dennoch ist der Vorgang des Zerlegens eines Strings in Teilstrings
        eine Standardprozedur beim Programmieren von Anwendungen. In vielen
        Programmiersprachen hei√üt die hier beschriebene Funktionalit√§t
        <emphasis>Substring</emphasis>. Mit einer Substring-Funktion kann man
        Teile eines Strings ausschneiden und das Ergebnis in einer anderen
        Variablen abspeichern. In Asterisk gibt es keine eigenst√§ndige Routine
        f√ºr diese Substring-Funktion, sondern hierf√ºr wird ein <code>:</code>
        (Doppelpunkt) nach dem Variablennamen eingesetzt. Vom Inhalt der
        Variablen, also dem String, wird dann eine vorgegebene Anzahl von
        Zeichen (L√§nge) als Teilstring abgetrennt.</para>

        <section id="var-substring-syntax">
          <title>Syntax</title>

          <para><synopsis>${<replaceable>VARIABLENNAME</replaceable>[:<replaceable>Start</replaceable>[:<replaceable>Laenge</replaceable>]]}</synopsis></para>
        </section>

        <section id="var-substring-beispiel">
          <title>Beispiele</title>

          <para>Bei einer Telefonanlage wird traditionell eine f√ºhrende 0
          (Null) gew√§hlt, um eine Amtsleitung zu bekommen. Die zu w√§hlende
          Telefonnummer darf diese 0 aber nicht enthalten. Wird die Nummer
          <code>0030 227 32320</code> gew√§hlt, so kann man mit folgender Zeile
          die eigentliche Rufnummer in die Variable
          <varname>${RUFNUMMER}</varname> abspeichern.<footnote>
              <para>F√ºr alle neugierigen Leser: Das ist die Telefonnummer des
              Parlamentsarchives des Deutschen Bundestages in Berlin.</para>
            </footnote> <programlisting>exten =&gt; _0X.,1,Set(RUFNUMMER=${EXTEN:1})</programlisting></para>

          <para>Wenn die Angabe der L√§nge fehlt, wird automatisch der Rest des
          Strings genommen.</para>

          <para>Wenn wir die letzten 5 Ziffern der gew√§hlten Nummer ben√∂tigen,
          dann erreichen wir das mit einer negativen Zahl. Bei der oben
          gew√§hlten Nummer w√ºrde die folgende Zeile den Wert 32320 in der
          Variablen <varname>${DURCHWAHL}</varname>
          abspeichern.<programlisting>exten =&gt; _0X.,1,Set(DURCHWAHL=${EXTEN:-5})</programlisting></para>

          <para>M√∂chten wir die Vorwahl in einer separaten Variable
          abspeichern, so erreichen wir dies durch:<programlisting>exten =&gt; _0X.,1,Set(VORWAHL=${EXTEN:1:3})</programlisting>Diese
          Zeile geht davon aus, dass die Vorwahl 3-stellig ist und speichert
          sie in der Variable <varname>${VORWAHL}</varname>.<footnote>
              <para>Leider macht diese Variante in Deutschland wenig Sinn, da
              es unterschiedlich lange Vorwahlen gibt. Mehr Informationen zur
              deutschen Vorwahl finden Sie unter <ulink
              url="http://de.wikipedia.org/wiki/Telefonvorwahl_%28Deutschland%29">
              <citetitle>http://de.wikipedia.org/wiki/Telefonvorwahl_%28Deutschland%29.</citetitle>
              </ulink></para>
            </footnote></para>

          <para>Nehmen wir an, wir m√∂chten bei Telefonaten zur Nummer
          <code>00012024562121</code> nach Amerika die einzelnen Bestandteile
          herausfiltern:<footnote>
              <para>Um Ihnen das Gespr√§ch nach Amerika zu sparen: Dies ist die
              Nummer der Besucherzentrale des Wei√üen Hauses in Washington DC.
              ;-)</para>
            </footnote><programlisting>exten =&gt; _0001X.,1,Set(INTERNATIONALEVORWAHL=${EXTEN:3:1})
exten =&gt; _0001X.,n,Set(ORTSVORWAHL=${EXTEN:4:3})
exten =&gt; _0001X.,n,Set(RUFNUMMER=${EXTEN:7})
exten =&gt; _0001X.,n,Set(DURCHWAHL=${EXTEN:-4}</programlisting></para>
        </section>
      </section>
    </section>
  </section>

  <section id="besondere-extensions">
    <title>Besondere Extensions</title>

    <indexterm>
      <primary>Extensions</primary>

      <secondary>Besondere Extensions</secondary>
    </indexterm>

    <para>Da s√§mtliche Programmierlogik √ºber Extensions programmiert werden
    muss, ben√∂tigen wir noch eine Reihe von besonderen und vom System
    vorbelegte Extensions.</para>

    <section id="h-extension">
      <title>Die h-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>h-Extension</secondary>
      </indexterm>

      <para>Das <code>h</code> steht bei dieser Standard-Extension f√ºr Hangup
      (Auflegen). Sie wird aufgerufen, sobald ein Gespr√§ch beendet wurde.
      Dabei muss ber√ºcksichtig werden, dass dann logischerweise der Wert der
      Variable <varname>${EXTEN}</varname> nicht mehr die urspr√ºngliche
      Extension, sondern den Wert <code>h</code> enth√§lt.</para>

      <section id="h-extension-beispiel">
        <title>Beispiel</title>

        <para>Sollen in der globalen Variable GESPRAECHE immer die Anzahl der
        aktuell gef√ºhrten Gespr√§che gespeichert werden, so muss diese beim
        Aufbau eines Gespr√§chs um 1 erh√∂ht und beim Abbau eines Gespr√§chs
        (also beim Auflegen) wieder um 1 vermindert werden. Der folgende
        Dialplan zeigt die Grundidee:<programlisting>[global]
GESPRAECHE=0

[from-intern]
exten =&gt; _X.,1,Set(GESPRAECHE=$[${GESPRAECHE} + 1]|g)
exten =&gt; _X.,2,Dial(SIP/${EXTEN})

exten =&gt; h,1,Set(GESPRAECHE=$[${GESPRAECHE} - 1]|g)</programlisting></para>
      </section>
    </section>

    <section id="i-extension">
      <title>Die i-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>i-Extension</secondary>
      </indexterm>

      <para>Um einen Context "wasserdicht" zu machen, wird die
      <code>i</code>-Extension benutzt. Das <code>i</code> steht dabei f√ºr
      invalid (ung√ºltig) und behandelt alle im entsprechenden Context nicht
      definierten Zielrufnummern. Auch hier wird in der Variable
      <code>EXTEN</code> nat√ºrlich nicht mehr die angew√§hlte Nummer
      abgebildet, diese ist mit der Variable <code>INVALID_EXTEN</code>
      abrufbar.</para>

      <section id="i-extension-beispiel">
        <title>Beispiel</title>

        <para>In der Apfelmus GmbH k√∂nnen aus der Abteilung B nur die
        Rufnummern 100 bis 199 angerufen werden. Alle anderen Gespr√§che f√ºhren
        zur Ansage des Bausteines that-is-not-rec-phn-num.<footnote>
            <para>Der Sprachbaustein in der Datei
            <filename>that-is-not-rec-phn-num.gsm</filename> enth√§lt den
            folgenden Text: "That is not a recognized phone number".</para>
          </footnote><programlisting>[abteilung-b]
exten =&gt; _1XX,1,Dial(${EXTEN})

exten =&gt; i,1,NoOp(Undefinierte Nummer ${INVALID_EXTEN} wurde gewaehlt.)
exten =&gt; i,2,Answer()
exten =&gt; i,3,Playback(that-is-not-rec-phn-num)
exten =&gt; i,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="o-und-a-extension">
      <title>Die o- und a-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>o-Extension</secondary>
      </indexterm>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>a-Extension</secondary>
      </indexterm>

      <para>Wurde in der Konfigurationsdatei
      <filename>voicemail.conf</filename> der Eintrag
      <code>operator=yes</code> gesetzt, so kann innerhalb der Voicemailbox
      durch Dr√ºcken der <code>0</code> (Null) die <code>o</code>-Extension
      aufgerufen werden (<code>o</code> f√ºr Operator).</para>

      <para>Durch Dr√ºcken der Stern-Taste (<code>*</code>) kommt man hingegen
      in die <code>a</code>-Extension (abort, Abbruch).</para>
    </section>

    <section id="t-extension">
      <title>Die t- und T-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>t-Extension</secondary>
      </indexterm>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>T-Extension</secondary>
      </indexterm>

      <para>Bei den <code>t</code>- und <code>T</code>-Extensions handelt es
      sich jeweils um Timeout-Extensions, also Zeit√ºberschreitungen.</para>

      <section id="klein-t-extension">
        <title>t-Extension</title>

        <para>Erfolgt nach einer bestimmten Zeit in einem IVR-Men√º keine
        Eingabe, so wird die <code>t</code>-Extension aufgerufen.</para>

        <para>Beispiel:<programlisting>[hauptmenue]
exten =&gt; 10,1,Answer()
exten =&gt; 10,n,Background(marryme)             ; "Heiraten? 1 f√ºr ja, 2 f√ºr nein"

exten =&gt; 1,1,Playback(thank-you-cooperation)  ; 1 =&gt; "Danke"
exten =&gt; 1,n,Hangup()

exten =&gt; 2,1,Playback(hangup-try-again)       ; 2 =&gt; "Nochmal probieren"
exten =&gt; 2,n,Hangup()

exten =&gt; t,1,Hangup()                         ; keine Eingabe =&gt; auflegen</programlisting></para>
      </section>

      <section id="gross-t-extension">
        <title>T-Extension</title>

        <para>Die <code>T</code>-Extension wird nach einem Absolute Timeout
        aufgerufen. Dieser kann mit
        <code>Set(TIMEOUT(absolute)=&lt;Sekunden&gt;)</code> gesetzt
        werden.<warning>
            <para>Bitte achten Sie darauf, das vor und nach dem "=" Zeichen
            kein Leerzeichen stehen darf.</para>
          </warning> Der Timeout wird immer dann gestartet, wenn der Z√§hler
        neu gesetzt wird (es wird also nicht automatisch vom Start des
        Gespr√§ches gez√§hlt). Mit <code>Set(TIMEOUT(absolute)=0)</code> wird
        dieser Timeout wieder deaktiviert.</para>

        <para>Beispiel:<programlisting>exten =&gt; 20,1,Answer()
exten =&gt; 20,2,Set(TIMEOUT(absolute)=120)
exten =&gt; 20,3,Playback(hello-world)
exten =&gt; 20,4,Wait(1)
exten =&gt; 20,5,Goto(3)

exten =&gt; T,1,Wait(1)
exten =&gt; T,2,Playback(thank-you-for-calling)
exten =&gt; T,3,Wait(1)
exten =&gt; T,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="s-extension">
      <title>Die s-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>s-Extension</secondary>
      </indexterm>

      <para>Der erste Parameter einer Regel (Extension) ist immer der Name
      bzw. die Nummer. Was passiert aber, falls der Anruf auf einer
      klassischen analogen Leitung eintrifft und Asterisk gar nicht wissen
      kann, an wen der Anruf gerichtet ist? Dies ist dann der Fall, wenn Sie
      Asterisk mittels eines analogen Anschlusses an das Festnetz anschlie√üen
      und die Rufnummerweitergabe aus dem Festnetz an den analogen
      Teilnehmeranschluss nicht erfolgt. F√ºr dieses und alle anderern
      Szenarien, in denen der eingehende Anruf ohne eine Zielrufnummer
      ankommt, gibt es die <code>s</code>-Extension.<warning>
          <para>Wenn Sie ein ATA-Device, also einen Analog to VoIP-Adapter
          benutzen, so ben√∂tigen Sie daf√ºr keine <code>s</code>-Extension. Die
          Zielrufnummer m√ºssen Sie hierbei im Adapter (meist √ºber ein
          Webinterface) konfigurieren.</para>
        </warning></para>

      <para>Beispiel:</para>

      <programlisting>exten =&gt; s,1,Answer()
exten =&gt; s,2,Wait(1)
exten =&gt; s,3,Play(carried-away-by-monkeys)
exten =&gt; s,4,Wait(1)
exten =&gt; s,5,Hangup()</programlisting>
    </section>
  </section>

  <section id="macro">
    <title>Macro</title>

    <para>Ein Macro ist eine Art Unterprogramm. Es kann komplexe Workflows
    enthalten und dann im restlichen Dialplan immer mit einer einzigen Zeile
    aufgerufen werden. Ein einfaches Beispiel kann so
    aussehen:<programlisting>[macro-anruf]
exten =&gt; s,1,Dial(SIP/${MACRO_EXTEN},10)
exten =&gt; s,n,VoiceMail(${MACRO_EXTEN})</programlisting></para>

    <para>Ein solches Macro w√ºrde im rest des Dialplanes dann wie folgt
    aufgerufen werden:<programlisting>[sales]
exten =&gt; _2XXX,1,Macro(anruf)

[hausmeister]
exten =&gt; _2XXX,1,Macro(anruf)</programlisting></para>

    <para>Bei einem zweizeiligen Macro ist der Effekt nat√ºrlich nicht so gro√ü
    wie bei einem langen Macro, aber es ist klar, worum es geht.</para>

    <para>Die Benutzung oder nicht Benutzung von Macros spaltet die Asterisk
    Entwicklergemeinde in zwei Lager. F√ºr die eine H√§lfte machen sie den
    Dialplan √ºbersichtlicher und f√ºr die andere H√§lfte machen sie ihn total
    un√ºbersichtlich. Entscheiden Sie selber, zu welcher Gruppierung Sie
    geh√∂ren!</para>

    <section id="macro-basics">
      <title>Macro Basics</title>

      <para>Bei der Definition eines Macros sind folgende Punkte zu
      beachten:</para>

      <itemizedlist>
        <listitem>
          <para>Bei der Definition eines Macros gibt es nur eine Extension
          (die s-Extension).</para>
        </listitem>

        <listitem>
          <para>Auf die urspr√ºnglichen Variablen
          <parameter>${EXTEN}</parameter> und
          <parameter>${CONTEXT}</parameter> kann innerhalb des Macros nicht
          direkt zugegriffen werden. Das geschieht √ºber die Variablen
          <parameter>${MACRO_EXTEN}</parameter> und
          <parameter>${MACRO_CONTEXT}</parameter>.</para>
        </listitem>

        <listitem>
          <para>Beim Aufruf eines Macros k√∂nnen zus√§tzliche Argumente
          √ºbergeben werden (mit Komma oder Pipe abgetrennt). Diese k√∂nnen im
          Macro mit <parameter>${ARGn}</parameter> (n ist dabei eine
          nat√ºrliche Zahl) abgerufen werden.</para>
        </listitem>

        <listitem>
          <para>Ein Macro wird durch <code>[macro-macroname]</code> definiert
          und mit der Applikation <command>Macro()</command> im Dialplan
          aufgerufen.</para>
        </listitem>
      </itemizedlist>

      <para>Weitere Informationen zu Macros finden Sie unter <xref
      linkend="applikationen-macro" />.<tip>
          <para>Mit der Applikation <command>MacroExclusive()</command> kann
          man sicherstellen, das das konkrete Macro immer nur einmal zu einem
          gegebenen Zeitpunkt aufgerufen wird (siehe <xref
          linkend="applikationen-macroexclusive" />).</para>
        </tip></para>
    </section>
  </section>

  <section id="priority-jumping">
    <title>Priority Jumping ist deprecated</title>

    <indexterm>
      <primary>Priority Jumping</primary>

      <secondary>+101</secondary>
    </indexterm>

    <para>Lange Zeit wurde in Asterisk Dialpl√§nen haupts√§chlich mit Priority
    Jumping gearbeitet. Dazu wurde von bestimmten Applikationen (z.B.
    <code>Dial()</code>) die Priorit√§t bei bestimmten Ereignissen um 101
    hochgesetzt. Diese Funktionalit√§t ist aber mittlerweile offiziell
    <emphasis>deprecated</emphasis> (also im Sinne von "√ºberholt")) und wird
    zwar teilweise noch unterst√ºtzt, sollte jedoch nicht mehr benutzt werden.
    Die Klassifizierung "deprecated" bezeichnet zumeist Funktionen und
    Funktionsaufrufe, f√ºr die mittlerweile entsprechende Nachfolger oder
    Folgekonstrukte existieren und k√ºnftig durch diese neuen ersetzt werden
    sollen. Beim Suchen nach L√∂sungen und Anregungen im Internet oder auch in
    anderen Asteriskb√ºchern werden Sie ebenfalls immer wieder auf
    L√∂sungsvorschl√§ge sto√üen, die dieses √ºberholte Konstrukt mit den
    Priorit√§ten verwenden. Auch wenn die Unterst√ºtzung f√ºr derart erstellte
    Dialpl√§ne sicher nicht morgen eingestellt wird, so werden sie doch
    mittelfristig schlechter unterst√ºtzt werden und man kann dann nicht sicher
    sein, dass es eine L√∂sung in der alten Notation geben wird. Es hat auch
    Vorteile sich aktiv mit einer Umstellung fr√ºhzeitig zu besch√§ftigen, da
    sie bei k√ºnftigen Updates der Asterisk-Software deutlich weniger Gefahr
    laufen werden, dass ihr Dialplan nicht mehr so funktioniert, wie sie das
    gewohnt sind.</para>
  </section>

  <xi:include href="applikationen.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="funktionen.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
</chapter>