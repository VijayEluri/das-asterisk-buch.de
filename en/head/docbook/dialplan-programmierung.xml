<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-programmieren" lang="en" revision="$Revision: 472 $">
  <!--% Copyright (c) 2006 - 2007 by
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% translated from the German by Stephen Bosch <sbosch@vodacomm.ca>
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Programming in the dialplan</title>

  <para>In Asterisk, functions or programs can be implemented either
  externally, through an AGI script (in much the same way that a CGI script
  can add functionality to a web page) or internally, through functions and
  applications in the dialplan. This chapter will focus strictly on the
  internal functions; AGI is treated in depth in a separate chapter.</para>

  <para>The dialplan is defined in the <filename>extensions.conf</filename>
  configuration file. The dialplan itself looks much like a BASIC program. The
  administrator can implement features and call flow using a simple scripting
  language.</para>

  <section id="programmierer-howto">
    <title>Programming "How-to"</title>

    <indexterm>
      <primary>How-to</primary>

      <secondary>Programming How-to</secondary>
    </indexterm>

    <para>A major challenge in writing a book like this one is that every
    reader comes to it with a different level of previous experience. A book
    on Asterisk might be read by administrators, programmers, telephone
    specialists, and hobbyists, all with different levels of practical
    experience. To take full advantage of Asterisk, a basic level of
    programming skill and a grasp of the fundamentals is necessary. Through
    this how-to, we hope to provide the newcomer with the basic understanding
    needed to make useful dialplans, through the use of plenty of examples and
    with frequent reference to <xref linkend="applikationen" />. You will
    probably recognize some of the material from other chapters. This little
    how-to should give you the overview you need to get started.</para>

    <section id="programmierer-howto-programmstruktur">
      <title>Program structure</title>

      <para>Each telephone number defined in the Asterisk dialplan
      (<filename>/etc/asterisk/extensions.conf</filename>) is really a small
      program. In Asterisk, the program is called an "extension." An extension
      looks like this:<programlisting>exten =&gt; 1001,1,Answer()
exten =&gt; 1001,n,Playback(hello-world)
exten =&gt; 1001,n,Hangup()</programlisting></para>

      <para>Priorities may also numbered sequentially:<programlisting>exten =&gt; 1001,1,Answer()
exten =&gt; 1001,2,Playback(hello-world)
exten =&gt; 1001,3,Hangup()</programlisting>The two extensions depicted here
      are functionally identical. If you use <code>n</code>, however, it makes
      adding and deleting entries in the extension much easier later
      on.</para>
    </section>

    <section id="programmierer-howto-variablen">
      <title>Variables</title>

      <para>Use the application Set() to create and change
      variables:<programlisting>exten =&gt; 1002,1,Set(Favoriteanimal = "Tiger")
exten =&gt; 1002,n,Set(Favoritenumber = 23)</programlisting></para>

      <para>Use the syntax <code>${VARIABLENNAME}</code> to read and print
      variables. You can print variable values on the CLI with
      <code>NoOp()</code> (with verbosity level 3 and up):<programlisting>exten =&gt; 1003,1,NoOp(${Favoriteanimal})
exten =&gt; 1003,n,NoOp(${Favoritenumber})</programlisting></para>

      <para>There are different kinds of variables:<itemizedlist>
          <listitem>
            <para>Global variables</para>

            <para>Valid anywhere in the dialplan and created or modified with
            <code>Set(&lt;variable&gt;=&lt;content&gt;,g):</code><programlisting>exten =&gt; 1004,1,Set(READABLEANYWHERE = 23,g)
exten =&gt; 1004,n,NoOp(${READABLEANYWHERE})</programlisting></para>
          </listitem>

          <listitem>
            <para>Channel variables</para>

            <para>Valid only in the current channel (a channel could be a
            connection between two people having a phone conversation).
            Created or modified with
            <code>Set(&lt;variable&gt;=&lt;content&gt;)</code> (without the
            <code>g</code>):<programlisting>exten =&gt; 1005,1,Set(READABLEHEREONLY= 42)
exten =&gt; 1005,n,NoOp(${READABLEHEREONLY})</programlisting></para>
          </listitem>

          <listitem>
            <para>System variables</para>

            <para>These dynamic variables are set by Asterisk and may be
            called in the dialplan without needing to create them. A
            frequently used system variable is ${EXTEN}:<programlisting>exten =&gt; 1006,1,NoOp(Dialed number: ${EXTEN})</programlisting></para>
          </listitem>
        </itemizedlist></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="variablen" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-labels-und-goto">
      <title>Labels and Goto()</title>

      <indexterm>
        <primary>Labels</primary>
      </indexterm>

      <para><code>Goto()</code> lets you jump from one dialplan entry to
      another. If you are using <code>n</code> priorities, this can be
      problematic. The solution is to use labels to tag specific entries and
      then call the entry by label in <code>Goto()</code>.</para>

      <para>Examples:</para>

      <itemizedlist>
        <listitem>
          <para>Within an extension:<programlisting>exten =&gt; 1007,1,Answer()
exten =&gt; 1007,n(Start),Wait(1)
exten =&gt; 1007,n,Playback(hello-world)
exten =&gt; 1007,n,Goto(Start)</programlisting></para>
        </listitem>

        <listitem>
          <para>Between extensions:<programlisting>exten =&gt; 1008,1,Answer()
exten =&gt; 1008,n,Goto(1009,Ping)

exten =&gt; 1009,1(Ping),Playback(hello-world)
exten =&gt; 1009,n,Wait(2)
exten =&gt; 1009,n,Goto(1010,Pong)

exten =&gt; 1010,1(Pong),Playback(tt-weasels)
exten =&gt; 1010,n,Wait(2)
exten =&gt; 1010,n,Goto(1009,Ping)</programlisting></para>
        </listitem>

        <listitem>
          <para>Between contexts:<programlisting>[hq]
exten =&gt; 1011,1,Answer()
exten =&gt; 1011,n,Playback(hello-world)
exten =&gt; 1011,n,Goto(sales,1012,1)

[sales]
exten =&gt; 1012,1,Playback(hello-world)
exten =&gt; 1012,n,Hangup()</programlisting></para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-goto" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-while">
      <title>While() loops</title>

      <indexterm>
        <primary>While() loops</primary>
      </indexterm>

      <para>Use <code>While()</code> to run loops in the
      dialplan:<programlisting>exten =&gt; 1013,1,Answer()
exten =&gt; 1013,n,Set(i=1)
exten =&gt; 1013,n,While($[${i} &lt; 10])
exten =&gt; 1013,n,SayNumber(${i})
exten =&gt; 1013,n,Wait(1)
exten =&gt; 1013,n,Set(i=$[${i} + 1])
exten =&gt; 1013,n,EndWhile()
exten =&gt; 1013,n,Hangup()</programlisting></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-while" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-gotoif">
      <title>GotoIf() conditional</title>

      <indexterm>
        <primary>GotoIf() conditional</primary>
      </indexterm>

      <para>You can jump to other parts of the dialplan depending on a
      specific condition being met with <code>GotoIf()</code>:<programlisting>exten =&gt; 1014,1,Answer()
exten =&gt; 1014,n,Set(Favoritestation = 0815)
exten =&gt; 1014,n,NoOp(Check to see if ${Favoritestation} is calling.)
exten =&gt; 1014,n,GotoIf($[${CALLERID(num) = ${Favoritestation}]?yes,no)

exten =&gt; 1014,n(yes),Playback(hello-world)
exten =&gt; 1014,n,Hangup()

exten =&gt; 1014,n(no),Playback(tt-monkeys)
exten =&gt; 1014,n,Hangup()</programlisting></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-gotoif" /></para>
      </formalpara>
    </section>

    <section id="programmier-howto-gosub">
      <title>Gosub() subroutines</title>

      <indexterm>
        <primary>Gosub() subroutines</primary>
      </indexterm>

      <para>With <code>Gosub()</code> the call is directed to a subroutine; it
      can be returned to the intiating priority with <code>Return()</code>
      wieder zurück:<programlisting>exten =&gt; 1015,1,Gosub(cid-set)
exten =&gt; 1015,n,Dial(SIP/${EXTEN})

exten =&gt; 1015,n(cid-set),Set(CALLERID(all)=Apfelmus GmbH &lt;012345678&gt;)
exten =&gt; 1015,n,Return()</programlisting></para>

      <formalpara>
        <title>See also:</title>

        <para><xref linkend="applikationen-gosub" />, <xref
        linkend="applikationen-gosubif" />, <xref
        linkend="applikationen-return" />, <xref
        linkend="applikationen-macro" /></para>
      </formalpara>
    </section>
  </section>

  <section id="variablen">
    <title>Variables</title>

    <indexterm>
      <primary>Variablen</primary>
    </indexterm>

    <para>A variable is a placeholder for an actual value. Exactly what that
    value is depends on the kind of variable. In Asterisk, variables can
    contain numbers, letters and strings (sequences of letters and numbers).
    Variables are useful because they let us create rules for call flow that
    apply in changing circumstances and make it easier to accommodate future
    changes in the telephone application or system.<tip>
        <para>If you've never worked with variables before, we recommend you
        read an introduction to the subject at <citetitle> <ulink
        url="???">http://en.wikipedia.org/wiki/Variables#In_computer_programming</ulink>
        </citetitle>.</para>
      </tip>In Asterisk, variables have varying scope. There are local
    variables (called <emphasis>channel variables</emphasis> in Asterisk),
    which can only set values for the current, active channel, and global
    variables, which set values for all channels. We should already be
    familiar with some of the variables Asterisk sets from our exposure to
    them as configuration parameters in the Asterisk configuration files (such
    as <code>sip.conf</code>, for example). We also have the freedom to define
    our own variables and use them in configuration files.</para>

    <section id="variablen-auslesen">
      <title>Expanding variables in an extension</title>

      <para>The value of a variable can be obtained using the syntax
      <code>${VARIABLENNAME}</code>. There are variables that are
      automatically set by Asterisk. For example, the called number is always
      stored in the Asterisk system variable <code>${EXTEN}</code>. Using
      patterns and variables, it is often possible to dramatically compress a
      long dialplan.</para>

      <para>Before:<programlisting>exten =&gt; 100,1,Dial(SIP/100)
exten =&gt; 101,1,Dial(SIP/101)
exten =&gt; 102,1,Dial(SIP/102)
exten =&gt; 103,1,Dial(SIP/103)
exten =&gt; 104,1,Dial(SIP/104)
exten =&gt; 105,1,Dial(SIP/105)
exten =&gt; 106,1,Dial(SIP/106)
exten =&gt; 107,1,Dial(SIP/107)
exten =&gt; 108,1,Dial(SIP/108)
exten =&gt; 109,1,Dial(SIP/109)
</programlisting></para>

      <para>After:<programlisting>exten =&gt; _10X,1,Dial(SIP/${EXTEN})</programlisting></para>
    </section>

    <section id="variablen-allgemeines">
      <title>General considerations</title>

      <para>Variable names needn't be in all uppercase as in our examples, nor
      are user-defined variables case-sensitive. It is a good idea to use
      uppercase variable names nonetheless because it makes the variables
      easier to identify and the dialplan code easier to read. The primary
      disadvantage of this is that it means you cannot distinguish variable
      names based on case. For example, <code>${FOO}</code> is considered the
      same as <code>${foo}</code>.<important>
          <para>Asterisk system variables such as ${EXTEN} must always be
          uppercase.</para>
        </important></para>

      <section id="var-strings">
        <title>String variables</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Strings</secondary>
        </indexterm>

        <para>String variables (meaning variables that contain text and not
        numbers) should be defined using double quotes, though Asterisk will
        still accept them without double quotes - the following two entries
        are functionally identical:<programlisting>exten =&gt; 1234,1,Set(FRUIT=Apple)
exten =&gt; 1234,2,Set(FRUIT="Apple")</programlisting></para>

        <para>If the string contains commas or spaces, you must use double
        quotes:<programlisting>exten =&gt; 1234,1,Set(FRUITTYPES="Apple, Pear, etc.")</programlisting>This
        is why it is a good idea to get into the habit of using them for any
        string variables you define.</para>
      </section>

      <section id="var-quoting">
        <title>Reserved characters</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Quoting</secondary>
        </indexterm>

        <para>Sometimes a variable will contain reserved characters
        (characters that have special functions and are interpreted
        differently). For example, if you want to variable to contain the
        underscore character ("<code>_</code>") you must use an "escape"
        character to tell the dialplan interpreter that it should ignore the
        reserved character. The following characters must be escaped when used
        in a variable:<programlisting>[ ] $ " \</programlisting></para>

        <para>The escape character in <filename>extensions.conf</filename> is
        "<code>\</code>" (backslash):</para>

        <para>Example:</para>

        <programlisting>exten =&gt; 1234,1,Set(AMOUNT="\$10.00")</programlisting>

        <para>Similarly, if you want to use the backslash character in a
        variable, you must escape it:<programlisting>exten =&gt; 1234,1,Set(ROOMNUMBER="48\\10")</programlisting></para>
      </section>

      <section id="var-integer">
        <title>Integers</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Integer</secondary>
        </indexterm>

        <para>If a variable contains an integer, it can have no more than 18
        digits. Anything larger will cause an error which will be recorded in
        the log file.<tip>
            <para>If you need to work with larger integers or floating point
            numbers, you can use an AGI script (see <xref
            linkend="kapitel-agi" />).</para>
          </tip></para>
      </section>
    </section>

    <section id="globale-var-globals">
      <title>Defining global variables in
      <filename>extensions.conf</filename></title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Globale Variablen in der extensions.conf ([globals])
        definieren.</secondary>
      </indexterm>

      <para>Global variables are defined at the beginning of
      <filename>extensions.conf</filename>. You must place them in the special
      <code>[globals]</code> context, which follows
      <code>[general]</code>.</para>

      <para>Example:<programlisting>[general]

[globals]
RINGTIME=90

[from-intern]
exten =&gt; _XXX,1,Dial(SIP/${EXTEN},${RINGTIME})
exten =&gt; _XXX,n,VoiceMail(${EXTEN})
</programlisting></para>
    </section>

    <section id="global-var-set">
      <title>Defining variables with Set()</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Set()</secondary>
      </indexterm>

      <para><code> <code>Set()</code> </code> is used to define a variable
      inside an extension.<footnote>
          <para>see also <xref linkend="applikationen-set" /></para>
        </footnote></para>

      <section id="set-syntax">
        <title>Syntax</title>

        <para><code>Set(&lt;variable1&gt;=&lt;value1&gt;[,&lt;variable2&gt;=&lt;value2&gt;][,&lt;option&gt;])</code></para>

        <para>Setting option <parameter> <code>g</code> </parameter>makes the
        variable global; without it, the variable is treated as a local
        channel variable.</para>

        <para>Example:</para>

        <programlisting>; Set a global variable:
exten =&gt; 10,1,Set(RINGTIME=90,g)

; Set a local channel variable:
exten =&gt; 10,2,Set(FAVORITEFRUIT="Apple")

; Set two channel variables at once:
exten =&gt; 10,3,Set(VAR1=10,VAR2=23)

; Print variables to the CLI
exten =&gt; 10,4,NoOp(RINGTIME = ${RINGTIME})
exten =&gt; 10,5,NoOp(FAVORITEFRUIT = ${FAVORITEFRUIT})
exten =&gt; 10,6,NoOp(VAR1 = ${VAR1})
exten =&gt; 10,7,NoOp(VAR2 = ${VAR2})</programlisting>
      </section>
    </section>

    <section id="var-vererbung">
      <title>Inheritance of channel variables</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Vererbung von Channel-Variablen</secondary>
      </indexterm>

      <para>If new channels are spawned while a conversation is in progress,
      they will have their own channel variables.</para>

      <section id="var-einstufige-vererbung">
        <title>Single-level inheritance</title>

        <para>Sometimes you want to have a channel variable persist into the
        spawned channel. You can do this by prefixing the variable with an "_"
        (underscore) character. When the variable is inherited by the spawned
        channel, Asterisk automatically removes the prefix. This ensures that
        the variable is inherited only once.</para>

        <para>Example:<programlisting>exten =&gt; 1234,1,Set(_CAKE="Marble cake")</programlisting></para>
      </section>

      <section id="var-mehrstufige-vererbung">
        <title>Multi-level inheritance</title>

        <para>If you need unlimited inheritance of a channel variable, you can
        do this by prefixing the variable with two "_" (underscore)
        characters. Variables prefixed in this way will always be inherited by
        spawned channels.</para>

        <warning>
          <para>Asterisk makes no distinction between variable names that are
          preceded with an underscore and those that are not. In the example
          below, a variable with multi-level inheritance
          ("<code>__CAKE</code>") is rendered uninheritable by the subsequent
          entry:<programlisting>exten =&gt; 1234,1,Set(__CAKE="Marble cake")
exten =&gt; 1234,n,Set(CAKE="Marble cake")</programlisting></para>
        </warning>

        <para>Example:<programlisting>exten =&gt; 1234,1,Set(__CAKE="Sponge cake")</programlisting></para>

        <para>When calling an inherited variable, it doesn't matter if it is
        called with a prefix or not. These entries will give the same output
        in the CLI:<programlisting>exten =&gt; 1234,1,NoOp(${__CAKE})
exten =&gt; 1234,n,NoOp(${CAKE})</programlisting></para>
      </section>
    </section>

    <section id="feste-channel-var">
      <title>System channel variables</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Feste Channel-Variablen</secondary>
      </indexterm>

      <para>The following list describes the more important system channel
      variables. These variables may be read but not overwritten by entries in
      <filename>extensions.conf</filename>, as they are pre-defined by
      Asterisk.<warning>
          <para>A complete list of all the pre-defined variables may be found
          in <filename>doc/README.variables</filename> (Asterisk 1.2) and
          <filename>doc/channelvariables.txt</filename> (Asterisk 1.4).
          Deprecated variables are not included in this list. For example, the
          variable ${CALLERIDNUM} (previously commonly used) is not in this
          list; it is preferable to use the Asterisk function ${CALLERID(num)}
          instead.</para>
        </warning><tip>
          <para>It is a good practice to replace dialplan code that depends on
          deprecated variables or functions with code that uses the
          recommended replacements. This will reduce the chance of an
          installation breaking when you upgrade Asterisk.</para>
        </tip>System variables relevant to specific Asterisk functions are
      covered again in their respective chapters.<footnote>
          <para>A classic "Which comes first, the chicken or the egg?"
          problem!</para>
        </footnote></para>

      <note>
        <para>Some of the "variables" described here are not really variables
        but in fact built-in <emphasis>functions</emphasis>. In practice, they
        often play a similar role, so they are listed here for
        convenience.</para>
      </note>

      <para><variablelist termlength="10">
          <?dbfo list-presentation="blocks"?>

          <?dbhtml list-presentation="list"?>

          <varlistentry>
            <term><code>${ANSWEREDTIME}</code></term>

            <listitem>
              <para>The total elapsed time for the active connection (in other
              words, the number of seconds since the conversation
              started).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${BLINDTRANSFER}</code></term>

            <listitem>
              <para>The name of the channel on the other side of a blind
              transfer.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CHANNEL}</code></term>

            <listitem>
              <para>Name of the current channel.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CONTEXT}</code></term>

            <listitem>
              <para>Name of the current context.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EPOCH}</code></term>

            <listitem>
              <para>Current Unix time (total number of seconds elapsed since
              the beginning of the Unix "epoch", which began at midnight UTC,
              January 1st, 1970)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EXTEN}</code></term>

            <listitem>
              <para>Currently dialed extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${ENV(VARIABLENAME)}</code></term>

            <listitem>
              <para>Environment variable <code>VARIABLENAME</code></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${HANGUPCAUSE}</code></term>

            <listitem>
              <para>Cause of connection hang-up.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${INVALID_EXTEN}</code></term>

            <listitem>
              <para>Used in the <code>i</code> extension and contains the
              dialed extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${PRIORITY}</code></term>

            <listitem>
              <para>Current priority in the current extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${TRANSFER_CONTEXT}</code></term>

            <listitem>
              <para>Context of a transferred call.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${UNIQUEID}</code></term>

            <listitem>
              <para>The unique ID for the current connection.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${SYSTEMNAME}</code></term>

            <listitem>
              <para>The system name as defined by <code>systemname</code> in
              <filename>/etc/asterisk/asterisk.conf</filename>.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>

    <section id="variablenmanipulation">
      <title>Manipulating variables</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Manipulation</secondary>
      </indexterm>

      <para>Variables are most useful when we can change their contents at
      execution time. This gives us the flexibility to impart complex and
      powerful behavior to our Asterisk system.</para>

      <section id="var-substring">
        <title>Substring</title>

        <para>In general, a string consistes of a sequence of individual
        characters. The size of a string is determined by the number of
        characters contained in it. For example, the string "apple tree" has
        10 characters (we must include the space). Any string can be broken
        into substrings. For example, "apple", "tree", "app" and "le tre" are
        all valid substrings of "apple tree". In theory, a string can be of
        any length; this entire book could be contained in a single string,
        though it would be impractical. Manipulation of strings is an
        important technique in programming applications. Asterisk lets you
        manipulate strings and substrings using the <code>:</code> (colon)
        character. Using the <code>:</code> character, you can extract a
        specified portion of an existing string variable.</para>

        <section id="var-substring-syntax">
          <title>Syntax</title>

          <para><synopsis>${<replaceable>VARIABLENAME</replaceable>[:<replaceable>start</replaceable>[:<replaceable>length</replaceable>]]}</synopsis></para>
        </section>

        <section id="var-substring-beispiel">
          <title>Examples</title>

          <para>Many telephone systems require that a prefix digit be dialled
          in order to get an outside line (In North America, this is usually
          "9"). The target number, however, cannot include this prefix digit.
          If we dial <code>9-1-202-7075000</code>, we can store the actual
          outside number in the <varname>${OUTGOINGNUMBER}</varname> using the
          following dialplan entry.<footnote>
              <para>For our curious readers: this is the general information
              number for the Library of Congress in Washington, D.C.</para>
            </footnote> <programlisting>exten =&gt; _0X.,1,Set(OUTGOINGNUMBER=${EXTEN:1})</programlisting></para>

          <para>If the <emphasis>length</emphasis> option is omitted, the rest
          of the string is taken automatically.</para>

          <para>What if we only need the last seven digits of the dialed
          number? I this case we use a negative number for the start
          parameter. The following entry would store 7075000 from our example
          above in the variable <code>${LOCALNUMBER}</code>.<footnote>
              <para>Under the original rules of the NANP (North American
              Numbering Plan) the last seven digits of a number constituted
              the local portion of the number. That is, if your telephone
              number was in the same area code as the dialed number, you
              needed only to dial seven digits. Population growth and density
              means that the number spaces of many area codes are becoming
              depleted. To minimize disruption, the NANP has been extended
              with <emphasis>overlay dialplans</emphasis>. In areas with
              overlay plans, two telephone lines on the same street, or even
              in the same building, may have different area codes. You are in
              an overlay area if you are required to dial 10 digits for local
              calls. In this case, a local number filter as depicted above
              will not be appropriate. Also, many area codes covering larger
              areas still have portions of the number space that are treated
              as long distance. You can read more about this at <citetitle>
              <ulink
              url="???">http://en.wikipedia.org/wiki/Overlay_plan</ulink>
              </citetitle>.</para>
            </footnote><programlisting>exten =&gt; _0X.,1,Set(LOCALNUMBER=${EXTEN:-7})</programlisting></para>

          <para>We can also capture just the area code:<programlisting>exten =&gt; _0X.,1,Set(AREACODE=${EXTEN:2:3})</programlisting><note>
              <para>Obviously, readers in other parts of the world
              (<emphasis>e.g.</emphasis> the United Kingdom, Australia, or
              elsewhere) will have different national dialplans which impact
              how outside numbers should be processed. Some countries have
              area and city codes which are variable in length; in those
              cases, this kind of number filtering will not be
              practical.</para>
            </note></para>

          <para>Here, then, is how we might extract useful information from a
          dialed number:<programlisting>exten =&gt; _9X.,1,Set(AREACODE=${EXTEN:2:3})
exten =&gt; _9X.,n,Set(LOCALNUMBER=${EXTEN:5})</programlisting></para>
        </section>
      </section>
    </section>
  </section>

  <section id="besondere-extensions">
    <title>Special extensions</title>

    <indexterm>
      <primary>Extensions</primary>

      <secondary>Special Extensions</secondary>
    </indexterm>

    <para>Because all the programming logic must occur via extensions, we need
    some additional system-defined extensions.</para>

    <section id="h-extension">
      <title>The <code>h</code> extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>h</code> Extension</secondary>
      </indexterm>

      <para>The <code>h</code> is the standard "hang-up" extension. The
      <code>h</code> extension, if it is configured, is called when a caller
      hangs up the phone. Note that as soon as this happens, the content of
      <varname>${EXTEN}</varname> changes to <code>h</code>.</para>

      <section id="h-extension-beispiel">
        <title>Example</title>

        <para>Say we want the global variable <code>CONNECTIONS</code> to
        reflect the number of currently active conversations at any given
        time. This means we need the value of <code>CONNECTIONS</code> to
        increase by one every time a connection is initiated and decrease by
        one every time someone hangs up. The following dialplan illustrates
        the basic idea:<programlisting>[global]
CONNECTIONS=0

[from-internal]
exten =&gt; _X.,1,Set(CONNECTIONS=$[${CONNECTIONS} + 1]|g)
exten =&gt; _X.,2,Dial(SIP/${EXTEN})

exten =&gt; h,1,Set(CONNECTIONS=$[${CONNECTIONS} - 1]|g)</programlisting></para>
      </section>
    </section>

    <section id="i-extension">
      <title>The <code>i</code> extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>i</code> Extension</secondary>
      </indexterm>

      <para>To make a context gracefully handle every conceivable
      circumstance, we use the special extension<code> i</code> ("i" stands
      for invalid) which handles all dialed numbers which are not explicitly
      handled handled within the context. Again, as with the <code>h</code>
      extension, once the <code>i</code> extension is invoked the
      <code>${EXTEN}</code> will no longer contain the dialed number. To get
      the dialed number while in the <code>i</code> extension, use
      <code>${INVALID_EXTEN}</code>.</para>

      <section id="i-extension-beispiel">
        <title>Example</title>

        <para>In our example business, Widgets, Inc., employees in department
        B can only dial extensions 100 to 199. Callers dialing any other
        numbers hear the message, "I'm sorry. That is not a valid extension.
        Please try again."<programlisting>[department-b]
exten =&gt; _1XX,1,Dial(${EXTEN})

exten =&gt; i,1,NoOp(An invalid number ${INVALID_EXTEN} was dialed.)
exten =&gt; i,2,Answer()
exten =&gt; i,3,Playback(invalid)
exten =&gt; i,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="o-und-a-extension">
      <title>The <code>o</code> and <code>a</code> extensions</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>o</code> Extension</secondary>
      </indexterm>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>a</code> Extension</secondary>
      </indexterm>

      <para>If <code>operator=yes</code> is set in
      <filename>voicemail.conf</filename>, the call will be directed to the o
      extension (o is for operator, kids!) if the caller presses
      "<code>0</code>".</para>

      <para>Pressing <code>*</code> (asterisk) will direct the call to the
      <code>a</code> extension (abort).</para>
    </section>

    <section id="t-extension">
      <title>The <code>t</code> and <code>T</code> extensions</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>t</code> Extension</secondary>
      </indexterm>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>T</code> Extension</secondary>
      </indexterm>

      <para>The <code>t</code> and <code>T</code> extensions are for handling
      timeouts in the context.</para>

      <section id="klein-t-extension">
        <title><code>t</code> extension</title>

        <para>If there is no input in an IVR menu within a certain time, the
        <code>t</code> extension is called.</para>

        <para>Example:<programlisting>[mainmenu]
exten =&gt; 10,1,Answer()
exten =&gt; 10,n,Background(marryme)             ; "Marry me? Press 1 for yes, 2 for no."

exten =&gt; 1,1,Playback(thank-you-cooperation)  ; 1 =&gt; "Thank you."
exten =&gt; 1,n,Hangup()

exten =&gt; 2,1,Playback(hangup-try-again)       ; 2 =&gt; "Hang up and try again."
exten =&gt; 2,n,Hangup()

exten =&gt; t,1,Hangup()                         ; no input =&gt; hang up</programlisting></para>
      </section>

      <section id="gross-t-extension">
        <title><code>T</code> extension</title>

        <para>The <code>T</code> extension is called after the absolute
        timeout has been exceeded. You can set this timeout value with
        <code>Set(TIMEOUT(absolute)=&lt;seconds&gt;)</code>.<warning>
            <para>Be careful not to have any spaces before and after the "="
            character.</para>
          </warning>The timer starts whenever the timeout value is set (in
        other words, it does not automatically start with the connection, it
        must be started explicitly with the <code>Set()</code> command).
        <code>Set(TIMEOUT(absolute)=0)</code> deactivates the absolute
        timeout.</para>

        <para>Example:<programlisting>exten =&gt; 20,1,Answer()
exten =&gt; 20,2,Set(TIMEOUT(absolute)=120)
exten =&gt; 20,3,Playback(hello-world)
exten =&gt; 20,4,Wait(1)
exten =&gt; 20,5,Goto(3)

exten =&gt; T,1,Wait(1)
exten =&gt; T,2,Playback(thank-you-for-calling)
exten =&gt; T,3,Wait(1)
exten =&gt; T,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="s-extension">
      <title>The <code>s</code> extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary><code>s</code> Extension</secondary>
      </indexterm>

      <para>The first entry in any extension is always the name or number
      dialed by the caller. When a call comes in from the PSTN, however,
      Asterisk doesn't know what was dialed or whom the caller is trying to
      reach. For any scenario in which we cannot determine the number dialed,
      we use the <code>s</code> extension. <warning>
          <para>If you are using an ATA device (<emphasis>analog telephone
          adapter</emphasis>) you don't need the <code>s</code> extension. You
          can configured the dialled number in the configuration interface
          (often a web interface) for the ATA.</para>
        </warning></para>

      <para>Example:</para>

      <programlisting>exten =&gt; s,1,Answer()
exten =&gt; s,2,Wait(1)
exten =&gt; s,3,Play(tt-monkeys)
exten =&gt; s,4,Wait(1)
exten =&gt; s,5,Hangup()</programlisting>
    </section>
  </section>

  <section id="macro">
    <title>Macros</title>

    <para>A macro is a kind of subroutine. It can contain complex workflows
    but is called through a single entry. This reduces repetition in the
    dialplan and makes it cleaner and smaller. A simple example might look
    like this:<programlisting>[macro-incoming]
exten =&gt; s,1,Dial(SIP/${MACRO_EXTEN},10)
exten =&gt; s,n,VoiceMail(${MACRO_EXTEN})</programlisting></para>

    <para>Ein solches Macro würde im rest des Dialplanes dann wie folgt
    aufgerufen werden:<programlisting>[sales]
exten =&gt; _2XXX,1,Macro(incoming)

[building-mgr]
exten =&gt; _2XXX,1,Macro(incoming)</programlisting></para>

    <para>The effect is not quite so impressive with a two-line macro as it
    would be with a much longer macro, but the advantages of such an approach
    should be clear.</para>

    <para>The use of macros tends to divide the Asterisk user community into
    two groups. One feels that macros make the dialplan easier to understand,
    the other feels that they make the dialplan confusing. We encourage you to
    draw your own conclusions!</para>

    <section id="macro-basics">
      <title>Macro basics</title>

      <para>When defining macros, take care to note the following
      points:</para>

      <itemizedlist>
        <listitem>
          <para>When defining a macro, only one extension - the s extension -
          is allowed.</para>
        </listitem>

        <listitem>
          <para>The original <parameter>${EXTEN}</parameter> and
          <parameter>${CONTEXT}</parameter> variables cannot be used inside a
          macro. We must use <parameter>${MACRO_EXTEN}</parameter> and
          <parameter>${MACRO_CONTEXT}</parameter> instead.</para>
        </listitem>

        <listitem>
          <para>When calling a macro, additional comma- (",") or
          pipe-separated ("|") arguments can be supplied. These arguments are
          called within the macro with <parameter>${ARGn}</parameter> (where
          <emphasis>n</emphasis> is a positive integer indicating which
          argument in the sequence).</para>
        </listitem>

        <listitem>
          <para>A macro is defined in square brackets
          (<code>[macro-macroname]</code>) and is called with the
          <command>Macro()</command> application in an extension.</para>
        </listitem>
      </itemizedlist>

      <para>More information on macros may be found at <xref
      linkend="applikationen-macro" />.<tip>
          <para>The application <command>MacroExclusive()</command> ensures
          that the specific macro can only be called once at any given time.
          If another channel is calling the macro, no other channel can call
          it until it completes (see <xref
          linkend="applikationen-macroexclusive" />).</para>
        </tip></para>
    </section>
  </section>

  <section id="priority-jumping">
    <title>Priority jumping is deprecated</title>

    <indexterm>
      <primary>Priority Jumping</primary>

      <secondary>+101</secondary>
    </indexterm>

    <para>For a long time, priority jumping was a standard way of moving a
    call about the dialplan. Specific applications (<emphasis>e.g.</emphasis>
    <code><command>Dial()</command></code>) would elevate the priority by 101
    under certain circumstances. This feature is now officially deprecated.
    Basically, this means that while it is currently still supported,
    eventually it <emphasis>will</emphasis> be removed. Anyone who continues
    to use it is making their dialplans vulnerable to failure after an
    upgrade.</para>

    <para>In working with Asterisk you will encounter dialplan configuration
    examples on the Internet; it is not uncommon to stumble upon grossly
    outdated examples that use deprecated constructs. In professional practice
    you should use the most current code constructions and versions of
    Asterisk. The software is always being updated, but deprecated features
    are not maintained.</para>

    <para>In summary: if you want the operation of your Asterisk systems to be
    as predictable as possible, keep your code current!</para>
  </section>

</chapter>