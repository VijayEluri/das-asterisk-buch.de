<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-protokolle" lang="en" revision="$Revision: 631 $">
  <!--% Copyright (c) 2006 - 2007 by 
- Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Protocols</title>

  <section id="protokolle-einleitung">
    <title>Introduction</title>

    <para>This chapter will cover the techniques by which we actually get
    voice data from one point to another. The session protocols for this
    purpose are really a kind of "grammar" that governs this transmission, and
    are in turn built upon the transport layer protocols that make up the
    TCP/IP protocol stack: namely TCP and UDP. You should have a fundamental
    understanding of these protocols when troubleshooting certain problems,
    which is why we are describing them in some detail here. This
    understanding is not strictly necessary to implement Asterisk but is
    nevertheless valuable. As such, this chapter is intended as a reference in
    the event it is needed.</para>
  </section>

  <section id="netzwerkprotokolle">
    <title>Network protocols</title>

    <para>We recommend you look at the Wikipedia articles describing the
    transport protocols, which cover them in considerably more depth.<footnote>
        <para>See <citetitle><ulink
        url="???">http://en.wikipedia.org/wiki/Transmission_Control_Protocol</ulink></citetitle>
        and <citetitle><ulink
        url="???">http://en.wikipedia.org/wiki/User_Datagram_Protocol</ulink></citetitle></para>
      </footnote></para>

    <para>For the impatient among you, here is a simple and brief definition:
    TCP is a protocol which ensures that all the information transmitted by
    the sender arrives at the receiver complete and in the correct order. This
    reliability is at the cost of relatively higher transmission overhead,
    which, during times of congestion, is more likely to lead to interruptions
    or delays in transmission. By contrast, its sister protocol UDP invests
    almost nothing in assuring that everything is received; instead, it merely
    sends out every packet as soon it is ready to be delivered without regard
    to whether it arrives intact or even in the right sequence.</para>

    <para>Both protocols are of importance in VoIP applications, because
    connections are established using TCP, whereas the voice data itself is
    transmitted using UDP. Particularly where audio data packets are
    concerned, quantity is indeed more important than quality.</para>

    <section id="tcp">
      <title>Transmission Control Protocol (TCP)</title>

      <para>The Transmission Control Protocol (TCP) is a protocol governing
      the transmission of data between computers. The operating systems of all
      modern computer understand and support TCP and use it to exchange data
      with other computers on a network. It is a reliable, connection-oriented
      transport protocol, and forms part of the Internet Protocol
      family.</para>

      <para>TCP was developed by Robert E. Kahn and Vinton G. Cerf, beginning
      initially as a research project in 1973 and culminating in the
      publication, in 1981, of the Internet standards document RFC<footnote>
          <para>"Request for Comments". These documents begin as simple
          proposals addressed to peers in the Internet engineering community
          and subject to revision; when a draft proposal has been accepted it
          is annotated and becomes part of the body of standards.</para>
        </footnote> 793, which forms the basis for all the TCP standards
      documents which followed, and, like many of its companion protocols,
      remains a "living" protocol which always being extended and updated,
      through new RFC documents, to meet new needs and circumstances.</para>

      <para>TCP sets up a virtual connection between two endpoints in a
      network. Data may be transmitted in either direction. TCP is almost
      always encapsulated in IP (Internet Protocol); for this reason you will
      often hear the term TCP/IP used. It allows bi-directional data
      transmission, no matter which endpoint originated the connection; it
      automatically detects and corrects data loss, and automatically adjusts
      the data transmission rate to accommodate network conditions. These
      features, along with the fact the standard is open, have made TCP the
      most widely-used data transmission protocol, and today it is used for
      the World Wide Web, e-mail, peer-to-peer file sharing, and other popular
      network services.</para>

      <section id="tcp-allgemein">
        <title>General</title>

        <para>TCP is an end-to-end ("circuit-like"), full duplex (meaning it
        allows the transmission of data in both directions at the same time)
        connection. Alternatively, connections may be assembled as two,
        half-duplex connections in which information may travel in both
        directions, albeit not at the same time; data may be returned for the
        purpose of connection management. Connection management itself is
        handled by the TCP protocol stack, software which is typically
        attached to, or forms part of, the core of the operating system. In
        the case of Linux, the TCP stack is in the kernel itself; this stack
        is accessed by network software such as e-mail clients, web browsers
        and servers.</para>

        <para>Each TCP connection consists of two endpoints, with each
        endpoint establishing a pair of identifying characteristics: namely,
        the unique IP address of the endpoint, and the port. This pair forms a
        software interface that allows bi-directional data transfer, and is
        sometimes called a "socket". The computers participating in the
        connection are identified by their IP addresses, while the particular
        connection is identified by the port number. As a result, it is
        possible for a web server, for example, to have multiple connections
        to a remote endpoint from its port 80; it keeps track of these
        multiple connections because each connection uses a different port on
        the remote endpoint.</para>

        <para>Ports are 16 bit numbers, and so range from 0 to 65535. The
        ports from 0 to 1023 are reserved and assigned by IANA<footnote>
            <para>Internet Assigned Numbers Authority. See <citetitle><ulink
            url="???">http://www.iana.org</ulink></citetitle>.</para>
          </footnote></para>

        <para> for specific applications. For example, web traffic, which uses
        HTTP, travels over the port reserved for HTTP traffic, port 80. The
        use of particular ports is not binding; an administrator may operate
        an FTP server on a port other than 21. For publicly-accessible
        services, however, client software will expect to find its specific
        service on the IANA-specified port, and special, private services are
        usually operated on unassigned ports above 1024.</para>
      </section>

      <section id="tcp-verbindungsaufbau">
        <title>Connection setup and teardown</title>

        <para>A web server publishing a service to the outside world sets up a
        socket consisting of its IP address and a port, and waits for clients
        to initiate connections to this socket. A socket in this state is said
        to be "listening", and indeed a display of the active sockets
        (typically through a command such as <command>netstat -an</command>)
        will show some in the LISTEN state. If a client wants to connect, it
        sets up a socket of its own with its IP address and a
        randomly-selected, unused port number, and uses this socket to connect
        to the listening socket on the server. Once the connection is
        established, the roles of client and server are indistinguishable and
        basically symmetrical. Either side may terminate the connection (when
        done gracefully, this is sometimes called "teardown.") Data may still
        be transferred by the opposite endpoint while the connection is being
        torn down.</para>
      </section>

      <section id="tcp-drei-wege-handshake">
        <title>The Three-Way Handshake</title>

        <para>The three-way handshake is the manner by which two TCP endpoints
        establish and maintain a connection so as to minimize data
        loss.</para>

        <section id="tcp-verbindungsaufbau">
          <title>Connection setup</title>

          <para>The device which wants to set up a connection sends the remote
          device a TCP SYN (synchronize) packet with a sequence number
          <replaceable>x</replaceable>. Sequence numbers are used to set the
          correct order for packets, ensure that no packets are missing, and
          check for duplicates when the packet stream is reassembled at the
          remote device.</para>

          <para>The type of packet (SYN) and the sequence number are set in
          the TCP header and the sequence number is selected randomly (how
          this is done depends on the TCP implementation). </para>

          <para></para>

          <para>Beim Aufbau einer TCP-Verbindung kommt der sogenannte
          Drei-Wege-Handshake zum Einsatz. Der Rechner, der die Verbindung
          aufbauen will, sendet dem anderen ein SYN-Paket (von engl.
          synchronize) mit einer Sequenznummer x. Die Sequenznummern sind
          dabei für die Sicherstellung einer vollständigen Übertragung in der
          richtigen Reihenfolge und ohne Duplikate wichtig. Es handelt sich
          also um ein Paket, dessen SYN-Bit im Paketkopf gesetzt ist (siehe
          TCP-Header). Die Start-Sequenznummer ist eine beliebige Zahl, deren
          Generierung von der jeweiligen TCP-Implementierung abhängig ist. Sie
          sollte jedoch möglichst zufällig sein, um Sicherheitsrisiken zu
          vermeiden. Die Gegenstelle (siehe Skizze) empfängt das Paket und
          sendet in einem eigenen SYN-Paket im Gegenzug ihre
          Start-Sequenznummer y (die ebenfalls beliebig und unabhängig von der
          Start-Sequenznummer der Gegenstelle ist). Zugleich bestätigt sie den
          Erhalt des ersten SYN-Pakets, indem sie die Sequenznummer x um eins
          erhöht und im ACK-Teil (von engl. acknowledgment = Bestätigung) des
          Headers zurückschickt. Der Client bestätigt zuletzt den Erhalt des
          SYN/ACK-Pakets durch das Senden eines eigenen ACK-Pakets mit der
          Sequenznummer y+1. Dieser Vorgang wird auch als Forward
          Acknowledgement bezeichnet. Außerdem sendet der Client den Wert x+1
          aus Sicherheitsgründen ebenso zurück. Dieses ACK-Segment erhält der
          Server, das ACK-Segment ist durch das gesetzte ACK-Flag
          gekennzeichnet. Die Verbindung ist damit aufgebaut.</para>
        </section>

        <section id="tcp-verbindungsabbau">
          <title>Verbindungsabbau</title>

          <para>Der geregelte Verbindungsabbau erfolgt ähnlich. Statt des
          SYN-Bits kommt das FIN-Bit (von engl. finish = Ende, Abschluss) zum
          Einsatz, welches anzeigt, dass keine Daten mehr vom Sender kommen.
          Der Erhalt des Pakets wird wiederum mittels ACK bestätigt. Der
          Empfänger des FIN-Pakets sendet zuletzt seinerseits ein FIN-Paket,
          das ihm ebenfalls bestätigt wird. Obwohl eigentlich vier Wege
          genutzt werden, handelt es sich beim Verbindungsabbau auch um einen
          Drei-Wege-Handshake, da die ACK- und FIN-Operationen vom Server zum
          Client als ein Weg gewertet werden. Zudem ist ein verkürztes
          Verfahren möglich, bei dem FIN und ACK genau wie beim
          Verbindungsaufbau im selben Paket untergebracht werden. Die maximum
          segment lifetime (MSL) ist die maximale Zeit, die ein Segment im
          Netzwerk verbringen kann, bevor es verworfen wird. Nach dem Senden
          des letzten ACKs wechselt der Client in einen zwei MSL andauernden
          Wartezustand (Waitstate), in dem alle verspäteten Segmente verworfen
          werden. Dadurch wird sichergestellt, dass keine verspäteten Segmente
          als Teil einer neuen Verbindung fehlinterpretiert werden. Außerdem
          wird eine korrekte Verbindungsterminierung sichergestellt. Geht ACK
          y+1 verloren, läuft beim Server der Timer ab, und das LAST_ACK
          Segment wird erneut übertragen.</para>
        </section>
      </section>

      <section id="tcp-header">
        <title>Aufbau des TCP-Headers</title>

        <para>Das TCP-Segment besteht immer aus zwei Teilen - dem Header und
        der Nutzlast (Payload). Die Nutzlast enthält die zu übertragenden
        Daten, die wiederum Protokollinformationen der Anwendungsschicht wie
        HTTP oder FTP entsprechen können. Der Header enthält für die
        Kommunikation erforderliche Daten sowie das Dateiformat beschreibende
        Information. Die Werte werden in network byte order (big endian)
        angegeben.</para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/tcp_header.png" />
          </imageobject>

          <imageobject role="html">
            <imagedata fileref="images/tcp_header.html.jpg" />
          </imageobject>
        </mediaobject>
      </section>

      <section id="tcp-datenuebertragung">
        <title>Datenübertragung</title>

        <section id="tcp-ip-paket-groesse">
          <title>TCP- / IP-Paket-Größe</title>

          <para>Ein TCP-Segment hat typischerweise eine Größe von 1500 Bytes.
          Es darf nur so groß sein, dass es in die darunterliegende
          Übertragungsschicht passt, das Internetprotokoll IP. Das IP-Paket
          ist theoretisch bis 65535 Bytes (64 Kilobyte) spezifiziert, wird
          aber selbst meist über Ethernet übertragen, und dort ist die
          Rahmengröße auf 1500 Bytes festgelegt. TCP und IP Protokoll
          definieren jeweils einen Header von 20 Bytes Größe. Für die
          Nutzdaten bleiben in einem TCP/IP-Paket also 1460 Bytes übrig. Da
          die meisten Internet-Anschlüsse DSL verwenden, gibt es dort noch das
          Point-to-Point Protocol (PPP) zwischen IP und Ethernet, was nochmal
          8 Bytes für den PPP-Rahmen kostet. Dem TCP/IP-Paket verbleiben im
          Ethernet-Rahmen nur 1492 Bytes MTU, die Nutzdaten reduzieren sich
          auf insgesamt 1452 Bytes MSS. Dies entspricht einer Auslastung von
          96,8 %.</para>
        </section>

        <section id="tcp-aufteilen-der-daten">
          <title>Aufteilen der Anwendungsdaten auf TCP- / IP-Pakete</title>

          <para>Empfänger und Sender einigen sich vor dem Datenaustausch über
          das Options-Feld auf die Größe der MSS. Die Anwendung, die Daten
          versenden möchte, beispielsweise ein Webserver, legt zum Beispiel
          einen 10 Kilobyte großen Datenblock im Puffer ab. Um so mit einem
          1460 Byte großen Nutzdatenfeld 10 Kilobyte Daten zu versenden, teilt
          man die Daten auf mehrere Pakete auf, fügt einen TCP-Header hinzu
          und versendet die TCP-Segmente. Dieser Vorgang wird Segmentierung
          genannt. Im Puffer ist der Datenblock, dieser wird in fünf Segmente
          aufgeteilt. Jedes Segment erhält durch die TCP-Software einen
          TCP-Header. Drei TCP-Segmente wurden aktuell abgeschickt. Diese sind
          nicht notwendigerweise sortiert, da im Internet jedes TCP-Segment
          einen anderen Weg nehmen und es dadurch zu Verzögerungen kommen
          kann. Damit die TCP-Software im Empfänger die Segmente wieder
          sortieren kann, ist jedes Segment nummeriert (die Segmente werden
          sozusagen durchgezählt). Bei der Zuordnung der Segmente wird die
          Sequenznummer herangezogen. Der Empfänger muss diejenigen
          TCP-Segmente bestätigen, die einwandfrei (Prüfsumme ist in Ordnung)
          angekommen sind.</para>
        </section>
      </section>

      <section id="tcp-flusssteuerung">
        <title>Flusssteuerung</title>

        <para>Da die Anwendung Daten aus dem Puffer liest, ändert sich der
        Füllstand des Puffers ständig. Deshalb ist es notwendig, den
        Datenfluss dem Füllstand entsprechend zu steuern. Dies geschieht mit
        dem Sliding Window und dessen Größe. Die Größe dieser Windows wird
        ständig angepasst und der Process der Anpassung ist ein nicht zu
        unterschätzender Overhead in der Kommunikation von Sender und
        Empfänger.</para>
      </section>

      <section id="tcp-slow-start">
        <title>Slow-Start</title>

        <para>Zu Beginn einer Datenübertragung dient der
        Slow-Start-Algorithmus zur Bestimmung des congestion window (wörtlich:
        Überlast-Zeitfenster), um einer möglichen Überlastsituation
        vorzubeugen. Man möchte Staus vermeiden, und da die momentane
        Auslastung des Netzes nicht bekannt ist, wird mit zunächst kleinen
        Datenmengen begonnen. Der Algorithmus startet mit einem kleinen
        Zeitfenster von zwei MSS, in dem Datenpakete vom Sender zum Empfänger
        übertragen werden. Der Empfänger sendet nun eine Bestätigung
        (Acknowledgement, ACK) an den Sender zurück. Anschließend wird die
        Größe des congestion window um eine Segmentgröße erhöht. Für jede
        weitere Bestätigung wird dieses wieder um eine Segmentgröße erhöht,
        das Limit ist das vom Empfänger festgelegte Empfangsfenster. Das
        Wachstum des Fensters ist in der Regel exponentiell, also erst
        langsam, dann schnell; insofern kann der historisch bedingte Name
        Slow-Start fälschlicherweise ein langsames Wachstum
        suggerieren.</para>
      </section>

      <section id="tcp-ueberlastkontrolle">
        <title>Überlastkontrolle</title>

        <para>Gehen bei einer bestimmten Fenstergröße Pakete verloren, kann
        das festgestellt werden, wenn der Sender innerhalb einer bestimmten
        Zeit (Timeout) keine Bestätigung (ACK) erhält. Man muss davon
        ausgehen, dass das Paket aufgrund zu hoher Netzlast von einem Router
        im Netz verworfen wurde. Das heißt, der Puffer eines Routers ist
        vollgelaufen; es handelt sich hier sozusagen um einen Stau im Netz. Um
        diesen aufzulösen, müssen alle beteiligten Sender ihre Netzlast
        reduzieren. Wird ein Paketverlust festgestellt, so wählt man die
        Hälfte der noch unbestätigten Daten im Netz als geeignetes Zeitfenster
        für die Datenübertragung zwischen diesem Sender und diesem Empfänger
        über den benutzten Kanal. Das verlorene Paket wird erneut übertragen,
        für jede Bestätigung wird die Sendefenstergröße wieder um eine MSS
        erhöht wie beim Slow-Start. Fast-Retransmit und Fast-Recovery werden
        eingesetzt, um nach einem Paketverlust schneller auf die
        Stau-Situation zu reagieren. Dazu informiert ein Empfänger den Sender,
        wenn Pakete außer der Reihe ankommen und somit dazwischen ein
        Paketverlust vorliegt. Hierfür bestätigt der Empfänger das letzte
        korrekte Paket erneut für jedes weitere ankommende Paket außer der
        Reihe. Man spricht dabei von Dup-Acks (Duplicate acknowledgements).
        Der Sender bemerkt die duplizierten Bestätigungen, und nach dem
        dritten Duplikat sendet er sofort, vor Ablauf des Timers, das
        verlorene Paket erneut. Weil nicht auf den Ablauf des Timers gewartet
        werden muss, heißt das Prinzip Fast Retransmit. Die Dup-Acks sind auch
        Hinweise darauf, dass zwar ein Paketverlust stattfand, aber doch die
        folgenden Pakete angekommen sind. Deshalb wird das Sendefenster nach
        dem Fehler nur halbiert und nicht wie beim Timeout wieder mit
        Slow-Start begonnen. Zusätzlich kann das Sendefenster noch um die
        Anzahl der Dup-Acks erhöht werden, denn jedes steht für ein weiteres
        Paket, welches den Empfänger erreicht hat, wenn auch außer der Reihe.
        Da dadurch nach dem Fehler schneller wieder die volle Sendeleistung
        erreicht wird, nennt man das Prinzip Fast-Recovery (schnelles
        Erholen). Bis zum Erkennen des Paketverlustes wurden noch weitere
        Pakete bis zur Sendefenstergröße übertragen. Der Empfänger konnte
        diese nicht nutzen, weil ein Paket der Serie verloren ging, aber er
        kann sie im Puffer halten. Nach der Neuübertragung des verlorenen
        Pakets durch den Sender bestätigt der Empfänger mittels ACK und einer
        höheren Sequenznummer die nun vollständige Paketfolge. Das erspart dem
        Sender, alle nach dem Paketverlust übertragenen Pakete erneut zu
        übertragen, und er kann sofort mit ganz neuen Paketen fortfahren; man
        nennt das kumuliertes ACK. Selective ACKs werden genutzt, um noch mehr
        Kontrollinformationen über den Datenfluss vom Empfänger an den Sender
        zurückzuschicken. Dabei wird nach einem Paketverlust vom Empfänger im
        TCP-Optionsfeld ein zusätzlicher Header eingefügt, aus welchem der
        Sender genau ersehen kann, welche Pakete bereits angekommen sind und
        welche fehlen (im Gegensatz zu den standardmäßigen kumulativen ACKs
        von TCP). Als bestätigt gelten die Pakete auch weiterhin erst dann,
        wenn der Empfänger dem Sender ein ACK für die Pakete übermittelt
        hat.</para>
      </section>

      <section id="tcp-datenintegritaet">
        <title>Datenintegrität und Zuverlässigkeit</title>

        <para>Im Gegensatz zum verbindungslosen UDP implementiert TCP einen
        bidirektionalen, byte-orientierten, zuverlässigen Datenstrom zwischen
        zwei Endpunkten. Das darunterliegende Protokoll (IP) ist
        paketorientiert, wobei Datenpakete verloren gehen können, in
        verkehrter Reihenfolge ankommen dürfen und sogar doppelt empfangen
        werden können. TCP wurde entwickelt, um mit der Unsicherheit der
        darunterliegenden Schichten umzugehen. Es prüft daher die Integrität
        der Daten mittels der Prüfsumme im Paketkopf und stellt die
        Reihenfolge durch Sequenznummern sicher. Der Sender wiederholt das
        Senden von Paketen, falls keine Bestätigung innerhalb einer bestimmten
        Zeitspanne (Timeout) eintrifft. Die Daten der Pakete werden beim
        Empfänger in einem Puffer in der richtigen Reihenfolge zu einem
        Datenstrom zusammengefügt und doppelte Pakete verworfen. Der
        Datentransfer kann selbstverständlich jederzeit nach dem Aufbau einer
        Verbindung gestört, verzögert oder ganz unterbrochen werden. Das
        Übertragungssystem läuft dann in einen Timeout. Der vorab getätigte
        Verbindungsaufbau stellt also keinerlei Gewähr für eine nachfolgende,
        dauerhaft gesicherte Übertragung dar.</para>
      </section>
    </section>

    <section id="udp">
      <title>User Datagram Protocol (UDP)</title>

      <para>Das User Datagram Protocol (Abk. UDP) ist ein minimales,
      verbindungsloses Netzprotokoll, das zur Transportschicht der
      Internetprotokollfamilie gehört. Aufgabe von UDP ist es, Daten, die über
      das Internet übertragen werden, der richtigen Anwendung zukommen zu
      lassen. Die Entwicklung von UDP begann 1977, als man für die Übertragung
      von Sprache ein einfacheres Protokoll benötigte als das bisherige
      verbindungsorientierte TCP. Es wurde ein Protokoll benötigt, das nur für
      die Adressierung zuständig war, ohne die Datenübertragung zu sichern, da
      dies zu Verzögerungen bei der Sprachübertragung führen würde.</para>

      <section id="udp-funktionsweise">
        <title>Funktionsweise</title>

        <para>Um die Daten, die mit UDP versendet werden, dem richtigen
        Programm auf dem Zielrechner zukommen zu lassen, werden bei UDP
        sogenannte Ports verwendet. Dazu wird bei UDP die Portnummer des
        Dienstes mitgesendet, der die Daten erhalten soll. Diese Erweiterung
        der Host-zu-Host- auf eine Prozess-zu-Prozess-Übertragung wird als
        Anwendungsmultiplexen und -demultiplexen bezeichnet.</para>
      </section>

      <section id="udp-eigenschaften">
        <title>Eigenschaften</title>

        <para>UDP stellt einen verbindungslosen, potentiell unzuverlässigen
        Übertragungsdienst bereit. Das bedeutet, dass es keine Garantie gibt,
        dass ein einmal gesendetes Paket auch ankommt oder dass Pakete in der
        gleichen Reihenfolge ankommen, in der sie gesendet wurden. Eine
        Anwendung, die UDP nutzt, muss daher gegenüber verloren gegangenen und
        umsortierten Paketen unempfindlich sein oder selbst entsprechende
        Korrekturmaßnahmen beinhalten. Da vor Übertragungsbeginn nicht erst
        eine Verbindung aufgebaut werden muss, können die Hosts schneller mit
        dem Datenaustausch beginnen. Dies fällt vor allem bei Anwendungen ins
        Gewicht, bei denen nur kleine Datenmengen ausgetauscht werden müssen.
        Einfache Frage-Antwort-Protokolle wie das Domain Name System verwenden
        UDP, um die Netzwerkbelastung gering zu halten und damit den
        Datendurchsatz zu erhöhen. Ein Drei-Wege-Handshake wie bei TCP für den
        Aufbau der Verbindung würde unnötigen Overhead erzeugen. Daneben
        bietet die ungesicherte Übertragung auch den Vorteil von geringen
        Übertragungsverzögerungsschwankungen: Geht bei einer TCP-Verbindung
        ein Paket verloren, so wird es automatisch erneut angefordert. Dies
        braucht Zeit, die Übertragungsdauer kann daher schwanken, was für
        Multimediaanwendungen schlecht ist. Bei VoIP z.B. würde es zu
        plötzlichen Aussetzern kommen bzw. die Wiedergabepuffer müssten größer
        angelegt werden. Bei verbindungslosen Kommunikationsdiensten bringen
        verloren gegangene Pakete dagegen nicht die gesamte Übertragung ins
        Stocken, sondern vermindern lediglich die Qualität. UDP übernimmt die
        Eigenschaften der darunterliegenden Netzwerkschicht. Im Falle des
        Internet Protocols IP können Datenpakete maximal 65535 Bytes lang
        sein, wovon der IP-Header und UDP-Header insgesamt mindestens 28 Bytes
        belegen. UDP-Datagramme haben daher maximal 65507 Nutzdatenbytes.
        Solche Pakete werden jedoch von IP fragmentiert übertragen, so dass
        UDP nur bei Datenpaketgrößen bis zu einigen Kilobytes sinnvoll ist. IP
        löscht Pakete etwa bei Übertragungsfehlern oder bei Überlast.
        Datagramme können daher fehlen. Das UDP-Protokoll bietet hierfür keine
        Erkennungs- oder Korrekturmechanismen wie etwa TCP. Im Falle von
        mehreren möglichen Routen zum Ziel kann IP bei Bedarf neue Wege
        wählen. Hierdurch ist es in seltenen Fällen sogar möglich, dass später
        gesendete Daten früher gesendete überholen.</para>
      </section>
    </section>
  </section>

  <section id="definition-channel">
    <title>Channels</title>

    <para>Ein Channel ist die Verbindung zwischen zwei Punkten (in unserem
    Fall sind das meistens menschliche Gesprächsteilnehmer). Es gibt folgende
    Channel-Arten:</para>

    <itemizedlist>
      <listitem>
        <para>Agent</para>

        <para>Ein ACD Agent-Channel</para>
      </listitem>

      <listitem>
        <para>CAPI</para>

        <para>Ein ISDN-Channel</para>
      </listitem>

      <listitem>
        <para>Console</para>

        <para>Ein Linux-Konsolen-Client-Treiber für Soundkarten, die mit OSS
        oder ALSA angesprochen werden können.</para>
      </listitem>

      <listitem>
        <para>H.323</para>

        <para>Ein VoIP-Protokoll</para>
      </listitem>

      <listitem>
        <para>IAX</para>

        <para>Ein VoIP-Protokoll<note>
            <para>Prinzipiel gibt es zwei Versionen von IAX (1 und 2). Wer
            heute von IAX spricht, meint eigentlich immer IAX2 (also die
            Version 2).</para>
          </note></para>
      </listitem>

      <listitem>
        <para>Local</para>

        <para>Ein Loopback in einen anderen Context</para>
      </listitem>

      <listitem>
        <para>MGCP</para>

        <para>Ein VoIP-Protokoll</para>
      </listitem>

      <listitem>
        <para>mISDN</para>

        <para>Ein ISDN-Channel</para>
      </listitem>

      <listitem>
        <para>NBS</para>

        <para>Network Broadcast Sound</para>
      </listitem>

      <listitem>
        <para>phone</para>

        <para>Linux Telephony Channel</para>
      </listitem>

      <listitem>
        <para>SIP</para>

        <para>Ein VoIP-Protokoll</para>
      </listitem>

      <listitem>
        <para>Skinny</para>

        <para>Ein VoIP-Protokoll</para>
      </listitem>

      <listitem>
        <para>vISDN</para>

        <para>Ein ISDN-Channel</para>
      </listitem>

      <listitem>
        <para>VOFR</para>

        <para>Voice over frame relay Adtran style</para>
      </listitem>

      <listitem>
        <para>VPB</para>

        <para>Verbindung von normalen Telefonanschlüssen mit
        Voicetronix-Karten</para>
      </listitem>

      <listitem>
        <para>Zap</para>

        <para>Verbindung von normalen Telefonanschlüssen mit Digium-Karten.
        Wird aber auch häufig für Karten anderer Hersteller benutzt.</para>
      </listitem>
    </itemizedlist>

    <para>In den meisten Beispielen in diesem Buch wird immer von
    SIP-Verbindungen ausgegangen. Der Grund dafür ist einfach: Zurzeit gibt es
    sehr viel mehr SIP- als z.B. IAX-fähige VoIP-Telefone. In diesem Kapitel
    werden diese zwei wichtigen Protokolle im Einzelnen beschrieben. Wer will,
    kann dieses Kapitel aber überspringen und bei konkreten Fragen zu
    bestimmten Parametern hier nachschlagen.</para>
  </section>

  <section id="peers-users-friends">
    <title>Peers, Users und Friends</title>

    <para>Die Unterscheidung der Begriffe Peer, User und Friend ist in der
    Asterisk-Dokumentation nicht immer leicht verständlich dargestellt und
    wird daher auch teilweise falsch auf manchen Webseiten wiedergegeben. Die
    folgende Tabelle zeigt die jeweiligen Funktionen:</para>

    <informaltable>
      <tgroup cols="3">
        <tbody>
          <row>
            <entry>Asterisk</entry>

            <entry>&lt;=</entry>

            <entry>User</entry>
          </row>

          <row>
            <entry>Asterisk</entry>

            <entry>=&gt;</entry>

            <entry>Peer</entry>
          </row>

          <row>
            <entry>Asterisk</entry>

            <entry>&lt;=&gt;</entry>

            <entry>Friend</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Ein Peer kann also nur angerufen werden, ein User nur anrufen und
    ein Friend kann beides.<tip>
        <para>In der Praxis wird meistens nur <parameter>Friend</parameter>
        benutzt. Entsprechend muss man sich diese Tabelle nicht einprägen,
        sondern kann sie im Spezialfall nachschlagen.</para>
      </tip></para>
  </section>

  <section id="iax-vs-sip">
    <title>IAX versus SIP</title>

    <para>Fast jeder Asterisk-Administrator muss sich irgendwann einmal die
    Frage stellen, ob er eher auf SIP oder eher auf IAX setzen soll. Die kurze
    Antwort: Wenn IAX möglich ist (also, wenn die Telefone es unterstützen),
    dann sollte IAX benutzt werden. Ansonsten immer SIP. Mark Spencer (der
    Erfinder von Asterisk) hat zu diesem Thema auf einer Asterisk-Mailingliste
    im Jahr 2004 eine ausführlichere Antwort geschrieben (die im Original
    englische E-Mail finden Sie im <xref
    linkend="anhang-iax-vs-sip" />):</para>

    <screen>Date: Mon, 5 Jul 2004 18:59:52 -0500 (CDT)
From: Mark Spencer &lt;markster@digium.com&gt;

Ich möchte einige Unterschiede zwischen SIP und IAX kurz 
zusammenfassen. Vielleicht hilft Dir das bei der 
Entscheidungsfindung.

1) IAX arbeitet während des Gesprächs unabhängig von der Anzahl 
der Anrufe und des verwendeten Codecs effizienter als RTP. Der 
Vorteil liegt irgendwo zwischen 2400 Kbit/s für einen 
Einzelanruf und der dreifachen Anzahl der Anrufe pro Megabit 
bei G.729, wenn die Messung bei aktiviertem Trunk-Modus auf der 
MAC-Ebene vorgenommen wird.

2) IAX ist nicht ASCII-, sondern datenelementkodiert. Dies macht
Implementierungen wesentlich leichter und zudem robuster 
gegenüber Pufferüberlaufangriffen, da absolut keine Textanalyse 
oder -interpretation erforderlich ist. IAX führt den gesamten 
IP-Stapel, IAX-Stapel, TDM-Schnittstelle, Echokompensation und 
Erzeugung der Anrufer-ID auf 4k Heap und Stack sowie 64k Flash 
aus. Dies veranschaulicht ganz klar die 
Implementierungseffizienz des Entwurfs. Die Größe der 
IAX-Signalpakete ist drastisch geringer als die bei SIP, was 
aber in der Regel nur dann erwähnenswert ist, wenn zahlreiche 
Clients sich häufig registrieren. Allgemein gesprochen ist IAX2 
bei der Kodierung, der Dekodierung und der Überprüfung der Daten 
effizienter. Zudem wäre es für den Autor einer 
IAX-Implementierung extrem schwierig, eine Inkompatibilität mit 
einer anderen Implementierung herzustellen, da für eine 
Interpretation kaum Raum vorhanden ist.

3) IAX weist eine sehr klare Trennung von Schicht 2 und Schicht 
3 auf, d.h. sowohl Signalisierung als auch Tondaten haben 
definierte Zustände, werden robust und in konsistenter Weise 
übertragen, und wenn ein Endpunkt des Anrufs unvermittelt 
verschwindet, dann wird der Anruf auch zeitnah beendet und zwar
auch dann, wenn keine weiteren Signale und/oder Audiodaten 
empfangen werden. Einen solchen Mechanismus weist SIP nicht auf; 
hinzu kommt, dass, was die Signalisierung angeht, die 
Zuverlässigkeit sehr niedrig und schwerfällig ist, weswegen 
zusätzlich zum Kernstandard RF3261 weitere Standards benötigt 
werden.

4) Die einheitlichen Signalisierungs- und Audiopfade von IAX 
gestatten die transparente Navigation von NATs, und der 
Firewall-Administrator muss lediglich einen einzigen Port 
öffnen, um den Einsatz von IAX zu gestatten. Der IAX-Client 
muss für einen korrekten Betrieb überhaupt nichts über das 
Netzwerk wissen, in dem er sich befindet. Anders gesagt: Es kann 
niemals eine durch eine Firewall bedingte Situation auftreten, 
in der IAX einen Anruf aufbauen und dann keine Audiodaten 
übertragen kann (natürlich vorausgesetzt, es ist genügend
Bandbreite vorhanden).

5) Das authentifizierte Übertragungssystem von IAX gestattet 
die Übertragung von Audio- und Rufsteuerdaten über einen 
zwischengeschalteten Server auf eine robuste Weise: Wenn zwei 
Endpunkte einander aus irgendeinem Grund nicht erkennen können, 
wird der Ruf über den Zentralserver gehalten.

6) IAX trennt die Caller-ID vom Authentifizierungsmechanismus 
des Benutzers. SIP verfügt hierzu über keine eindeutige Methode, 
sofern nicht Remote-Party-IDs verwendet werden.

7) SIP ist ein IETF-Standard. Zwar gibt es eine neue 
Dokumentation von Frank Miller, aber IAX ist gegenwärtig noch 
kein veröffentlichter Standard.

8) IAX ermöglicht es einem Endpunkt, die Gültigkeit einer 
Telefonnummer zu überprüfen, damit er weiß, ob die Nummer 
vollständig ist, vollständig sein könnte oder aber zwar 
vollständig ist, aber länger sein könnte. SIP bietet hierfür 
keine vollständige Unterstützung.

9) IAX sendet DTMF stets außerbandig, d.h. es kann keine 
Verwirrung bezüglich der Frage entstehen, welche Methode verwendet 
wird.

10) IAX unterstützt die Übertragung von Sprache und Context, was 
in einer Asterisk-Umgebung durchaus sinnvoll ist. Mehr fällt mir 
jetzt im Moment nicht ein.

Mark

PS: Ich nehme mal an, dass SIP trotzdem ein paar Vorteile 
aufweisen muss (andernfalls wären seine Entwickler ja Dummköpfe).

Es bleibt also zu fragen, wie IAX die folgenden Aspekte verwaltet:
1) Bandbreitenanzeige
2) Neue Codecs
3) Erweiterbarkeit
4) Parken von Verbindungen und andere komplexe Szenarien
5) Videotelephonie

Ich habe den Eindruck, dass dies alles in SIP besser geregelt ist.</screen>

    <para>Nachtrag zu dieser E-Mail: IAX ist mittlerweile ein offenes und gut
    dokumentiertes Protokoll.</para>
  </section>

  <xi:include href="sip.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="iax.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
</chapter>
