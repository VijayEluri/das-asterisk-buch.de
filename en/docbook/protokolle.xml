<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-protokolle" lang="de" revision="$Revision: 631 $">
  <!--% Copyright (c) 2006 - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
-->

  <!--% translated from the German by Stephen Bosch <sbosch@vodacomm.ca>-->

  <!--% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Protocols</title>

  <section id="protokolle-einleitung">
    <title>Introduction</title>

    <para>This chapter will cover the techniques by which we actually get
    voice data from one point to another. The session protocols for this
    purpose are really a kind of "grammar" that governs this transmission, and
    are in turn built upon the transport layer protocols that make up the
    TCP/IP protocol stack: namely TCP and UDP. You should have a fundamental
    understanding of these protocols when troubleshooting certain problems,
    which is why we are describing them in some detail here. This
    understanding is not strictly necessary to implement Asterisk but is
    nevertheless valuable. As such, this chapter is intended as a reference
    for the event it is needed.</para>
  </section>

  <section id="netzwerkprotokolle">
    <title>Network protocols</title>

    <para>We recommend you look at the Wikipedia articles describing the
    transport protocols, which cover them in considerably more depth.<footnote>
        <para>See <citetitle><ulink
        url="???">http://en.wikipedia.org/wiki/Transmission_Control_Protocol</ulink></citetitle>
        and <citetitle><ulink
        url="???">http://en.wikipedia.org/wiki/User_Datagram_Protocol</ulink></citetitle></para>
      </footnote></para>

    <para>For the impatient among you, here is a simple and brief definition:
    TCP is a protocol which ensures that all the information transmitted by
    the sender arrives at the receiver complete and in the correct order. This
    reliability is at the cost of relatively higher transmission overhead,
    which, during times of congestion, is more likely to lead to interruptions
    or delays in transmission. By contrast, its sister protocol UDP invests
    almost nothing in assuring that everything is received; instead, it merely
    sends out every packet as soon it is ready to be delivered without regard
    to whether it arrives intact or even in the right sequence.</para>

    <para>Both protocols are of importance in VoIP applications, because
    connections are established using TCP, whereas the voice data itself is
    transmitted using UDP. Particularly where audio data packets are
    concerned, quantity is indeed more important than quality.</para>

    <section id="tcp">
      <title>Transmission Control Protocol (TCP)</title>

      <para>The Transmission Control Protocol (TCP) is a protocol governing
      the transmission of data between computers. The operating systems of all
      modern computer understand and support TCP and use it to exchange data
      with other computers on a network. It is a reliable, connection-oriented
      transport protocol, and forms part of the Internet Protocol
      family.</para>

      <para>TCP was developed by Robert E. Kahn and Vinton G. Cerf, beginning
      initially as a research project in 1973 and culminating in the
      publication, in 1981, of the Internet standards document RFC<footnote>
          <para>"Request for Comments". These documents begin as simple
          proposals addressed to peers in the Internet engineering community
          and subject to revision; when a draft proposal has been accepted it
          is annotated and becomes part of the body of standards.</para>
        </footnote> 793, which forms the basis for all the TCP standards
      documents which followed, and, like many of its companion protocols,
      remains a "living" protocol which always being extended and updated,
      through new RFC documents, to meet new needs and circumstances.</para>

      <para>TCP sets up a virtual connection between two endpoints in a
      network. Data may be transmitted in either direction. TCP is almost
      always encapsulated in IP (Internet Protocol); for this reason you will
      often hear the term TCP/IP used. It allows bi-directional data
      transmission, no matter which endpoint originated the connection; it
      automatically detects and corrects data loss, and automatically adjusts
      the data transmission rate to accommodate network conditions. These
      features, along with the fact the standard is open, have made TCP the
      most widely-used data transmission protocol, and today it is used for
      the World Wide Web, e-mail, peer-to-peer file sharing, and other popular
      network services.</para>

      <section id="tcp-allgemein">
        <title>General</title>

        <para>TCP is an end-to-end ("circuit-like"), full duplex (meaning it
        allows the transmission of data in both directions at the same time)
        connection. Alternatively, connections may be assembled as two,
        half-duplex connections in which information may travel in both
        directions, albeit not at the same time; data may be returned for the
        purpose of connection management. Connection management itself is
        handled by the TCP protocol stack, software which is typically
        attached to, or forms part of, the core of the operating system. In
        the case of Linux, the TCP stack is in the kernel itself; this stack
        is accessed by network software such as e-mail clients, web browsers
        and servers.</para>

        <para>Each TCP connection consists of two endpoints, with each
        endpoint establishing a pair of identifying characteristics: namely,
        the unique IP address of the endpoint, and the port. This pair forms a
        software interface that allows bi-directional data transfer, and is
        sometimes called a "socket". The computers participating in the
        connection are identified by their IP addresses, while the particular
        connection is identified by the port number. As a result, it is
        possible for a web server, for example, to have multiple connections
        to a remote endpoint from its port 80; it keeps track of these
        multiple connections because each connection uses a different port on
        the remote endpoint.</para>

        <para>Ports are 16 bit numbers, and so range from 0 to 65535. The
        ports from 0 to 1023 are reserved and assigned by IANA<footnote>
            <para>Internet Assigned Numbers Authority. See <citetitle><ulink
            url="???">http://www.iana.org</ulink></citetitle>.</para>
          </footnote></para>

        <para> for specific applications. For example, web traffic, which uses
        HTTP, travels over the port reserved for HTTP traffic, port 80. The
        use of particular ports is not binding; an administrator may operate
        an FTP server on a port other than 21. For publicly-accessible
        services, however, client software will expect to find its specific
        service on the IANA-specified port, and special, private services are
        usually operated on unassigned ports above 1024.</para>
      </section>

      <section id="tcp-verbindungsaufbau">
        <title>Connection setup and teardown</title>

        <para>A web server publishing a service to the outside world sets up a
        socket consisting of its IP address and a port, and waits for clients
        to initiate connections to this socket. A socket in this state is said
        to be "listening", and indeed a display of the active sockets
        (typically through a command such as <command>netstat -an</command>)
        will show some in the LISTEN state. If a client wants to connect, it
        sets up a socket of its own with its IP address and a
        randomly-selected, unused port number, and uses this socket to connect
        to the listening socket on the server. Once the connection is
        established, the roles of client and server are indistinguishable and
        basically symmetrical. Either side may terminate the connection (when
        done gracefully, this is sometimes called "teardown.") Data may still
        be transferred by the opposite endpoint while the connection is being
        torn down.</para>
      </section>

      <section id="tcp-drei-wege-handshake">
        <title>The Three-Way Handshake</title>

        <para>The three-way handshake is the manner by which two TCP endpoints
        establish and maintain a connection so as to minimize data
        loss.</para>

        <section id="tcp-verbindungsaufbau">
          <title>Connection setup</title>

          <para>The client intitiating a connection sends the server a TCP SYN
          (synchronize, identified with the SYN flag bit set to 1) packet with
          a sequence number <replaceable>x</replaceable>. Sequence numbers are
          used to set the correct order for packets, ensure that no packets
          are missing, and check for duplicates when the packet stream is
          reassembled at the server.</para>

          <para>The type of packet (SYN) and the sequence number are set in
          the TCP header and the sequence number is selected randomly (how
          this is done depends on the TCP implementation). The server replies
          with a SYN/ACK (synchronize-acknowledge, identified with both SYN
          and ACK flags set to 1) packet having a (similarly randomly
          selected) sequence number <replaceable>y</replaceable>. At the same
          time it increments the sequence number of the initiating SYN packet
          by one (<replaceable>x</replaceable> + 1) and places this number in
          the acknowledgement field of the packet's TCP header.</para>

          <para>Finally, the client completes the handshake by replying to the
          SYN/ACK with an ACK packet of its own, incrementing the sequence
          number by one (<replaceable>y</replaceable> + 1). This process is
          also called "forward acknowledgement". For extra security, the
          client also wraps the received <replaceable>x</replaceable> + 1
          sequence number in this ACK reply. If all goes well, the connection
          is established.</para>
        </section>

        <section id="tcp-verbindungsabbau">
          <title>Connection teardown</title>

          <para>Graceful teardown follows a similar process. Instead of
          packets with SYN flag bits set, the FIN (finish) flag bit is set.
          This indicates to the receiver that the sender will not be
          transmitting any further data. This is acknowledged with an ACK
          packet. The recipient of the initial FIN packet then responds with
          an ACK packet of its own, which is likewise acknowledged. Though
          four packets are exchanged, this is still treated as a three-way
          handshake, since the FIN-ACK combination from the server to the
          client is considered a "one-way" operation (the FIN and ACK message
          can also be contained in a single packet).</para>

          <para>The maximum segment lifetime (MSL) is the maximum time that a
          TCP segment may exist in the network before it is discarded
          (normally 2 minutes). After the transmission of the last ACK, the
          client enters a wait state equal to two MSL periods; during this
          time all late-arriving segments are discarded. This is to ensure
          that no late-arriving segments are misinterpreted as the initiation
          of new connections. This also ensures that the connection is indeed
          closed gracefully; if the ACK <replaceable>y</replaceable> + 1 goes
          missing, a wait timer on the server expires and the LAST_ACK segment
          is retransmitted.</para>
        </section>
      </section>

      <section id="tcp-header">
        <title>TCP header structure</title>

        <para>A TCP segment consists of two parts: the header, containing the
        transmission information such as port and sequence number, and the
        payload, which is the real information we want to send, which usually
        includes application layer protocol information (such as HTTP or SSH).
        The values are transmitted in network (big endian) byte order.</para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/tcp_header.png" />
          </imageobject>

          <imageobject role="html">
            <imagedata fileref="images/tcp_header.html.jpg" />
          </imageobject>
        </mediaobject>
      </section>

      <section id="tcp-datenuebertragung">
        <title>Data transmission</title>

        <section id="tcp-ip-paket-groesse">
          <title>TCP/IP packet size</title>

          <para>A TCP segment is typically no larger than 1500 bytes. It must
          be small enough to fit in the protocol data unit<footnote>
              <para>"Protocol Data Unit" is a term used to refer to the unit
              of transmission corresponding to a given network layer. In the
              session layer, the PDU is called a segment ("TCP segment"); in
              the network layer, it is a packet ("IP packet"); in the link
              layer, it is a frame ("Ethernet frame").</para>
            </footnote> of the protocol layer immediately beneath it in the
          stack, in this case, IP. An IP packet may be as large as 64
          kilobytes, but because IP is practically always transmitted over
          Ethernet, most IP packets are smaller than the maximum Ethernet
          frame size of 1500 bytes. Both TCP and IP specify a header of 20
          bytes, respectively, so the payload is limited to 1460 bytes. Some
          connections (particularly some forms of DSL service) use PPP
          (Point-to-Point Protocol), which requires an additional 8 bytes of
          header information, meaning that the TCP/IP packet can be a maximum
          of 1492 bytes, leaving a maximum segment size (or MSS) of 1452
          bytes. This corresponds to about 3.2% overhead.</para>
        </section>

        <section id="tcp-aufteilen-der-daten">
          <title>Distribution of application data across TCP/IP
          packets</title>

          <para>The sender and receiver negotiate the maximum segment size
          before data transmission begins, using the options field in the TCP
          header. The application wanting to send data (for example, a web
          server) places a data block of 10 kilobytes in the transmit buffer.
          To send this 10 kB data block, it is divided into multiple packets,
          each with its own TCP header, and transmitted as TCP segments, a
          process called segmentation.</para>

          <para>Segments usually leave in sequential order, though this is not
          strictly necessary, since the sequence numbering allows the receiver
          to re-assemble them in the correct order. Received segments are
          checked for integrity by calculating a checksum. If it is correct,
          the packet is acknowledged. If it is incorrect, the acknowledgement
          is withheld and the sender retransmits the packet.</para>
        </section>
      </section>

      <section id="tcp-datenintegritaet">
        <title>Data integrity and reliability</title>

        <para>TCP allows a bi-directional, byte-oriented, reliable data stream
        between two endpoints. The underlying network layer protocol (IP) is
        packet-switched, and packets can get lost, mangled, or arrive in the
        wrong order. TCP was designed to deal with these inherent
        uncertainties, and so it verifies data integrity using a checksum
        provided in the packet header, establishes the correct packet order
        using sequence numbers, and discards duplicate packets. The sender
        retransmits packets that are not acknowledged within a certain time.
        The received packets are assembled in the correct order in the receive
        buffer to form a data stream which is passed to the appropriate
        application.</para>

        <para>Of course, the data transfer can be interrupted, corrupted or
        terminated at any time. The connection will expire after a timeout has
        been exceeded. The successful establishment of a connection does not
        guarantee that a lasting and reliable transfer will follow.</para>
      </section>
    </section>

    <section id="udp">
      <title>User Datagram Protocol (UDP)</title>

      <para>In contrast to TCP, the User Datagram Protocol (UDP) is a minimal,
      connectionless session layer protocol. Development of UDP began in 1977,
      after the limits of TCP for the transmission of time-sensitive data
      became apparent. A protocol which handled only addressing was needed,
      without the overhead that went with guaranteed delivery.</para>

      <section id="udp-funktionsweise">
        <title>Operation</title>

        <para>To ensure that data sent via UDP reaches the appropriate
        application, source and destination ports are specified in the UDP
        header. This process-to-process communication is called application
        <emphasis>multiplexing</emphasis> and
        <emphasis>de-multiplexing</emphasis> (sometimes muxing and
        demuxing).</para>
      </section>

      <section id="udp-eigenschaften">
        <title>Characteristics</title>

        <para>UDP establishes a connectionless, potentially unreliable
        transfer service. This means that neither transmission nor order of
        reception are guaranteed; that is, UDP sends data on a "best effort"
        basis. Applications which use UDP must take these characteristics into
        account and implement data correction where it is appropriate and
        necessary. Because no connection setup is required prior to data
        transmission (as is the case with TCP), the endpoints can begin
        exchanging data more quickly. This relatively low overhead makes UDP
        particularly useful for applications which exchange only small amounts
        of data, such as Domain Name System (DNS).</para>

        <para>In addition, the absence of handshaking means that there is less
        variation in latency, or jitter. If a packet is lost in a TCP
        transaction, precious time is needed while the recipient waits for the
        sender to retransmit it, and the momentary latency can increase
        dramatically. This is important for multimedia applications which are
        sensitive to delay. In VoIP applications, these kinds of delays lead
        to sound artifacts and dropouts.</para>

        <para>Connectionless protocols like UDP do not stop the flow of data
        if packets go missing. It is up to the receiving end to make sense of
        the gaps in the data stream when packets are lost, and most do this by
        momentarily reducing the resolution or quality of the resulting audio
        or video.</para>

        <para>UDP, like TCP, is constrained by the protocol data unit size of
        the underlying network stack layers. IP packets cannot be larger than
        65535 bytes, of which the IP and UDP headers consume at least 28
        bytes, leaving a maximum of 65507 bytes for the actual payload. Such
        datagrams are usually fragmented in IP. In practice, UDP packets are
        rarely more than a few kilobytes in size. IP will discard packets in
        the case of transmission error or overflow, so datagrams can go
        missing.</para>
      </section>
    </section>
  </section>

  <section id="definition-channel">
    <title>Channels</title>

    <para>In Asterisk, a channel is the connection between two endpoints
    (usually human beings in conversation). The following channel types
    exist:</para>

    <itemizedlist>
      <listitem>
        <para>Agent</para>

        <para>An automatic call distribution (ACD) Agent channel</para>
      </listitem>

      <listitem>
        <para>CAPI</para>

        <para>An ISDN channel</para>
      </listitem>

      <listitem>
        <para>Console</para>

        <para>A Linux console channel driver for sound cards which can be
        manipulated through OSS and ALSA.</para>
      </listitem>

      <listitem>
        <para>H.323</para>

        <para>A VoIP protocol.</para>
      </listitem>

      <listitem>
        <para>IAX</para>

        <para>A VoIP protocol.<note>
            <para>In principle, there are two versions of IAX (1 and 2).
            Today, anyone referring to IAX is almost certainly speaking about
            IAX2 (in other words, IAX version 2).</para>
          </note></para>
      </listitem>

      <listitem>
        <para>Local</para>

        <para>A loopback into another context.</para>
      </listitem>

      <listitem>
        <para>MGCP</para>

        <para>A VoIP protocol.</para>
      </listitem>

      <listitem>
        <para>mISDN</para>

        <para>An ISDN channel.</para>
      </listitem>

      <listitem>
        <para>NBS</para>

        <para>Network Broadcast Sound</para>
      </listitem>

      <listitem>
        <para>phone</para>

        <para>Linux Telephony channel</para>
      </listitem>

      <listitem>
        <para>SIP</para>

        <para>A VoIP protocol.</para>
      </listitem>

      <listitem>
        <para>Skinny</para>

        <para>A VoIP protocol (also called SCCP, or Skinny Client Control
        Protocol).</para>
      </listitem>

      <listitem>
        <para>vISDN</para>

        <para>An ISDN channel.</para>
      </listitem>

      <listitem>
        <para>VOFR</para>

        <para>Voice over frame relay Adtran style</para>
      </listitem>

      <listitem>
        <para>VPB</para>

        <para>Voicetronix hardware channel driver for PSTN connections.</para>
      </listitem>

      <listitem>
        <para>Zap</para>

        <para>Digium hardware channel driver for PSTN connections; also used
        for hardware from competing manufacturers.</para>
      </listitem>
    </itemizedlist>

    <para>Most examples in this book assume SIP connections. The reason for
    this is simple -- at the moment, there are more SIP-capable VoIP
    telephones than telephones for any other VoIP protocol. The other
    significant VoIP protocol for Asterisk is IAX. This chapter will cover
    these two important protocols in some further detail, but may also be used
    as parameter reference for configuration.</para>
  </section>

  <section id="peers-users-friends">
    <title>Peers, Users and Friends</title>

    <para>The distinction between the Asterisk classifications "peer", "user"
    and "friend" is not always clear in the Asterisk documentation;
    consequently there are some incorrect websites. The following table
    describes the functions of each host type:</para>

    <informaltable>
      <tgroup cols="3">
        <tbody>
          <row>
            <entry>Asterisk</entry>

            <entry>&lt;=</entry>

            <entry>User</entry>
          </row>

          <row>
            <entry>Asterisk</entry>

            <entry>=&gt;</entry>

            <entry>Peer</entry>
          </row>

          <row>
            <entry>Asterisk</entry>

            <entry>&lt;=&gt;</entry>

            <entry>Friend</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>A peer can only be called, a user can only make calls, and a friend
    can do both.<tip>
        <para>In practice, <parameter>friend</parameter> is used the most. As
        such, you needn't memorize this table, but it is always here if you
        need to refer to it later.</para>
      </tip></para>
  </section>

  <section id="iax-vs-sip">
    <title>IAX versus SIP</title>

    <para>Every Asterisk administrator is eventually faced with the question
    of whether to build primarily on SIP or IAX. If IAX is available and
    possible (that is, the sets support it), then IAX should be used;
    otherwise, you should use SIP. Mark Spencer, the inventor of Asterisk,
    wrote an e-mail to the Asterisk users mailing list in 2004 that attempts
    to address the question:</para>

    <screen>Date: Mon, 5 Jul 2004 18:59:52 -0500 (CDT)
From: Mark Spencer &lt;markster@digium.com&gt;

Let me summarize some differences between SIP and IAX, and it might help you
make a decision about what is best for you.

1) IAX is more efficient on the wire than RTP for any number of calls,
any codec. The benefit is anywhere from 2.4k for a single call to
approximately tripling the number of calls per megabit for G.729 when
measured to the MAC level when running trunk mode.

2) IAX is information-element encoded rather than ASCII encoded. This
makes implementations substantially simpler and more robust to buffer
overrun attacks since absolutely no text parsing or interpretation is
required. The IAXy runs its entire IP stack, IAX stack, TDM interface,
echo canceler, and callerid generation in 4k of heap and stack and 64k of
flash. Clearly this demonstrates the implementation efficiency of its
design. The size of IAX signaling packets is phenomenally smaller than
those of SIP, but that is generally not a concern except with large
numbers of clients frequently registering. Generally speaking, IAX2 is
more efficient in its encoding, decoding and verifying information, and it
would be extremely difficult for an author of an IAX implementation to
somehow be incompatible with another implementation since so little is
left to interpretation.

3) IAX has a very clear layer2 and layer3 separation, meaning that both
signaling and audio have defined states, are robustly transmitted in a
consistent fashion, and that when one end of the call abruptly disappears,
the call WILL terminate in a timely fashion, even if no more signaling
and/or audio is received. SIP does not have such a mechanism, and its
reliability from a signaling perspective is obviously very poor and
clumsy requiring additional standards beyond the core RF3261.

4) IAX's unified signaling and audio paths permit it to transparently
navigate NAT's and provide a firewall administrator only a *single* port to
have to open to permit its use. It requires an IAX client to know
absolutely nothing about the network that it is on to operate. More
clearly stated, there is *never* a situation that can be created with a
firewall in which IAX can complete a call and not be able to pass audio
(except of course if there was insufficient bandwidth).

5) IAX's authenticated transfer system allows you to transfer audio and
call control off a server-in-the-middle in a robust fashion such that if
the two endpoints cannot see one another for any reason, the call
continues through the central server.

6) IAX clearly separates Caller*ID from the authentication mechanism of
the user. SIP does not have a clear method to do this unless
Remote-Party-ID is used.

7) SIP is an IETF standard. While there is some fledgling documentation
courtesy Frank Miller, IAX is not a published standard at this time.

8) IAX allows an endpoint to check the validity of a phone number to know
whether the number is complete, may be complete, or is complete but could
be longer. There is no way to completely support this in SIP.

9) IAX always sends DTMF out of band so there is never any confusion about
what method is used.

10) IAX support transmission of language and context, which are useful in
an Asterisk environment. That's pretty much all that comes to mind at the
moment.


Mark


PS:
I Guess there must be some advantages to SIP (or we should call the writers of
it stupid).

So here a few questions to elaborate how IAX handles:

1) Bandwidth indications

2) New codecs

3) extensibility

4) Call Hold and other complex scenarios

5) Video telephone

I have got the impression this has all been better arranged in SIP
</screen>

    <para>Appendix to this e-mail: in the intervening years, IAX has itself
    become a well-documented and open protocol.</para>
  </section>

  <xi:include href="sip.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="iax.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
</chapter>