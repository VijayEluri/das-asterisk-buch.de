<?xml version="1.0" encoding="UTF-8"?>
<screen>-= Info about application &apos;Macro&apos; =-

[Synopsis]
Macro Implementation

[Description]
  Macro(macroname,arg1,arg2...): Executes a macro using the context
&apos;macro-&lt;macroname&gt;&apos;, jumping to the &apos;s&apos; extension of that context and
executing each step, then returning when the steps end.
The calling extension, context, and priority are stored in ${MACRO_EXTEN},
${MACRO_CONTEXT} and ${MACRO_PRIORITY} respectively.  Arguments become
${ARG1}, ${ARG2}, etc in the macro context.
If you Goto out of the Macro context, the Macro will terminate and control
will be returned at the location of the Goto.
If ${MACRO_OFFSET} is set at termination, Macro will attempt to continue
at priority MACRO_OFFSET + N + 1 if such a step exists, and N + 1 otherwise.
Extensions: While a macro is being executed, it becomes the current context.
            This means that if a hangup occurs, for instance, that the macro
            will be searched for an &apos;h&apos; extension, NOT the context from which
            the macro was called. So, make sure to define all appropriate
            extensions in your macro! (Note: AEL does not use macros)
WARNING: Because of the way Macro is implemented (it executes the priorities
         contained within it via sub-engine), and a fixed per-thread
         memory stack allowance, macros are limited to 7 levels
         of nesting (macro calling macro calling macro, etc.); It
         may be possible that stack-intensive applications in deeply nested macros
         could cause asterisk to crash earlier than this limit. It is advised that
         if you need to deeply nest macro calls, that you use the Gosub application
         (now allows arguments like a Macro) with explict Return() calls instead.<screen>
