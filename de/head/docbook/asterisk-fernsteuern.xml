<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="asterisk-fernsteuern" lang="de" revision="$Revision$">
  <!--% Copyright (c) 2007
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de -->

  <title>Asterisk fernsteuern<indexterm>
      <primary>Fernsteuern</primary>
    </indexterm></title>

  <para>Es gibt verschiedene Möglichkeiten, eine Asterisk-Telefonanlage von
  extern (also z.B. von anderen Programmen) aus zu steuern.</para>

  <section id="asterisk-rx">
    <title>asterisk -rx "<replaceable>Befehl</replaceable>"<indexterm>
        <primary>asterisk -rx</primary>
      </indexterm></title>

    <para>Die einfachste Möglichkeit, mit Asterisk von außen zu kommunizieren,
    ist der Aufruf des Programmes <command>asterisk</command> mit den
    Parametern <parameter>-rx</parameter> und danach dem CLI-Befehl. So kann
    man jeden beliebigen CLI-Befehl von der Shell aus ausführen.</para>

    <section id="asterisk-rx-beispiel">
      <title>Beispiel</title>

      <para>Wenn man sich den Dialplan für die Extension
      <parameter>23</parameter> im Context
      <parameter>[meine-telefone]</parameter> anschauen will, kann man dies
      mit der Eingabe <command>asterisk -rx "show dialplan
      23@meine-telefone"</command> erreichen:<screen>root@molokai:~&gt;asterisk -rx "show dialplan 23@meine-telefone"
[ Context 'meine-telefone' created by 'pbx_config' ]
  '23' =&gt;           1. Wait(1)                                    [pbx_config]
                    2. Answer()                                   [pbx_config]
                    3. Playback(hello-world)                      [pbx_config]
                    4. Wait(1)                                    [pbx_config]
                    5. Hangup()                                   [pbx_config]

-= 1 extension (5 priorities) in 1 context. =-
root@molokai:~&gt;</screen></para>
    </section>
  </section>

  <section id="call-file">
    <title>Call Files<indexterm>
        <primary>Call Files</primary>
      </indexterm></title>

    <para>Call Files lassen sich am ehesten mit Batch-Dateien vergleichen. Sie
    werden ins Verzeichnis <filename>/var/spool/asterisk/outgoing/</filename>
    verschoben und dort dann von Asterisk abgearbeitet.<important>
        <para>Ein <command>mv</command> (move) ist im Dateisystem ein atomarer
        Vorgang und deshalb für Call Files ideal geeignet. Bei einem
        <command>cp</command> (copy) wird dagegen die Datei Zeile für Zeile
        kopiert. Es kann also vorkommen, dass ein halbfertig kopiertes Call
        File von Asterisk bereits abgearbeitet wird.</para>
      </important></para>

    <para>Der ganze Mechanismus lässt sich anhand eines Beispiels besser
    erklären. Nehmen wir an, dass an einer Asterisk-Anlage ein SIP-Telefon mit
    der Nummer 2000 angemeldet ist. Weiterhin haben wir im Dialplan die
    folgende Extension eingetragen:<programlisting>[call-file-test]
exten =&gt; 10,1,Answer()
exten =&gt; 10,n,Wait(1)
exten =&gt; 10,n,Playback(hello-world)
exten =&gt; 10,n,Wait(1)
exten =&gt; 10,n,Hangup()</programlisting></para>

    <para>Jetzt generieren wir im Verzeichnis <filename>/tmp/</filename> die
    Datei <filename>ein-test.call</filename> mit folgendem
    Inhalt:<programlisting>Channel: SIP/2000
MaxRetries: 2
RetryTime: 60
WaitTime: 30
Context: call-file-test
Extension: 10</programlisting></para>

    <para>Danach verschieben wir diese Datei mit <command>mv
    /tmp/ein-test.call /var/spool/asterisk/outgoing/</command><screen>root@molokai:~&gt;mv /tmp/ein-test.call /var/spool/asterisk/outgoing/</screen></para>

    <para>Jetzt passiert Folgendes:</para>

    <itemizedlist>
      <listitem>
        <simpara>Asterisk überprüft ständig, ob sich im Verzeichnis
        <filename>/var/spool/asterisk/outgoing/</filename> ein Call File
        befindet, und arbeitet dieses ab, sobald es da ist.</simpara>
      </listitem>

      <listitem>
        <simpara>Asterisk öffnet eine Verbindung zum Telefon
        <code>SIP/2000</code>. Wenn das Telefon besetzt sein oder nicht
        rangehen sollte, dann versucht Asterisk das gleiche noch zwei Mal
        (siehe <parameter>MaxRetries</parameter>).</simpara>
      </listitem>

      <listitem>
        <simpara>Geht der Benutzer des Telefons 2000 ran, dann startet
        Asterisk im Context <parameter>[call-file-test]</parameter> die
        Abarbeitung der Extension <code>10</code>. Es wird also der
        Sprachbaustein <filename>hello-world</filename> abgespielt.</simpara>
      </listitem>
    </itemizedlist>

    <section id="call-file-parameter">
      <title>Parameter</title>

      <para>Im Call File können folgende Parameter angegeben
      werden:<variablelist termlength="23">
          <varlistentry>
            <term><code>Channel: &lt;channel&gt; </code></term>

            <listitem>
              <simpara>Der zu benutzende Channel. Dabei gilt die gleiche
              Syntax wie beim <code>Dial()</code>-Befehl (siehe <xref
              linkend="applikationen-dial" />).</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Callerid: &lt;callerid&gt;</code></term>

            <listitem>
              <simpara>Die zu benutzende Caller-ID.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>WaitTime: &lt;number&gt;</code></term>

            <listitem>
              <simpara>Die Anzahl an Sekunden, die das System auf die Annahme
              des Anrufs warten soll. Wird der Wert nicht angegeben, dann ist
              der Default 45 Sekunden.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>MaxRetries: &lt;number&gt;</code></term>

            <listitem>
              <simpara>Die Anzahl der weiteren Wählversuche (falls besetzt
              oder nicht erreichbar). Wird dieser Parameter nicht angegeben,
              ist der Defaultwert 0 (es wird also nur einmal versucht, den
              Channel aufzubauen).</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>RetryTime: &lt;number&gt;</code></term>

            <listitem>
              <simpara>Die Anzahl an Sekunden, die bis zum nächsten
              Wählversuch gewartet wird. Wird dieser Parameter nicht
              angegeben, ist der Defaultwert 300 Sekunden.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Account: &lt;account&gt;</code></term>

            <listitem>
              <simpara>Der Abrechnungscode für Ihr CDR-System.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Context: &lt;context&gt;</code></term>

            <listitem>
              <simpara>Der Zielcontext.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Extension: &lt;exten&gt;</code></term>

            <listitem>
              <simpara>Die Zielextension, die bei Erfolg aufgerufen
              wird.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Priority: &lt;priority&gt; </code></term>

            <listitem>
              <simpara>Die Zielpriorität. Wenn nicht angegeben, dann ist der
              Defaultwert 1.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Setvar: &lt;var=value&gt;</code></term>

            <listitem>
              <simpara>Mit <parameter>Setvar:</parameter> können beliebig
              viele Channelvariablen definiert werden.</simpara>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Archive: &lt;yes|no&gt;</code></term>

            <listitem>
              <simpara>Normalerweise werden Call Files nach der Abarbeitung
              direkt gelöscht. Ist <parameter>Archive: yes</parameter>
              gesetzt, werden die Call Files aber stattdessen ins Verzeichnis
              <filename>/var/spool/asterisk/outgoing_done/</filename>
              verschoben. Dabei wird Asterisk noch eine Zeile zum Call File
              hinzufügen. Diese beschreibt das Ergebnis des Call Files und
              sieht so aus:</simpara>

              <literallayout>Status: &lt;Expired|Completed|Failed&gt;</literallayout>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>

    <section id="call-file-zukunft">
      <title>Call Files in der Zukunft aufrufen</title>

      <para>Beim Aufruf eines Call Files vergleicht Asterisk die Zeit der
      letzten Änderung der Datei mit der aktuellen Uhrzeit. Liegt dieser
      Eintrag in der Zukunft, wird das Call File noch nicht abgearbeitet. So
      kann man leicht Call Files zeitgesteuert abarbeiten.</para>
    </section>

    <section id="call-file-weckruf">
      <title>Beispiel Weckruf</title>

      <para>Nehmen wir an, ein Hotel möchte über Asterisk ein einfaches
      Weckrufsystem erstellen. Kunden sollen einen Weckruf über die
      Servicerufnummer *77* aktivieren können. Nach der *77* soll das genaue
      Datum und die Weckuhrzeit gewählt werden.<programlisting>[hotel-intern]
exten =&gt; _*77*XXXXXXXXXXXX,1,Answer()
exten =&gt; _*77*XXXXXXXXXXXX,n,Set(Jahr = ${EXTEN:4:4})
exten =&gt; _*77*XXXXXXXXXXXX,n,Set(Monat = ${EXTEN:8:2})
exten =&gt; _*77*XXXXXXXXXXXX,n,Set(Tag = ${EXTEN:10:2})
exten =&gt; _*77*XXXXXXXXXXXX,n,Set(Stunden = ${EXTEN:12:2})
exten =&gt; _*77*XXXXXXXXXXXX,n,Set(Minuten = ${EXTEN:14:2})
exten =&gt; _*77*XXXXXXXXXXXX,n,NoOp(Weckruf soll fuer die Rufnummer ${CALLERID(num)} soll um ${Stunden}:${Minuten} Uhr am ${Tag}.${Monat}.${Jahr} erfolgen.)
exten =&gt; _*77*XXXXXXXXXXXX,n,System(echo 'Channel: SIP/${CALLERID(num)}\nContext: Weckruf\nExtension: 23' &amp;gt; /tmp/${UNIQUEID}.call)
exten =&gt; _*77*XXXXXXXXXXXX,n,System(touch -t ${Jahr}${Monat}${Tag}${Stunden}${Minuten} /tmp/${UNIQUEID}.call)
exten =&gt; _*77*XXXXXXXXXXXX,n,System(mv /tmp/${UNIQUEID}.call /var/spool/asterisk/outgoing/
exten =&gt; _*77*XXXXXXXXXXXX,n,Playback(rqsted-wakeup-for)
exten =&gt; _*77*XXXXXXXXXXXX,n,SayNumber(${Stunden})
exten =&gt; _*77*XXXXXXXXXXXX,n,SayNumber(${Minuten})
exten =&gt; _*77*XXXXXXXXXXXX,n,Playback(digits/oclock)
exten =&gt; _*77*XXXXXXXXXXXX,n,Hangup()

[Weckruf]
exten =&gt; 23,1,Answer()
exten =&gt; 23,n,Wait(1)
exten =&gt; 23,n,Playback(this-is-yr-wakeup-call)
exten =&gt; 23,n,Wait(1)
exten =&gt; 23,n,Hangup()</programlisting></para>
    </section>
  </section>

  <section id="asterisk-manager-api">
    <title>Das Manager-Interface (AMI)<indexterm>
        <primary>Manager-Interface</primary>
      </indexterm><indexterm>
        <primary>AMI</primary>
      </indexterm><indexterm>
        <primary><filename>manager.conf</filename></primary>
      </indexterm><indexterm>
        <primary>Asterisk Manager Interface</primary>
      </indexterm></title>

    <para>Das Manager-Interface aktiviert man, indem man in der
    <filename>manager.conf</filename> im Abschnitt <code>[general]</code> den
    Parameter <code>enabled=yes</code> setzt.<caution>
        <para>Das sollte man nie auf einem Server mit öffentlichem Zugang
        machen, außer man schützt sich zusätzlich durch
        <command>iptables</command>, <command>ipfw</command> oder eine andere
        Firewall oder einen SSH-Tunnel!</para>
      </caution>Ganz unten legen wir uns einen Benutzereintrag mit dem Namen
    <parameter>admin</parameter> an:<programlisting>[admin]
secret = geheim
deny = 0.0.0.0/0.0.0.0
permit = 127.0.0.1/255.255.255.255
read = all,system,call,log,verbose,command,agent,user,config
write = all,system,call,log,verbose,command,agent,user,config</programlisting>Die
    Optionen nach <code>read</code> und <code>write</code> geben an, für
    welche Befehlsklassen wir dem User Rechte geben.<footnote>
        <simpara>Welche Rechte-Klassen man zum Ausführen eines Befehls haben
        muss, erfährt man im CLI mit <command>show manager commands</command>
        bzw. <command>manager show commands</command>.</simpara>
      </footnote><caution>
        <para>Diese großzügige Rechtevergabe dient nur zum Testen! Mit dem
        Recht <code>command</code> kann der User z.B. Asterisk stoppen. Seit
        1.4 ist es sogar möglich, durch das AMI den Dialplan zu verändern und
        dann evtl. mit <code>System()</code> auf der Shell Befehle mit
        root-Rechten auszuführen!</para>
      </caution>Nach einem Restart von Asterisk können wir uns auf Port 5038
    mit dem AMI verbinden, was wir auf der Shell mit
    <command>telnet</command><footnote>
        <simpara>Hier kommt nur das <emphasis>Tool</emphasis>
        <command>telnet</command> zum Einsatz. Das hat nichts mit dem
        Telnet-Protokoll oder Port zu tun.</simpara>
      </footnote>ausprobieren:<screen><prompt>$ </prompt>telnet 127.0.0.1 5038
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Asterisk Call Manager/1.0</screen>Man kann hier von Hand Befehle (die meist
    aus mehreren Zeilen bestehen) eintippen, z.B.:<screen>Action: Login
ActionID: 1
Username: admin
Secret: geheim

</screen><note>
        <simpara>Alle Befehls-Pakete werden durch zwei Returns
        abgeschlossen.</simpara>
      </note></para>

    <para>Antwort:<screen>Response: Success
ActionID: 1
Message: Authentication accepted
</screen></para>

    <simpara>Die primäre Verwendung liegt aber ganz klar im automatisierten
    Zugriff durch Skripte.</simpara>

    <note>
      <para>Die Manager-API ist nicht unbedingt dafür berühmt, viele
      gleichzeitige Verbindungen handhaben zu können (auch wenn sich das in
      der Version 1.4 stark verbessert hat). In so einer Last-Situation könnte
      man über den Einsatz eines speziellen Proxys wie den <quote>Simple
      Asterisk Manager Proxy</quote><footnote>
          <simpara><ulink
          url="http://www.popvox.com/simpleproxy.pl">http://www.popvox.com/simpleproxy.pl</ulink></simpara>
        </footnote> (ein Perl-Skript) nachdenken, der viele Verbindungen
      entgegennimmt und zu einer bündelt - für die zugreifenden Skripte völlig
      transparent. Für die folgenden <quote>Spielereien</quote> ist das aber
      unnötig.</para>
    </note>

    <simpara>Nach erfolgreicher Authentifizierung können in beiden Richtung
    Pakete gesendet werden. Die Art des Pakets wird immer von der ersten Zeile
    darin bestimmt. Der Client sendet <code>Action</code>-Pakete, der Server
    antwortet mit <code>Response</code> oder kann auch von sich aus
    <code>Event</code>-Pakete schicken. Die Reihenfolge der Zeilen in einem
    Paket ist ansonsten aber irrelevant. Zeilen werden durch CR LF<footnote>
        <simpara>Carriage Return (ASCII 13 dezimal) und Line Feed (ASCII 10
        dezimal)</simpara>
      </footnote> beendet, das ganze Paket durch ein weiteres CR LF.
    Normalerweise sendet der Client in jeder <code>Action</code> ein
    <code>ActionID</code>-Feld mit beliebigem, möglichst eindeutigem,
    Inhalt<footnote>
        <simpara>Hier bietet sich etwa der Name des Skripts, ein Timestamp und
        eine fortlaufende Nummer für jede Action an, z.B.
        <code>testskript.php-1169405408-1.</code></simpara>
      </footnote>, das der Server so in seine <code>Response</code> übernimmt,
    damit sich die Antworten bei Überschneidungen zuordnen lassen.</simpara>

    <simpara>Der Server sendet <code>Event</code>-Pakete, um den Client über
    verschiedene Ereignisse zu informieren. Es gibt auch Ereignisse, die von
    einer <code>Action</code> des Clients ausgelöst werden. Dann sendet der
    Server ein <code>Response: Follows</code> gefolgt von den Events (die dann
    ebenfalls die <code>ActionID</code> beinhalten) und ein abschließendes
    Event (normalerweise
    <replaceable>Aktionsname</replaceable>Complete).</simpara>

    <simpara>Wenn Ihr Client keine Events benötigt, kann er direkt im ersten
    Authentifizierungs-Paket den Parameter <code>Events: off</code> senden, um
    dann nur Antworten auf von ihm gesendete Actions zu erhalten.</simpara>

    <para>Die Liste der verfügbaren Befehle erhält man im
    <emphasis>CLI</emphasis> mit <command>show manager commands</command>
    (bzw. <command>manager show commands</command>), Informationen über einen
    Befehl mit <command>show manager command
    <replaceable>Befehlsname</replaceable></command> (bzw. <command>manager
    show command <replaceable>Befehlsname</replaceable></command>):<screen>mos-eisley*CLI&gt; manager show commands
  Action           Privilege        Synopsis                                               
  ------           ---------        --------                                               
  AbsoluteTimeout  call,all         Set Absolute Timeout                                   
  AgentCallbackLo  agent,all        Sets an agent as logged in by callback                 
  AgentLogoff      agent,all        Sets an agent as no longer logged in                   
  Agents           agent,all        Lists agents and their status                          
  ChangeMonitor    call,all         Change monitoring filename of a channel                
  Command          command,all      Execute Asterisk CLI Command                           
  DBGet            system,all       Get DB Entry                                           
  DBPut            system,all       Put DB Entry                                           
  Events           &lt;none&gt;           Control Event Flow                                     
  ExtensionState   call,all         Check Extension Status                                 
  GetConfig        config,all       Retrieve configuration                                 
  Getvar           call,all         Gets a Channel Variable                                
  Hangup           call,all         Hangup Channel                                         
  IAXnetstats      &lt;none&gt;           Show IAX Netstats                                      
  IAXpeers         &lt;none&gt;           List IAX Peers                                         
  ListCommands     &lt;none&gt;           List available manager commands                        
  Logoff           &lt;none&gt;           Logoff Manager                                         
  MailboxCount     call,all         Check Mailbox Message Count                            
  MailboxStatus    call,all         Check Mailbox                                          
  Monitor          call,all         Monitor a channel                                      
  Originate        call,all         Originate Call                                         
  Park             call,all         Park a channel                                         
  ParkedCalls      &lt;none&gt;           List parked calls                                      
  PauseMonitor     call,all         Pause monitoring of a channel                          
  Ping             &lt;none&gt;           Keepalive command                                      
  PlayDTMF         call,all         Play DTMF signal on a specific channel.                
  QueueAdd         agent,all        Add interface to queue.                                
  QueuePause       agent,all        Makes a queue member temporarily unavailable           
  QueueRemove      agent,all        Remove interface from queue.                           
  Queues           &lt;none&gt;           Queues                                                 
  QueueStatus      &lt;none&gt;           Queue Status                                           
  Redirect         call,all         Redirect (transfer) a call                             
  SetCDRUserField  call,all         Set the CDR UserField                                  
  Setvar           call,all         Set Channel Variable                                   
  SIPpeers         system,all       List SIP peers (text format)                           
  SIPshowpeer      system,all       Show SIP peer (text format)                            
  Status           call,all         Lists channel status                                   
  StopMonitor      call,all         Stop monitoring a channel                              
  UnpauseMonitor   call,all         Unpause monitoring of a channel                        
  UpdateConfig     config,all       Update basic configuration                             
  UserEvent        user,all         Send an arbitrary event                                
  WaitEvent        &lt;none&gt;           Wait for an event to occur</screen>Diese
    Befehle sind fast immer gleichlautend mit einer entsprechenden
    Dialplan-Applikation - neu ist vor allem die Action
    <code>Originate</code>, mit der man einen ausgehenden Anruf veranlassen
    kann, und <code>Command</code>, was einen Befehl direkt auf dem CLI
    ausführt. Da wir unserem User <code>admin</code> alle Rechte gegeben haben
    (s.o.), darf er alle Befehle ausführen. Wie man einen Befehl benutzt,
    erfährt man so:<screen>mos-eisley*CLI&gt; manager show command Command
Action: Command 
Synopsis: Execute Asterisk CLI Command
Privilege: command,a
Description: Run a CLI command.
Variables: (Names marked with * are required)
        *Command: Asterisk CLI command to run
        ActionID: Optional Action id for message matching.</screen></para>

    <simpara>Die von Asterisk verschickten Events sind bisher so gut wie
    undokumentiert. Auf <ulink
    url="http://www.voip-info.org/wiki/view/asterisk+manager+events">http://www.voip-info.org/wiki/view/asterisk+manager+events</ulink>
    findet sich eine zusammengestellte Liste mit spärlichen Hinweisen. Ein
    paar Erklärungen kann man auf <ulink
    url="http://asterisk-java.sourceforge.net/apidocs/net/sf/asterisk/manager/event/package-frame.html">http://asterisk-java.sourceforge.net/apidocs/net/sf/asterisk/manager/event/package-frame.html</ulink>
    nachlesen<footnote>
        <simpara>Nicht verwirren lassen, das ist eigentlich eine
        Java-Dokumentation.</simpara>
      </footnote>.</simpara>

    <section id="manager-interface-beispiel-expect">
      <title>Beispiel: Anzahl der Mailbox-Nachrichten mit Expect
      abfragen</title>

      <simpara>Nehmen wir an, wir wollten über das Manager-Interface die
      Anzahl der Nachrichten in einer Voicemailbox abfragen. Diese einfache
      Aufgabe lässt sich leicht mit einem Skript für <command>expect</command>
      lösen.</simpara>

      <sidebar>
        <simpara><command>expect</command> ist ein erweiterter
        Tcl-Interpreter, mit dem man automatisiert interaktive Shell-Programme
        ansteuern kann.<footnote>
            <simpara><ulink
            url="http://expect.nist.gov/">http://expect.nist.gov/</ulink>,
            <ulink
            url="http://en.wikipedia.org/wiki/Expect">http://en.wikipedia.org/wiki/Expect</ulink></simpara>
          </footnote></simpara>
      </sidebar>

      <para>Folgendes Expect-Skript verbindet sich mit dem AMI, loggt sich ein
      und gibt schließlich die Anzahl der neuen und alten Nachrichten in der
      angegebenen Mailbox aus:<programlisting>#!/usr/bin/expect
#
# Aufruf: ./vmcount.exp 1234@default

if {[llength $argv] != 1} {
    send_user "Fehler: Geben Sie eine Mailbox an!\n"
    exit 1
}

# erstes Argument ist die abzufragende Mailbox:
set mailbox [lindex $argv 0]
send_user "Mailbox: $mailbox\n"

# Durchschleifen von stdout zum User abschalten:
log_user 0

# Verbindung zum AMI öffnen:
spawn telnet 127.0.0.1 5038

# auf die Zeichenfolge "Manager" warten und bei Erfolg
# ein Login-Paket senden:
#
expect "Manager" {
    send_user "Verbunden.\n"
    send "Action: Login\nUsername: admin\nSecret: geheim\n\n"
}

# Login erfolgreich?:
#
expect {
    -re "Response:\\s*Error" {
        send_user "Login fehlgeschlagen.\n"
        exit 1
    }
    -re "Response:\\s*Success" {
        send_user "Eingeloggt.\n"
        # Anzahl der Mailbox-Nachrichten abfragen:
        send "Action: MailboxCount\nMailbox: 1234@default\n\n"
    }
}

expect {
    -re "Response:\\s*Error" {
        send_user "Abfragen der Mailbox fehlgeschlagen.\n"
        exit 1
    }
    -re "Response:\\s*Success" {}
}
expect {
    -re "NewMessages:\\s*(\[\\d]*)" {
        send_user "Neue Nachrichten: $expect_out(1,string)\n"
    }
}
expect {
    -re "OldMessages:\\s*(\[\\d]*)" {
        send_user "Alte Nachrichten: $expect_out(1,string)\n"
    }
}

# Ausloggen - nicht unbedingt nötig, aber sauber:
send "Action: Logoff\n\n"
</programlisting>Wir speichern das Skript als <filename>vmcount.exp</filename>
      und setzen es mit <command>chmod a+x vmcount.exp</command> auf
      ausführbar.</para>

      <para>Aufruf:<screen>$ ./vmcount.exp 123@default
Mailbox: 123@default
Verbunden.
Eingeloggt.
Neue Nachrichten: 0
Alte Nachrichten: 0
</screen></para>
    </section>

    <section id="manager-interface-starastapi">
      <title>StarAstAPI für PHP<indexterm>
          <primary>StarAstAPI</primary>
        </indexterm></title>

      <simpara>Vorweg gesagt: Erwarten Sie nicht zu viel von diesem kleinen
      Exkurs. StarAstAPI ist noch verbesserungsfähig. :-)</simpara>

      <simpara>Für das Manager-Interface gibt es mittlerweile mehr oder
      weniger gute APIs in verschiedenen Programmiersprachen (PHP, Perl,
      Python, Ruby etc.), die natürlich hier nicht alle getestet werden
      konnten<footnote>
          <simpara>Beispiele mit Anmerkungen auf <ulink
          url="http://www.voip-info.org/wiki/view/Asterisk+manager+Examples">http://www.voip-info.org/wiki/view/Asterisk+manager+Examples</ulink></simpara>
        </footnote>. Sollte die API für Ihre Lieblingssprache nicht laufen,
      können Sie das Problem sicher lösen - bis hierher haben sowieso nur
      Leute gelesen, die schon mal programmiert haben. :-)</simpara>

      <para>Wir testen hier ganz kurz die StarAstAPI<footnote>
          <simpara>von <ulink
          url="http://www.starutilities.com/">http://www.starutilities.com/</ulink></simpara>
        </footnote> in PHP, die ein PHP 5 voraussetzt<footnote>
          <simpara>Die API lässt sich aber relativ leicht auf PHP 4
          umschreiben, obwohl der Code recht unübersichtlich und schlecht
          formatiert ist. Im Zweifelsfall einfach immer die Parse-Errors
          beheben. :-)</simpara>
        </footnote>, das mit <code>--enable-sockets</code> kompiliert
      wurde.<footnote>
          <para>Auf der Shell erfährt man mit <command>php -m</command>,
          welche Module einkompiliert sind.</para>
        </footnote> Leider findet man in den StarAstAPI-Dateien noch die seit
      Jahren veralteten <quote>short open tags</quote> (<code>&lt;?</code>),
      ersetzen Sie diese ggf. durch die korrekte Syntax
      (<code>&lt;?php</code>). Der API liegen 4 Demo-Skripte bei:
      <filename>sLogin.php</filename> versucht nur, sich einzuloggen<footnote>
          <simpara>Wenn Sie nach der Anleitung oben vorgegangen sind, müssen
          Sie natürlich jeweils den Benutzernamen und das Passwort
          entsprechend anpassen.</simpara>
        </footnote>, <filename>sCommand.php</filename> führt den CLI-Befehl
      <code>reload</code> aus, <filename>sDial.php</filename> versucht eine
      Verbindung mit SIP/120 und <filename>sEvents.php</filename> empfängt
      Events. Wenn wir gleichzeitig mit <command>asterisk -vvvr</command> die
      CLI beobachten und mit <command>php -q sLogin.php</command> eine
      Verbindung zum AMI öffnen<footnote>
          <simpara>Hier absichtlich mit falschem User/Passwort.</simpara>
        </footnote>, sehen wir im CLI:<screen>mos-eisley*CLI&gt; 
  == Parsing '/etc/asterisk/manager.conf': Found
[Jan 26 20:08:09] NOTICE[10352]: manager.c:961 authenticate: 127.0.0.1 tried to authenticate with nonexistent user 'mark'
  == Connect attempt from '127.0.0.1' unable to authenticate
mos-eisley*CLI&gt; </screen> Es hat also wegen des falschen Users nicht
      funktioniert, trotzdem meldet das Demo-Skript:<screen>$  php -q sLogin.php 
Login Sucessful 

</screen>und danach das Response-Paket:<screen>Response:  Error
ActionID:  1
Message:  Authentication failed
</screen>StarAstAPI arbeitet also nicht ganz sauber, kann aber sicher ohne
      allzu großen Aufwand verbessert werden. Wenn wir <command>php -q
      sEvents.php</command> aufrufen - jetzt mit dem richtigen User - sehen
      wir im CLI:<screen>mos-eisley*CLI&gt; 
  == Parsing '/etc/asterisk/manager.conf': Found
  == Manager 'admin' logged on from 127.0.0.1
mos-eisley*CLI&gt; </screen>Testhalber führen wir im CLI ein
      <code>reload</code> aus, was sich in diesen Events in der Ausgabe des
      PHP-Skripts widerspiegelt:<screen>Event:  Reload
Privilege:  system,all
Message:  Reload Requested

Event:  ChannelReload
Privilege:  system,all
Channel:  SIP
ReloadReason:  RELOAD (Channel module reload)
Registry_Count:  0
Peer_Count:  0
User_Count:  0

</screen>Lassen Sie sich was einfallen! Schreiben Sie ein kleines Skript, das
      all Ihre Freunde anruft - natürlich mitten in der Nacht!</para>
    </section>

    <section id="manager-interface-beispiel-php">
      <title>Beispiel: Anzahl der Mailbox-Nachrichten mit PHP abfragen</title>

      <para>So könnten wir das Beispiel aus <xref
      linkend="manager-interface-beispiel-expect" /> in PHP mit der StarAstAPI
      lösen:<programlisting>#!/usr/bin/php -q
&lt;?php
# der Parameter -q dient dazu, bei einem CGI-PHP die Ausgabe der
# Header abzuschalten

if ($argc != 2) {
    echo "Fehler: Geben Sie eine Mailbox an!\n";
    exit(1);
}
# das erste Argument nach dem Programmnamen ist die Mailbox:
$mailbox = $argv[1];
echo "Mailbox: $mailbox\n\n";

# StarAstAPI einbinden:
require_once './StarAstAPI/StarAstAPI.php';

# verbinden und einloggen:
#
$ami = new AstClientConnection();
if ($ami-&gt;Login( 'admin', 'geheim', '127.0.0.1', 5038 )) {
    $rp = $ami-&gt;GetResponse('1');
    //echo $rp-&gt;ToString();
} else {
    exit(1);
}

# folgendes Paket senden:
#     Action: MailboxCount
#     Mailbox: $mailbox
#     ActionID: 2
#
$data = new AstPacketData;
$data-&gt;AddKVPair( 'Action'  , 'MailboxCount' );
$data-&gt;AddKVPair( 'Mailbox' , $mailbox );
$data-&gt;AddKVPair( 'ActionID', '2' );
$packet = new AstPacket;
$packet-&gt;SetAstPacketType( 'Action' );
$packet-&gt;SetAstPacketData( $data );
$ami-&gt;SendPacket( $packet );

# Antwort-Paket mit ActionID 2 lesen:
#
$rPacket = $ami-&gt;GetResponse('2');
//echo $rp-&gt;ToString();
$rData = $rPacket-&gt;GetAstPacketData();
$r = $rData-&gt;GetAll();

echo "Neue Nachrichten: ", (int)trim($r['NewMessages:']), "\n";
echo "Alte Nachrichten: ", (int)trim($r['OldMessages:']), "\n";
echo "\n";

# Ausloggen - nicht unbedingt nötig, aber sauber:
#
$ami-&gt;Logoff();
# allerdings ist die Funktion der StarAstAPI nicht gerade schön.
# sie tut dies:
#echo "Logoff Called from somewhere ...";
#socket_close($this-&gt;mSocket);

echo "\n";
?&gt;</programlisting>Wir speichern das Skript als
      <filename>vmcount.php</filename> und setzen es mit <command>chmod a+x
      vmcount.exp</command> auf ausführbar.</para>

      <para>Aufruf:<screen>$ ./vmcount.php 123@default
Mailbox: 123123123

Neue Nachrichten: 0
Alte Nachrichten: 0

Logoff Called from somewhere ...
</screen></para>
    </section>
  </section>

  <section id="manager-interface-ajam">
    <title>Der Aynchronous Javascript Asterisk Manager (AJAM)<indexterm>
        <primary>AJAM</primary>
      </indexterm><indexterm>
        <primary>Aynchronous Javascript Asterisk Manager</primary>
      </indexterm><indexterm>
        <primary><filename>http.conf</filename></primary>
      </indexterm></title>

    <simpara>Seit Version 1.4 bringt Asterisk einen kleinen Webserver mit,
    AJAM genannt, über den man per HTTP auf das Asterisk Manager Interface
    (AMI) zugreifen kann. Die Bezeichnung <quote>AJAM</quote> ist eindeutig
    von <quote>AJAX</quote><footnote>
        <simpara><ulink
        url="http://de.wikipedia.org/wiki/Ajax_(Programmierung)">http://de.wikipedia.org/wiki/Ajax_(Programmierung)</ulink></simpara>
      </footnote> (Asynchronous JavaScript and XML) abgeleitet.</simpara>

    <para>Zur Einrichtung sind die Schritte wie in <xref
    linkend="asterisk-manager-api" /> Voraussetzung, zusätzlich stellt man in
    der <filename>manager.conf</filename> im Abschnitt <code>[general]</code>
    den Parameter <code>webenabled</code> auf <code>yes</code> ein. Beachten
    Sie auch den Parameter <code>httptimeout</code>, der festlegt, nach
    welcher Inaktivität (in Sekunden) man im Web-Interface automatisch
    ausgeloggt wird. Um dann den Webserver zu aktivieren, setzt man in der
    <filename>http.conf</filename> folgende Einstellungen:<programlisting>[general]
enabled=yes
enablestatic=yes
bindaddr=127.0.0.1
bindport=8088
prefix=asterisk</programlisting><code>enablestatic</code> muss man nur dann
    aktivieren, wenn der AJAM auch als Webserver für statische Dateien im
    Verzeichnis <filename>/var/lib/asterisk/static-http/</filename> fungieren
    soll. Normalerweise stellt man das auf <code>no</code>, es ist aber
    Voraussetzung für die Asterisk-AJAM-Demo (<xref
    linkend="manager-interface-ajam-demo" />).</para>

    <simpara>Restart nicht vergessen!</simpara>

    <caution>
      <para>Nach meiner Einschätzung ist es in den seltensten Fällen
      empfehlenswert, andere Web-Applikationen, also solche, die
      ausschließlich für den Administrator zugänglich sind, direkt auf die
      AJAM-Schnittstelle zugreifen zu lassen, und das ist wohl auch nicht so
      gedacht, denn dazu lassen sich die Rechte mit <code>read</code> und
      <code>write</code> (siehe <xref linkend="asterisk-manager-api" />)
      einfach nicht granular genug einstellen. Denken Sie daran, dass ein User
      absichtlich oder unabsichtlich auch andere Aktionen ausführen kann, als
      Sie ihm in der GUI zur Verfügung stellen. Besser wäre es, Ihre
      Applikation auf z.B. ein PHP-Skript zugreifen zu lassen, das nur
      vordefinierte erlaubte Befehle auf dem AMI ausführt, und zur Sicherheit
      muss noch nicht mal dieses Skript alle AMI-Rechte haben.</para>
    </caution>

    <section id="manager-interface-beispiel-ajam">
      <title>Beispiel: Anzahl der Mailbox-Nachrichten per AJAM
      abfragen</title>

      <simpara>Wir betrachten wieder die aus <xref
      linkend="manager-interface-beispiel-expect" /> und <xref
      linkend="manager-interface-beispiel-php" /> bekannte einfache Aufgabe,
      also die Anzahl der Nachrichten auf einer Mailbox abzufragen. Der AJAM
      bietet hier folgende Möglichkeiten:</simpara>

      <section id="ajam-format-html">
        <title>HTML<indexterm>
            <primary>AJAM</primary>

            <secondary>HTML</secondary>
          </indexterm></title>

        <para>Unter der URL<literallayout>http://localhost:8088/asterisk/manager</literallayout>wartet
        das Manager-Interface auf unsere Anfragen. Dabei werden die Felder
        eines Pakets als Parameter an die URL gehängt. Probieren Sie die
        folgenden beiden Adressen im Webbrowser aus:<literallayout>http://localhost:8088/asterisk/manager?action=Login&amp;username=admin&amp;secret=geheim
http://localhost:8088/asterisk/manager?action=MailboxCount&amp;mailbox=123</literallayout></para>

        <simpara>Die Antwort erfolgt jeweils als HTML-Seite, ist also für den
        Zugriff durch Skripte denkbar ungeeignet.</simpara>
      </section>

      <section id="ajam-format-text">
        <title>Plain-Text<indexterm>
            <primary>AJAM</primary>

            <secondary>Plain-Text</secondary>
          </indexterm></title>

        <para>Man kann in der URL <code>manager</code> durch
        <code>rawman</code> ersetzen, dann erfolgt die Antwort als Plain-Text.
        Zum Einloggen und Abfragen der Mailbox-Nachrichten
        also:<literallayout>http://localhost:8088/asterisk/rawman?action=Login&amp;username=admin&amp;secret=geheim</literallayout><screen>Response: Success
Message: Authentication accepted
</screen><literallayout>http://localhost:8088/asterisk/rawman?action=MailboxCount&amp;mailbox=123</literallayout><screen>Response: Success
Message: Mailbox Message Count
Mailbox: 123
NewMessages: 0
OldMessages: 0
</screen><literallayout>http://localhost:8088/asterisk/rawman?action=Logoff</literallayout><screen>Response: Goodbye
Message: Thanks for all the fish.
</screen></para>

        <simpara>Diese Text-Ausgabe kann man also gut in automatisierten
        Skripten verwenden.</simpara>
      </section>

      <section id="ajam-format-xml">
        <title>XML<indexterm>
            <primary>AJAM</primary>

            <secondary>XML</secondary>
          </indexterm></title>

        <para>Will man stattdessen lieber XML, dann ruft man <code>mxml</code>
        auf. Die XML-Ausgabe ist hier zur leichteren Lesbarkeit formatiert
        dargestellt, der AJAM macht keine Zeilenumbrüche innerhalb der Tags.
        Einen korrekten XML-Parser würde das aber auch so wie hier dargestellt
        nicht stören.<literallayout>http://localhost:8088/asterisk/mxml?action=Login&amp;username=admin&amp;secret=geheim</literallayout><screen>&lt;ajax-response&gt;
    &lt;response type='object' id='unknown'&gt;
        &lt;generic
            response='Success'
            message='Authentication accepted' /&gt;
    &lt;/response&gt;
&lt;/ajax-response&gt;
</screen><literallayout>http://localhost:8088/asterisk/mxml?action=MailboxCount&amp;mailbox=123</literallayout><screen>&lt;ajax-response&gt;
    &lt;response type='object' id='unknown'&gt;
        &lt;generic
            response='Success'
            message='Mailbox Message Count'
            mailbox='123'
            newmessages='0'
            oldmessages='0' /&gt;
    &lt;/response&gt;
&lt;/ajax-response&gt;
</screen><literallayout>http://localhost:8088/asterisk/mxml?action=Logoff</literallayout><screen>&lt;ajax-response&gt;
    &lt;response type='object' id='unknown'&gt;
        &lt;generic
            response='Goodbye'
            message='Thanks for all the fish.' /&gt;
    &lt;/response&gt;
&lt;/ajax-response&gt;
</screen></para>
      </section>
    </section>

    <section id="manager-interface-ajam-hinweise">
      <title>Hinweise zu AJAX und AJAM</title>

      <section id="ajam-format-json">
        <title>JSON</title>

        <para>Bei AJAX-Anwendungen - das erkennt man leicht am Namen
        <quote>Asynchronous JavaScript and XML</quote> - ist XML das übliche
        Format, obwohl es wegen seiner aufgeblähten Struktur vielfach
        kritisiert wird. Für AJAX können aber auch andere Formate wie
        JSON<footnote>
            <simpara><ulink
            url="http://de.wikipedia.org/wiki/JSON">http://de.wikipedia.org/wiki/JSON</ulink></simpara>
          </footnote> zum Einsatz kommen. JSON (JavaScript Object Notation)
        ist - der Name verrät es - besonders gut für JavaScript-Anwendungen
        geeignet, da die Datenstruktur hier nativ mit <code>eval()</code> in
        ein Objekt umgewandelt werden kann und wenig Overhead hat. Es
        existieren aber auch zahlreiche Implementierungen für PHP, Perl etc.
        Eine Ausgabe in JSON fehlt dem AJAM bisher jedoch leider. Man könnte
        aber beispielsweise die Plain-Text-Ausgabe clientseitig in JSON
        umwandeln, wenn einem das leichter fällt oder wenn es sich besser in
        vorhandene JS-Libs inegrieren lässt. Hier der Ansatz als
        Idee:<programlisting>// angenommen in responseText ist der empfangene Antwort-Text
// gespeichert, was wir hier nur simulieren:
var responseText = 'Response: Success\n'
+'Message: Mailbox Message Count\n'
+'Mailbox: 123\n'
+'NewMessages: 0\n'
+'OldMessages: 0\n';

// einfache Anführungszeichen escapen:
responseText = responseText.replace( /\'/g, "\\'" );
// Felder quoten:
responseText = responseText.replace( /^([a-z\d]*):\s*(.*)/gmi, "'$1':'$2'," );
// in Objekt umwandeln:
eval('var packet = {'+ responseText +'}');

// jetzt kann man wie bei jedem Objekt so auf die Felder zugreifen:
alert( packet['NewMessages'] );   // gibt "0" aus
</programlisting></para>
      </section>

      <section id="manager-interface-ajam-ping">
        <title>Ping</title>

        <para>Für Zugriffe von AJAX-Anwendungen auf den AJAM ist der
        Ping-Befehl besonders hilfreich, der dazu dient, die Verbindung und
        Authentifizierung offenzuhalten.<literallayout>http://localhost:8088/asterisk/rawman?action=Ping</literallayout><screen>Response: Pong
</screen></para>
      </section>

      <section id="manager-interface-ajam-demo">
        <title>AJAM Demo</title>

        <para>Unter der URL<literallayout>http://localhost:8088/asterisk/static/ajamdemo.html</literallayout>ist
        eine kleine Beispiel-Anwendung mitgeliefert, die den Zugriff per AJAX
        demonstriert. Sie verwendet die äußerst praktische JavaScript-Library
        Prototype<footnote>
            <simpara><ulink
            url="http://prototype.conio.net/">http://prototype.conio.net/</ulink>,
            mittlerweile auch <ulink
            url="http://www.prototypejs.org/">http://www.prototypejs.org/</ulink>,
            siehe <ulink
            url="http://en.wikipedia.org/wiki/Prototype_Javascript_Framework">http://en.wikipedia.org/wiki/Prototype_Javascript_Framework</ulink>
            oder <ulink
            url="http://de.wikipedia.org/wiki/Prototype">http://de.wikipedia.org/wiki/Prototype</ulink></simpara>
          </footnote> für die AJAX-Zugriffe und zeigt mit der Action
        <code>Status</code> die momentan aktiven Kanäle an. Sie können die
        AJAM-Demo als Basis für eigene AJAX-Anwendungen heranziehen.</para>
      </section>

      <section id="manager-interface-ajam-apache">
        <title>Apache</title>

        <para>Der Webserver von Asterisk ist sehr minimalistisch und ersetzt
        keinesfalls einen <quote>richtigen</quote> Server wie den Apache, der
        auch PHP-Skripte ausführt etc. Um beides zu vereinen, könnte man z.B.
        in der <filename>httpd.conf</filename> des Apache an der
        entsprechenden Stelle den Eintrag<programlisting>ProxyPass /ajam http://localhost:8088/asterisk</programlisting>verwenden,
        um für alle Zugriffe auf den URL-Pfad <code>/ajam</code> nur als Proxy
        zu fungieren und die Anfragen zum AJAM durchzuschleusen.</para>
      </section>
    </section>
  </section>
</chapter>