<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="kapitel-programmieren" lang="de" revision="$Revision$">
  <!--% Copyright (c) 2006 - 2007 by
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Programmieren im Dialplan</title>

  <para>Die Erstellung von intelligenten Funktionen oder Programmen kann in
  Asterisk extern über ein <link linkend="kapitel-agi">AGI-Skript</link>
  (vergleichbar mit CGI-Skripten bei Webservern) oder intern im <link
  linkend="dialplan-grundlagen">Dialplan</link> erfolgen. In diesem Kapitel
  beschäftigen wir uns mit der internen Variante. AGI-Skripte werden in einem
  Extra-Kapitel besprochen.</para>

  <para>In der Konfigurationsdatei <filename>extensions.conf</filename> wird
  der so genannte Dialplan definiert. Dabei ähnelt der Dialplan häufig einem
  BASIC-Programm. Der Admin kann in einer einfachen Skriptsprache
  Programmabläufe und damit auch das Routing von Telefonaten erstellen.</para>

  <section id="programmierer-howto">
    <title>Kleines Programmierer Howto</title>

    <indexterm>
      <primary>Howto</primary>

      <secondary>Kleines Programmierer Howto</secondary>
    </indexterm>

    <para>Die Schwierigkeit eines solchen Buches liegt unter anderem im breit
    gestreuten Grundwissen der Leser. Ein Buch über Asterisk wird von Admins,
    Programmierern, Telefonanlagentechnikern und vielen anderen technisch
    interessierten Menschen gelesen. Die praktischen Programmierkenntnisse
    sind dabei sehr unterschiedlich ausgeprägt. Um die Fähigkeiten von
    Asterisk auszureizen benötigt man schon einfache Programmierkenntnisse und
    ein gesundes Basiswissen. In diesem Howto möchte ich die wichtigsten
    Grundprinzipien und Ideen für Programmierer erläutern. Dabei gehe ich
    beispielhaft vor und verweise bei Detailfragen auf <xref
    linkend="applications" />. Einige Themen werden sie hier sicher aus
    anderen Kapiteln wiedererkennen. Dieses kleine Howto soll ihnen einen sehr
    schnellen Überblick zu dem Thema bieten.</para>

    <section id="programmierer-howto-programmstruktur">
      <title>Programmstruktur</title>

      <para>Im Dialplan (also der
      <filename>/etc/asterisk/extensions.conf</filename>) gibt es für jede zur
      Verfügung gestellte Zielrufnummer ein kleines Programm. Dieses Programm
      heißt bei Asterisk Extension. Eine Extension sieht dabei wie folgt
      aus:<programlisting>exten =&gt; 1001,1,Answer()
exten =&gt; 1001,n,Playback(hello-world)
exten =&gt; 1001,n,Hangup()</programlisting></para>

      <para>Häufig sieht man die Prioritäten auch nicht mit <code>n</code>
      sondern mit Zahlen benannt.<programlisting>exten =&gt; 1001,1,Answer()
exten =&gt; 1001,2,Playback(hello-world)
exten =&gt; 1001,3,Hangup()</programlisting>Die Funktionsweise der jeweiligen
      Extensions ist identisch. Wer mit <code>n</code> programmiert, kann
      später aber leichter einzelne Zeilen löschen oder hinzufügen.</para>
    </section>

    <section id="programmierer-howto-variablen">
      <title>Variablen</title>

      <para>Zum Generieren und Verändern von Variablen wird die Applikation
      <code>Set()</code> benutzt:<programlisting>exten =&gt; 1002,1,Set(Lieblingstier=Tiger)
exten =&gt; 1002,n,Set(Lieblingszahl=23)</programlisting></para>

      <para>Zum Lesen und Ausgeben von Variablen wird die Syntax
      <code>${VARIABLENNAME}</code> benutzt. Mit der Applikation
      <code>NoOp()</code> kann man Variablenwerte auf dem CLI ausgeben (ab
      Verbose-Level 3):<programlisting>exten =&gt; 1003,1,NoOp(${Lieblingstier})
exten =&gt; 1003,n,NoOp(${Lieblingszahl})</programlisting></para>

      <para>Es gibt verschiedene Arten von Variablen:<itemizedlist>
          <listitem>
            <para>Globale Variablen</para>

            <para>Gelten im gesamten Dialplan und werden bei Bedarf in der
            <filename>extensions.conf</filename> im Abschnitt
            <literal>[globals]</literal><programlisting>[globals]
SOLL_UEBERALL_LESBAR_SEIN=&gt;23</programlisting>bzw. in der
            <filename>extensions.ael</filename> in <literal>globals</literal>
            gesetzt.<programlisting>globals {
    SOLL_UEBERALL_LESBAR_SEIN=23;
}</programlisting></para>

            <para>Sie können auch im Dialplan mit
            <code>Set(GLOBAL(X)=23)</code> gesetzt und verändert
            werden.<programlisting>exten =&gt; 1004,1,Set(GLOBAL(SOLL_UEBERALL_LESBAR_SEIN)=23)
exten =&gt; 1004,n,NoOp(${SOLL_UEBERALL_LESBAR_SEIN})</programlisting></para>
          </listitem>

          <listitem>
            <para>Channel-Variablen</para>

            <para>Gelten nur im aktiven Channel (ein Channel kann z. B. ein
            Gespräch von Peter und Uwe sein). Sie werden mit
            <code>Set(Y=42)</code> definiert und verändert.<programlisting>exten =&gt; 1005,1,Set(SOLL_NUR_HIER_LESBAR_SEIN=42)
exten =&gt; 1005,n,NoOp(${SOLL_NUR_HIER_LESBAR_SEIN})</programlisting></para>
          </listitem>

          <listitem>
            <para>System-Variablen</para>

            <para>Diese sind quasi "Gott-gegeben" (ok, natürlich eher
            "Asterisk-gegeben" ;-)) und können einfach im Dialplan aufgerufen
            werden. Eine typische Systemvariable ist ${EXTEN}.<programlisting>exten =&gt; 1006,1,NoOp(Gewaehlte Nummer: ${EXTEN})</programlisting></para>
          </listitem>
        </itemizedlist></para>

      <formalpara>
        <title>Siehe auch:</title>

        <para><xref linkend="variablen" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-labels-und-goto">
      <title>Labels und Goto()</title>

      <indexterm>
        <primary>Labels</primary>
      </indexterm>

      <para>Mit <code>Goto()</code> kann man innerhalb des Dialplans Sprünge
      zu einem mit (Labelname) definierten Label vollziehen:<footnote>
          <para>Man kann natürlich mit <code>Goto()</code> auch zu einer
          bestimmten Priorität springen. Aber dann ist der ganze Vorteil der
          n-Priorität wieder weg.</para>
        </footnote></para>

      <itemizedlist>
        <listitem>
          <para>Innerhalb einer Extension:<programlisting>exten =&gt; 1007,1,Answer()
exten =&gt; 1007,n(Anfang),Wait(1)
exten =&gt; 1007,n,Playback(hello-world)
exten =&gt; 1007,n,Goto(Anfang)</programlisting></para>
        </listitem>

        <listitem>
          <para>Von Extension zu Extension:<programlisting>exten =&gt; 1008,1,Answer()
exten =&gt; 1008,n,Goto(1009,Ping)

exten =&gt; 1009,1(Ping),Playback(hello-world)
exten =&gt; 1009,n,Wait(2)
exten =&gt; 1009,n,Goto(1010,Pong)

exten =&gt; 1010,1(Pong),Playback(weasels-eaten-phonesys)
exten =&gt; 1010,n,Wait(2)
exten =&gt; 1010,n,Goto(1009,Ping)</programlisting></para>
        </listitem>

        <listitem>
          <para>Von Context zu Context:<programlisting>[zentrale]
exten =&gt; 1011,1,Answer()
exten =&gt; 1011,n,Playback(hello-world)
exten =&gt; 1011,n,Goto(verkauf,1012,1)

[verkauf]
exten =&gt; 1012,1,Playback(hello-world)
exten =&gt; 1012,n,Hangup()</programlisting></para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Siehe auch:</title>

        <para><xref linkend="applications-goto" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-while">
      <title>While()-Schleifen</title>

      <indexterm>
        <primary>While()-Schleifen</primary>
      </indexterm>

      <para>Mit <code>While()</code> lassen sich Schleifen im Dialplan
      erzeugen:<programlisting>exten =&gt; 1013,1,Answer()
exten =&gt; 1013,n,Set(i=1)
exten =&gt; 1013,n,While($[${i} &lt; 10])
exten =&gt; 1013,n,SayNumber(${i})
exten =&gt; 1013,n,Wait(1)
exten =&gt; 1013,n,Set(i=$[${i} + 1])
exten =&gt; 1013,n,EndWhile()
exten =&gt; 1013,n,Hangup()</programlisting></para>

      <formalpara>
        <title>Siehe auch:</title>

        <para><xref linkend="applications-while" />, <xref
        linkend="glossar-expressions" /></para>
      </formalpara>
    </section>

    <section id="programmierer-howto-gotoif">
      <title>GotoIf()-Bedingung</title>

      <indexterm>
        <primary>GotoIf()-Bedingung</primary>
      </indexterm>

      <para>Mit GotoIf() lassen sich Sprünge zu anderen Teilen im Dialplan mit
      einer Bedingung verbinden:<programlisting>exten =&gt; 1014,1,Answer()
exten =&gt; 1014,n,Set(Lieblingsnebenstelle = 0815)
exten =&gt; 1014,n,NoOp(Ueberpruefe, ob Anruf von ${Lieblingsnebenstelle} kommt.)
exten =&gt; 1014,n,GotoIf($[${CALLERID(num)} = ${Lieblingsnebenstelle}]?ja:nein)

exten =&gt; 1014,n(ja),Playback(hello-world)
exten =&gt; 1014,n,Hangup()

exten =&gt; 1014,n(nein),Playback(tt-monkeys)
exten =&gt; 1014,n,Hangup()</programlisting></para>

      <formalpara>
        <title>Siehe auch:</title>

        <para><xref linkend="applications-gotoif" />, <xref
        linkend="glossar-expressions" /></para>
      </formalpara>
    </section>

    <section id="programmier-howto-gosub">
      <title>Gosub()-Unterprogramme</title>

      <indexterm>
        <primary>Gosub()-Unterprogramme</primary>
      </indexterm>

      <para>Mit Gosub() kann man in ein Unterprogramm springen und aus diesem
      mit Return() wieder zurück:<programlisting>exten =&gt; 1015,1,Gosub(cid-setzen)
exten =&gt; 1015,n,Dial(SIP/${EXTEN})

exten =&gt; 1015,n(cid-setzen),Set(CALLERID(all)=Apfelmus GmbH &lt;012345678&gt;)
exten =&gt; 1015,n,Return()</programlisting></para>

      <formalpara>
        <title>Siehe auch:</title>

        <para><xref linkend="applications-gosub" />, <xref
        linkend="applications-gosubif" />, <xref
        linkend="applications-return" />, <xref
        linkend="applications-macro" /></para>
      </formalpara>
    </section>
  </section>

  <section id="variablen">
    <title>Variablen</title>

    <indexterm>
      <primary>Variablen</primary>
    </indexterm>

    <para>Variablen sind Platzhalter für konkrete Werte. Diese konkreten Werte
    sind abhängig von der Definition der Variablen, also dem Typ, und können
    bei Asterisk Zahlen, Buchstaben und Buchstabenfolgen sein. Variablen
    dienen dazu, das kompilierte Programm flexibler zu gestalten und für
    unterschiedliche oder wechselnde Einsatzzwecke anzupassen. Die Verwendung
    von Variablen ermöglicht erst den individuellen Einsatz eines Programms,
    ohne die erneute Übersetzung des Programmcodes in ein ausführbares
    Programm.</para>

    <tip>
      <para>Wer noch nie programmiert hat oder mit Variablen in Berührung
      gekommen ist, sollte sich an dieser Stelle kurz bei <ulink
      url="http://de.wikipedia.org/wiki/Variable_%28Programmierung%29">http://de.wikipedia.org/wiki/Variable_%28Programmierung%29</ulink>
      in die Materie einlesen.</para>
    </tip>

    <para>Variablen haben bei Asterisk unterschiedliche Geltungsbereiche. Es
    gibt Channel-Variablen, die Werte nur für den jeweiligen und aktiven
    Channel (also das aktuelle Gespräch) setzen, und globale Variablen, die
    Werte für alle Channels setzen. Die bereits von Asterisk vorgesehenen
    Variablen haben wir ja in Form der Parameter in den Konfigurationsdateien
    schon ausführlich kennengelernt. Neben diesen gibt es auch die
    Möglichkeit, eigene Variablen zu definieren und diese in den
    Konfigurationsdateien zu verwenden.</para>

    <section id="variablen-auslesen">
      <title>Variablen in einer Extension auslesen</title>

      <para>Der Wert einer Variable kann immer in der Syntax
      <code>${VARIABLENNAME}</code> ausgelesen werden. Es gibt Variablen, die
      vom Asterisk-System automatisch gesetzt werden. So wird z. B. die
      angerufene Nummer immer in der Variable <code>EXTEN</code>
      abgespeichert. Durch Regular Expressions und den Einsatz von Variablen
      kann man somit einen langen Dialplan häufig stark komprimieren.</para>

      <para>Beispiel vorher:<programlisting>exten =&gt; 100,1,Dial(SIP/100)
exten =&gt; 101,1,Dial(SIP/101)
exten =&gt; 102,1,Dial(SIP/102)
exten =&gt; 103,1,Dial(SIP/103)
exten =&gt; 104,1,Dial(SIP/104)
exten =&gt; 105,1,Dial(SIP/105)
exten =&gt; 106,1,Dial(SIP/106)
exten =&gt; 107,1,Dial(SIP/107)
exten =&gt; 108,1,Dial(SIP/108)
exten =&gt; 109,1,Dial(SIP/109)</programlisting></para>

      <para>Beispiel nachher:<programlisting>exten =&gt; _10X,1,Dial(SIP/${EXTEN})</programlisting></para>
    </section>

    <section id="variablen-allgemeines">
      <title>Allgemeines</title>

      <para>Variablennamen müssen nicht wie in unseren Beispielen
      großgeschrieben werden und sind auch nicht an Groß- und Kleinschreibung
      gebunden. Die Großschreibung von Variablen führt aber meistens zu besser
      lesbarem Code, da Sie bereits an der Schreibweise erkennen können, dass
      es sich um eine Variable handelt. Umgekehrt bedeutet das aber auch, dass
      Groß- und Kleinschreibung nicht für die Unterscheidung von Variablen
      verwendet werden kann.<important>
          <para>Die von Asterisk selbst generierten Variablen wie
          <literal>${EXTEN}</literal> müssen immer in Großbuchstaben
          geschrieben werden.</para>
        </important></para>

      <section id="var-strings">
        <title>Strings</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Strings</secondary>
        </indexterm>

        <para>Strings (als Variablen, die keine Zahlen, sondern Text
        enthalten) sollten immer in Anführungszeichen gesetzt werden. Asterisk
        akzeptiert sie aber auch ohne diese Markierung. So sind die folgenden
        zwei Zeilen im Ergebnis gleich:<programlisting>exten =&gt; 1234,1,Set(OBST=Apfel)
exten =&gt; 1234,2,Set(OBST="Apfel")</programlisting></para>

        <para>Sollte der String ein Komma oder ein Leerzeichen enthalten, dann
        <emphasis>müssen</emphasis> Sie Anführungszeichen verwenden, da diese
        sonst als Kommandos und nicht als Strings interpretiert
        werden:<programlisting>exten =&gt; 1234,1,Set(OBSTSORTEN="Apfel, Birne, usw.")</programlisting></para>
      </section>

      <section id="var-quoting">
        <title>Quoting</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Quoting</secondary>
        </indexterm>

        <para>Bei einer Variablen, die Zeichen oder Zeichenfolgen (Wörter,
        Text) als Werte enthält, kann es vorkommen, dass man bestimmte Zeichen
        verwenden möchte, die bereits für andere Funktionen reserviert sind.
        Wollen Sie zum Beispiel ein Underscore-Zeichen als Bestandteil des
        Variablenwertes verwenden, müssen Sie es besonders kennzeichnen, bzw.
        maskieren. Diese Kennzeichnung nennt man beim Programmieren
        <phrase>escapen</phrase>. Folgende Zeichen müssen auf jeden Fall
        maskiert (<quote>escaped</quote>) werden:<programlisting>[ ] $ " \</programlisting></para>

        <para>Das Quoting in der <filename>extensions.conf</filename> erfolgt
        mit einem vorangestellten <code>\</code> (Backslash).</para>

        <para>Beispiel:</para>

        <programlisting>exten =&gt; 1234,1,Set(BETRAG="10,00 US \$")</programlisting>
      </section>

      <section id="var-integer">
        <title>Integer</title>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>Integer</secondary>
        </indexterm>

        <para>Bestehen Variablen aus einer Ganzzahl
        (<emphasis>Integer</emphasis>), so kann diese maximal 18 Stellen
        betragen. Bei Zahlen, die größer sind, tritt ein Fehler auf, der im
        Logfile protokolliert wird.<tip>
            <para>Wer mit größeren oder Kommazahlen (Real) arbeiten will, kann
            dies mit einem AGI-Skript realisieren (siehe <xref
            linkend="kapitel-agi" />).</para>
          </tip></para>
      </section>
    </section>

    <section id="globale-var-globals">
      <title>Globale Variablen in der <filename>extensions.conf</filename>
      definieren</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Globale Variablen in der extensions.conf ([globals])
        definieren.</secondary>
      </indexterm>

      <para>Eine globale Variable kann am Anfang der
      <filename>extensions.conf</filename> gesetzt werden. Dies muss im
      besonderen Context <code>[globals]</code> erfolgen (er folgt dem Context
      <code>[general]</code>).</para>

      <para>Beispiel:<programlisting>[general]

[globals]
KLINGELZEIT=90

[from-intern]
exten =&gt; _XXX,1,Dial(SIP/${EXTEN},${KLINGELZEIT})
exten =&gt; _XXX,n,VoiceMail(${EXTEN})
</programlisting></para>
    </section>

    <section id="global-var-set">
      <title>Variablen mit Set() definieren</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Set()</secondary>
      </indexterm>

      <para>Die Applikation <code>Set()</code> wird benutzt, um eine Variable
      in einer Extension zu setzen.<footnote>
          <para>siehe auch <xref linkend="applications-set" /></para>
        </footnote></para>

      <section id="set-syntax">
        <title>Syntax</title>

        <synopsis>Set(<replaceable>Variablenname</replaceable>=<replaceable>Wert</replaceable>)</synopsis>

        <para>Beispiel:</para>

        <programlisting>; Eine Channel-Variable setzen:
exten =&gt; 10,1,Set(LIEBLINGSOBSTSORTE="Apfel")

; Eine globale Variable setzen:
exten =&gt; 10,n,Set(GLOBAL(KLINGELZEIT)=90)

; Die Variablen auf dem CLI ausgeben
exten =&gt; 10,n,NoOp(KLINGELZEIT = ${KLINGELZEIT})
exten =&gt; 10,n,NoOp(LIEBLINGSOBSTSORTE = ${LIEBLINGSOBSTSORTE})
exten =&gt; 10,n,NoOp(VAR1 = ${VAR1})
exten =&gt; 10,n,NoOp(VAR2 = ${VAR2})</programlisting>
      </section>
    </section>

    <section id="var-vererbung">
      <title>Vererbung von Channel-Variablen</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Vererbung von Channel-Variablen</secondary>
      </indexterm>

      <para>Wird im Lauf eines Gespräches ein weiterer Channel aufgebaut, so
      hat dieser natürlich wieder eigene Channel-Variablen.</para>

      <section id="var-einstufige-vererbung">
        <title>Einstufige Vererbung</title>

        <para>Will man eine Channel-Variable übergeben, aber keine globale
        Variable dafür benutzen, so kann man der Channel-Variable ein
        <literal>_</literal> (Unterstrich) voransetzen. Diese Channel-Variable
        wird dann an den nächsten Channel vererbt. Dabei wird der Unterstrich
        entfernt. Die Vererbung kann also nur einmal erfolgen.</para>

        <para>Beispiel:<programlisting>exten =&gt; 1234,1,Set(_KUCHENSORTE="Marmorkuchen")</programlisting></para>
      </section>

      <section id="var-mehrstufige-vererbung">
        <title>Mehrstufige Vererbung</title>

        <para>Will man eine Channel-Variable beliebig oft vererben, so muss
        man zwei <literal>__</literal> (Unterstrich)-Zeichen vor die Variable
        setzen. Die zwei Unterstrich-Zeichen werden dann immer
        mitvererbt.</para>

        <warning>
          <para>Asterisk unterscheidet die Namen von Variablen, die mit einem
          Underscore anfangen, nicht von Variablen, die keinen Underscore
          haben. So wird im folgenden Beispiel aus der vererbbaren
          Channel-Variable <code>KUCHENSORTE</code> eine normale (nicht
          vererbbare) Channel-Variable:<programlisting>exten =&gt; 1234,1,Set(__KUCHENSORTE="Marmorkuchen")
exten =&gt; 1234,n,Set(KUCHENSORTE="Marmorkuchen")</programlisting></para>
        </warning>

        <para>Beispiel:<programlisting>exten =&gt; 1234,1,Set(__KUCHENSORTE="Nusskuchen")</programlisting></para>

        <para>Die Unterstriche müssen aber nur beim Setzen der Variable
        vorangestellt werden, nicht beim Auslesen.<programlisting>exten =&gt; 1234,1,Set(__KUCHENSORTE="Pflaumenkuchen")
exten =&gt; 1234,n,NoOp(Kuchen: ${KUCHENSORTE})</programlisting></para>
      </section>
    </section>

    <section id="feste-channel-var">
      <title>Feste Channel-Variablen</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Feste Channel-Variablen</secondary>
      </indexterm>

      <para>Die folgende Liste enthält die wichtigsten fest einprogrammierten
      Channel-Variablen, die nicht in der <filename>extensions.conf</filename>
      überschrieben, aber ausgelesen werden können.<warning>
          <para>Eine komplette Liste aller vordefinierten Variablen finden Sie
          in der Datei <filename>doc/README.variables</filename> (Asterisk
          1.2) und <filename>doc/channelvariables.txt</filename> (Asterisk
          1.4). In dieser Liste werden nur nicht-deprecatete Variablen
          aufgelistet. So finden Sie z. B. ein
          <literal>${CALLERIDNUM}</literal> nicht in dieser Liste, weil dies
          deprecated ist (man soll anstatt die Funktion
          <literal>${CALLERID(num)}</literal> benutzen).</para>
        </warning>Die für das jeweilige Thema relevanten Variablen werden aber
      im Buch immer in jedem Kapitel extra aufgeführt.<footnote>
          <para>Ein klassisches Henne-Ei-Problem</para>
        </footnote></para>

      <note>
        <para>Bei einigen der hier aufgeführten Variablen handelt es sich gar
        nicht um Variablen, sondern um eingebaute Funktionen. Da dies in der
        Praxis aber oft verschwimmt, werden sie hier trotzdem
        aufgelistet.</para>
      </note>

      <para><variablelist termlength="10">
          <?dbfo list-presentation="blocks"?>

          <?dbhtml list-presentation="list"?>

          <varlistentry>
            <term><code>${ANSWEREDTIME}</code></term>

            <listitem>
              <para>Die Gesamtzeit (in Sekunden) seitdem das Gespräch zustande
              gekommen ist.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${BLINDTRANSFER}</code></term>

            <listitem>
              <para>Der Name des Channels auf der anderen Seite eines
              Blind-Transfers.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CHANNEL}</code></term>

            <listitem>
              <para>Name des aktuellen Channels</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${CONTEXT}</code></term>

            <listitem>
              <para>Name des aktuellen Contextes</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EPOCH}</code></term>

            <listitem>
              <para>Aktueller Unix Style Epoch.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${EXTEN}</code></term>

            <listitem>
              <para>Aktuell gewählte Extension</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${ENV(VARIABLENNAME)}</code></term>

            <listitem>
              <para>Umgebungsvariable <code>VARIABLENNAME</code></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${HANGUPCAUSE}</code></term>

            <listitem>
              <para>Grund für das Beenden (hangup) eines Gespräches</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${INVALID_EXTEN}</code></term>

            <listitem>
              <para>Wird in der <code>i</code>-Extension benutzt und enthält
              die gewählte Extension.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${PRIORITY}</code></term>

            <listitem>
              <para>Aktuelle Priorität innerhalb der Extension</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${TRANSFER_CONTEXT}</code></term>

            <listitem>
              <para>Context eines weiterverbundenen Gespräches</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${UNIQUEID}</code></term>

            <listitem>
              <para>Im System einzigartige (unique) ID für das aktuelle
              Gespräch</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><code>${SYSTEMNAME}</code></term>

            <listitem>
              <para>In der <filename>/etc/asterisk/asterisk.conf</filename>
              Datei eingetragener <parameter>systemname</parameter>
              Parameter.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>

    <section id="variablenmanipulation">
      <title>Variablenmanipulation</title>

      <indexterm>
        <primary>Variablen</primary>

        <secondary>Manipulation</secondary>
      </indexterm>

      <para>Variablen an sich eröffnen ihren Nutzen erst dann, wenn man sie
      zur Laufzeit verändern kann. Mit Hilfe dieser Variabilität lassen sich
      komplexe Verhaltensweisen steuern und vorsehen.</para>

      <section id="var-substring">
        <title>Substring</title>

        <para>In der Regel bezeichnen Strings eine Aneinanderreihung einzelner
        Zeichen (character). Die Größe eines Strings bestimmt sich durch die
        Anzahl der identifizierbaren einzelnen Zeichen. Zum Beispiel besteht
        der String <quote>Apfelbaum</quote> aus 9 Zeichen. Ein String kann
        grundsätzlich in so genannte Teilstrings zerlegt werden, also Strings,
        die, wenn man sie wieder aneinanderreiht, den ursprünglichen String
        ergeben. Im genannten Beispiel könnten wir den String
        <quote>Apfelbaum</quote> in die Teilstrings <quote>Apfel</quote> und
        <quote>baum</quote> zerlegen, aber auch <quote>Apf</quote> und
        <quote>elbaum</quote> sind echte Teilstrings. Ein String hat
        theoretisch keine begrenzte Größe, er kann beliebig viele Zeichen
        enthalten, der gesamte Text dieses Buches könnte so als ein String
        aufgefasst werden. Natürlich wäre das dann nicht mehr sehr handlich,
        dennoch ist der Vorgang des Zerlegens eines Strings in Teilstrings
        eine Standardprozedur beim Programmieren von Anwendungen. In vielen
        Programmiersprachen heißt die hier beschriebene Funktionalität
        <emphasis>Substring</emphasis>. Mit einer Substring-Funktion kann man
        Teile eines Strings ausschneiden und das Ergebnis in einer anderen
        Variablen abspeichern. In Asterisk gibt es keine eigenständige Routine
        für diese Substring-Funktion, sondern hierfür wird ein <code>:</code>
        (Doppelpunkt) nach dem Variablennamen eingesetzt. Vom Inhalt der
        Variablen, also dem String, wird dann eine vorgegebene Anzahl von
        Zeichen (Länge) als Teilstring abgetrennt.</para>

        <section id="var-substring-syntax">
          <title>Syntax</title>

          <para><synopsis>${<replaceable>VARIABLENNAME</replaceable>[:<replaceable>Anfang</replaceable>[:<replaceable>Laenge</replaceable>]]}</synopsis></para>
        </section>

        <section id="var-substring-beispiel">
          <title>Beispiele</title>

          <para>Bei einer Telefonanlage wird traditionell eine führende 0
          (Null) gewählt, um eine Amtsleitung zu bekommen. Die zu wählende
          Telefonnummer darf diese 0 aber nicht enthalten. Wird die Nummer
          <code>0030 227 32320</code> gewählt, so kann man mit folgender Zeile
          die eigentliche Rufnummer in die Variable
          <varname>${RUFNUMMER}</varname> abspeichern.<footnote>
              <para>Für alle neugierigen Leser: Das ist die Telefonnummer des
              Parlamentsarchives des Deutschen Bundestages in Berlin.</para>
            </footnote> <programlisting>exten =&gt; _0X.,1,Set(RUFNUMMER=${EXTEN:1})</programlisting></para>

          <para>Wenn die Angabe der Länge fehlt, wird automatisch der Rest des
          Strings genommen.</para>

          <para>Wenn wir die letzten 5 Ziffern der gewählten Nummer benötigen,
          dann erreichen wir das mit einer negativen Zahl. Bei der oben
          gewählten Nummer würde die folgende Zeile den Wert 32320 in der
          Variablen <varname>${DURCHWAHL}</varname>
          abspeichern.<programlisting>exten =&gt; _0X.,1,Set(DURCHWAHL=${EXTEN:-5})</programlisting></para>

          <para>Möchten wir die Vorwahl in einer separaten Variable
          abspeichern, so erreichen wir dies durch:<programlisting>exten =&gt; _0X.,1,Set(VORWAHL=${EXTEN:1:3})</programlisting>Diese
          Zeile geht davon aus, dass die Vorwahl 3-stellig ist und speichert
          sie in der Variable <varname>${VORWAHL}</varname>.<footnote>
              <para>Leider macht diese Variante in Deutschland wenig Sinn, da
              es unterschiedlich lange Vorwahlen gibt. Mehr Informationen zur
              deutschen Vorwahl finden Sie unter <ulink
              url="http://de.wikipedia.org/wiki/Telefonvorwahl_%28Deutschland%29">http://de.wikipedia.org/wiki/Telefonvorwahl_%28Deutschland%29</ulink>.</para>
            </footnote></para>

          <para>Nehmen wir an, wir möchten bei Telefonaten zur Nummer
          <code>00012024562121</code> nach Amerika die einzelnen Bestandteile
          herausfiltern:<footnote>
              <para>Um Ihnen das Gespräch nach Amerika zu sparen: Dies ist die
              Nummer der Besucherzentrale des Weißen Hauses in Washington DC.
              ;-)</para>
            </footnote><programlisting>exten =&gt; _0001X.,1,Set(INTERNATIONALEVORWAHL=${EXTEN:3:1})
exten =&gt; _0001X.,n,Set(ORTSVORWAHL=${EXTEN:4:3})
exten =&gt; _0001X.,n,Set(RUFNUMMER=${EXTEN:7})
exten =&gt; _0001X.,n,Set(DURCHWAHL=${EXTEN:-4}</programlisting></para>
        </section>
      </section>
    </section>
  </section>

  <section id="besondere-extensions">
    <title>Besondere Extensions</title>

    <indexterm>
      <primary>Extensions</primary>

      <secondary>Besondere Extensions</secondary>
    </indexterm>

    <para>Da sämtliche Programmierlogik über Extensions programmiert werden
    muss, benötigen wir noch eine Reihe von besonderen und vom System
    vorbelegte Extensions.</para>

    <section id="h-extension">
      <title>Die h-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>h-Extension</secondary>
      </indexterm>

      <para>Das <code>h</code> steht bei dieser Standard-Extension für Hangup
      (Auflegen). Sie wird aufgerufen, sobald ein Gespräch beendet wurde.
      Dabei muss berücksichtig werden, dass dann logischerweise der Wert der
      Variable <varname>${EXTEN}</varname> nicht mehr die ursprüngliche
      Extension, sondern den Wert <code>h</code> enthält.</para>

      <section id="h-extension-beispiel">
        <title>Beispiel</title>

        <para>Sollen in der globalen Variable <literal>GESPRAECHE</literal>
        immer die Anzahl der aktuell geführten Gespräche gespeichert werden,
        so muss diese beim Aufbau eines Gesprächs um 1 erhöht und beim Abbau
        eines Gesprächs (also beim Auflegen) wieder um 1 vermindert werden.
        Der folgende Dialplan zeigt die Grundidee:<programlisting>[global]
GESPRAECHE=0

[from-intern]
exten =&gt; _X.,1,Set(GESPRAECHE=$[${GESPRAECHE} + 1]|g)
exten =&gt; _X.,2,Dial(SIP/${EXTEN})

exten =&gt; h,1,Set(GESPRAECHE=$[${GESPRAECHE} - 1]|g)</programlisting></para>
      </section>
    </section>

    <section id="i-extension">
      <title>Die i-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>i-Extension</secondary>
      </indexterm>

      <para>Um einen Context "wasserdicht" zu machen, wird die
      <code>i</code>-Extension benutzt. Das <code>i</code> steht dabei für
      invalid (ungültig) und behandelt alle im entsprechenden Context nicht
      definierten Zielrufnummern. Auch hier wird in der Variable
      <code>EXTEN</code> natürlich nicht mehr die angewählte Nummer
      abgebildet, diese ist mit der Variable <code>INVALID_EXTEN</code>
      abrufbar.</para>

      <section id="i-extension-beispiel">
        <title>Beispiel</title>

        <para>In der Apfelmus GmbH können aus der Abteilung B nur die
        Rufnummern 100 bis 199 angerufen werden. Alle anderen Gespräche führen
        zur Ansage des Bausteines that-is-not-rec-phn-num.<footnote>
            <para>Der Sprachbaustein in der Datei
            <filename>that-is-not-rec-phn-num.gsm</filename> enthält den
            folgenden Text: "That is not a recognized phone number".</para>
          </footnote><programlisting>[abteilung-b]
exten =&gt; _1XX,1,Dial(${EXTEN})

exten =&gt; i,1,NoOp(Undefinierte Nummer ${INVALID_EXTEN} wurde gewaehlt.)
exten =&gt; i,2,Answer()
exten =&gt; i,3,Playback(that-is-not-rec-phn-num)
exten =&gt; i,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="o-und-a-extension">
      <title>Die o- und a-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>o-Extension</secondary>
      </indexterm>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>a-Extension</secondary>
      </indexterm>

      <para>Wurde in der Konfigurationsdatei
      <filename>voicemail.conf</filename> der Eintrag
      <code>operator=yes</code> gesetzt, so kann innerhalb der Voicemailbox
      durch Drücken der <code>0</code> (Null) die <code>o</code>-Extension
      aufgerufen werden (<code>o</code> für Operator).</para>

      <para>Durch Drücken der Stern-Taste (<code>*</code>) kommt man hingegen
      in die <code>a</code>-Extension (abort, Abbruch).</para>
    </section>

    <section id="t-extension">
      <title>Die t- und T-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>t-Extension</secondary>
      </indexterm>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>T-Extension</secondary>
      </indexterm>

      <para>Bei den <code>t</code>- und <code>T</code>-Extensions handelt es
      sich jeweils um Timeout-Extensions, also Zeitüberschreitungen.</para>

      <section id="klein-t-extension">
        <title>t-Extension</title>

        <para>Erfolgt nach einer bestimmten Zeit in einem IVR-Menü keine
        Eingabe, so wird die <code>t</code>-Extension aufgerufen.</para>

        <para>Beispiel:<programlisting>[hauptmenue]
exten =&gt; 10,1,Answer()
exten =&gt; 10,n,Background(marryme)             ; "Heiraten? 1 für ja, 2 für nein"

exten =&gt; 1,1,Playback(thank-you-cooperation)  ; 1 =&gt; "Danke"
exten =&gt; 1,n,Hangup()

exten =&gt; 2,1,Playback(hangup-try-again)       ; 2 =&gt; "Nochmal probieren"
exten =&gt; 2,n,Hangup()

exten =&gt; t,1,Hangup()                         ; keine Eingabe =&gt; auflegen</programlisting></para>
      </section>

      <section id="gross-t-extension">
        <title>T-Extension</title>

        <para>Die <code>T</code>-Extension wird nach einem Absolute Timeout
        aufgerufen. Dieser kann mit
        <code>Set(TIMEOUT(absolute)=&lt;Sekunden&gt;)</code> gesetzt
        werden.<warning>
            <para>Bitte achten Sie darauf, das vor und nach dem "=" Zeichen
            kein Leerzeichen stehen darf.</para>
          </warning> Der Timeout wird immer dann gestartet, wenn der Zähler
        neu gesetzt wird (es wird also nicht automatisch vom Anfang des
        Gespräches gezählt). Mit <code>Set(TIMEOUT(absolute)=0)</code> wird
        dieser Timeout wieder deaktiviert.</para>

        <para>Beispiel:<programlisting>exten =&gt; 20,1,Answer()
exten =&gt; 20,2,Set(TIMEOUT(absolute)=120)
exten =&gt; 20,3,Playback(hello-world)
exten =&gt; 20,4,Wait(1)
exten =&gt; 20,5,Goto(3)

exten =&gt; T,1,Wait(1)
exten =&gt; T,2,Playback(thank-you-for-calling)
exten =&gt; T,3,Wait(1)
exten =&gt; T,4,Hangup()</programlisting></para>
      </section>
    </section>

    <section id="s-extension">
      <title>Die s-Extension</title>

      <indexterm>
        <primary>Extensions</primary>

        <secondary>s-Extension</secondary>
      </indexterm>

      <para>Der erste Parameter einer Regel (Extension) ist immer der Name
      bzw. die Nummer. Was passiert aber, falls der Anruf auf einer
      klassischen analogen Leitung eintrifft und Asterisk gar nicht wissen
      kann, an wen der Anruf gerichtet ist? Dies ist dann der Fall, wenn Sie
      Asterisk mittels eines analogen Anschlusses an das Festnetz anschließen
      und die Rufnummerweitergabe aus dem Festnetz an den analogen
      Teilnehmeranschluss nicht erfolgt. Für dieses und alle anderern
      Szenarien, in denen der eingehende Anruf ohne eine Zielrufnummer
      ankommt, gibt es die <code>s</code>-Extension.<note>
          <para>Wenn Sie ein ATA-Device, also einen Analog-zu-VoIP-Adapter
          benutzen, so benötigen Sie dafür keine <code>s</code>-Extension. Die
          Zielrufnummer müssen Sie hierbei im Adapter (meist über ein
          Webinterface) konfigurieren.</para>
        </note></para>

      <para>Beispiel:</para>

      <programlisting>exten =&gt; s,1,Answer()
exten =&gt; s,2,Wait(1)
exten =&gt; s,3,Play(carried-away-by-monkeys)
exten =&gt; s,4,Wait(1)
exten =&gt; s,5,Hangup()</programlisting>
    </section>
  </section>

  <section id="macro">
    <title>Macro</title>

    <para>Ein Macro ist eine Art Unterprogramm. Es kann komplexe Workflows
    enthalten und dann im restlichen Dialplan immer mit einer einzigen Zeile
    aufgerufen werden. Ein einfaches Beispiel kann so
    aussehen:<programlisting>[macro-anruf]
exten =&gt; s,1,Dial(SIP/${MACRO_EXTEN},10)
exten =&gt; s,n,VoiceMail(${MACRO_EXTEN})</programlisting></para>

    <para>Ein solches Macro würde im rest des Dialplanes dann wie folgt
    aufgerufen werden:<programlisting>[verkauf]
exten =&gt; _2XXX,1,Macro(anruf)

[hausmeister]
exten =&gt; _2XXX,1,Macro(anruf)</programlisting></para>

    <para>Bei einem zweizeiligen Macro ist der Effekt natürlich nicht so groß
    wie bei einem langen Macro, aber es ist klar, worum es geht.</para>

    <para>Die Benutzung oder nicht Benutzung von Macros spaltet die Asterisk
    Entwicklergemeinde in zwei Lager. Für die eine Hälfte machen sie den
    Dialplan übersichtlicher und für die andere Hälfte machen sie ihn total
    unübersichtlich. Entscheiden Sie selber, zu welcher Gruppierung Sie
    gehören!</para>

    <section id="macro-basics">
      <title>Macro Basics</title>

      <para>Bei der Definition eines Macros sind folgende Punkte zu
      beachten:</para>

      <itemizedlist>
        <listitem>
          <para>Bei der Definition eines Macros gibt es nur eine Extension
          (die s-Extension).</para>
        </listitem>

        <listitem>
          <para>Auf die ursprünglichen Variablen
          <parameter>${EXTEN}</parameter> und
          <parameter>${CONTEXT}</parameter> kann innerhalb des Macros nicht
          direkt zugegriffen werden. Das geschieht über die Variablen
          <parameter>${MACRO_EXTEN}</parameter> und
          <parameter>${MACRO_CONTEXT}</parameter>.</para>
        </listitem>

        <listitem>
          <para>Beim Aufruf eines Macros können zusätzliche Argumente
          übergeben werden (mit Komma oder Pipe abgetrennt). Diese können im
          Macro mit <parameter>${ARGn}</parameter> (n ist dabei eine
          natürliche Zahl) abgerufen werden.</para>
        </listitem>

        <listitem>
          <para>Ein Macro wird durch <code>[macro-macroname]</code> definiert
          und mit der Applikation <command>Macro()</command> im Dialplan
          aufgerufen.</para>
        </listitem>
      </itemizedlist>

      <para>Weitere Informationen zu Macros finden Sie unter <xref
      linkend="applications-macro" />.<tip>
          <para>Mit der Applikation <command>MacroExclusive()</command> kann
          man sicherstellen, das das konkrete Macro immer nur einmal zu einem
          gegebenen Zeitpunkt aufgerufen wird (siehe <xref
          linkend="applications-macroexclusive" />).</para>
        </tip></para>
    </section>
  </section>

  <section id="priority-jumping">
    <title>Priority Jumping ist deprecated!</title>

    <indexterm>
      <primary>Priority Jumping</primary>

      <secondary>+101</secondary>
    </indexterm>

    <para>Lange Zeit wurde in Asterisk Dialplänen hauptsächlich mit Priority
    Jumping gearbeitet. Dazu wurde von bestimmten Applikationen (z. B.
    <code>Dial()</code>) die Priorität bei bestimmten Ereignissen um 101
    hochgesetzt. Diese Funktionalität ist aber mittlerweile offiziell
    <emphasis>deprecated</emphasis> (im Sinne von <quote>überholt</quote> und
    <quote>nicht erwünscht</quote>) und wird zwar teilweise noch unterstützt,
    sollte jedoch nicht mehr benutzt werden. Die Klassifizierung
    <emphasis>deprecated</emphasis> bezeichnet zumeist Funktionen und
    Funktionsaufrufe, für die mittlerweile entsprechende Nachfolger oder
    Folgekonstrukte existieren und künftig durch diese neuen ersetzt werden
    sollen. Beim Suchen nach Lösungen und Anregungen im Internet oder auch in
    anderen Asteriskbüchern werden Sie ebenfalls immer wieder auf
    Lösungsvorschläge stoßen, die dieses überholte Konstrukt mit den
    Prioritäten verwenden. Auch wenn die Unterstützung für derart erstellte
    Dialpläne sicher nicht morgen eingestellt wird, so werden sie doch
    mittelfristig schlechter unterstützt werden und man kann dann nicht sicher
    sein, dass es eine Lösung in der alten Notation geben wird. Es hat auch
    Vorteile sich aktiv mit einer Umstellung frühzeitig zu beschäftigen, da
    sie bei künftigen Updates der Asterisk-Software deutlich weniger Gefahr
    laufen werden, dass ihr Dialplan nicht mehr so funktioniert, wie sie das
    gewohnt sind.</para>
  </section>
</chapter>
