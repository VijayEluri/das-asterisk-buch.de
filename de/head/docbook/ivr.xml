<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="kapitel-ivr" lang="de" revision="$Revision$">
  <!--% Copyright (c) 2006 - 2008 by 
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Interactive-Voice-Response-Systeme (IVR)</title>

  <para>In der ursprünglichen Definition ist ein
  Interactive-Voice-Response-System (<acronym>IVR</acronym>) ein
  Ansagemenüsystem, das durch natürliche Sprache des Anrufers gesteuert wird.
  Allerdings ist diese Definition im Allgemeinen etwas aufgeweicht worden.
  Mittlerweile werden auch Systeme, die nur über Touch-Tone-Erkennung
  arbeiten, allgemein als IVRs bezeichnet.</para>

  <para>IVRs sind automatisierte Dialogsysteme, die einem Anrufer bestimmte
  Informationsangebote oder andere Leistungen in Dialogform anbieten. Das
  grundlegende Prinzip ist bei fast allen Systemen gleich: Dem Anrufer wird
  ein Menü vorgelesen, aus dem er dann durch bestimmte Aktionen (meist das
  Drücken einer Taste auf dem Telefon) einzelne Optionen auswählen kann. So
  kann man über solche Systeme die aktuellen Börsenkurse oder auch
  Abfahrtzeiten von Zügen der Deutschen Bahn abfragen. Es gibt sogar Systeme,
  die Buchungen von Veranstaltungstickets ermöglichen. Die Dialogsysteme
  unterscheiden sich hierbei in dem Grad der Automation. Voll automatisierte
  Systeme generieren die Sprachansagen (Text-to-Speech) und verfügen über eine
  maschinelle Spracherkennung, um die Benutzereingaben zu erkennen. Solche
  Systeme bieten einen sehr hohen Komfort, sind jedoch technisch derart
  anspruchsvoll, dass sie selten zum Einsatz kommen.<footnote>
      <para>Für Asterisk gibt es von der Firma <emphasis>LumenVox</emphasis>
      eine Spracherkennungsschnittstelle. Diese war zum Zeitpunkt der
      Drucklegung dieses Buches allerdings noch nicht für die deutsche Sprache
      erhältlich. Einfache Konstrukte wie die Erkennung von "Ja" und "Nein"
      lassen sich aber recht einfach nachbilden. Informationen zu LumenVox
      finden Sie unter <ulink
      url="http://www.lumenvox.com/">http://www.lumenvox.com</ulink>.</para>
    </footnote></para>

  <para>Die einfachste Variante ist zugleich die verbreitetste. Vorher
  aufgenommene Textnachrichten (Soundfiles) werden abgespielt, und die
  Nutzereingaben erfolgen durch Drücken der Telefontasten, deren
  charakteristische Frequenz einfach und robust von Asterisk standardmäßig
  erkannt werden kann.</para>

  <para>Die Meinungen über IVRs gehen zum Teil deutlich auseinander: Die einen
  empfinden sie als nützliche Hilfe, andere wiederum ärgern sich darüber. Oft
  bieten sie dabei immer wieder Stoff für reichlich Lacher. Meistens liegt das
  an ungeschickten Menüführungen oder &#8211; bei Systemen mit einer
  maschinellen Spracherkennung &#8211; an einer schlechten Erkennungsrate.
  Eine gut funktionierende IVR kann dem Kunden eine echte Hilfe sein, aber
  eine schlecht umgesetzte kann einen Kunden auch abschrecken. Deshalb sollten
  Sie dieses Mittel mit Bedacht einsetzen und sich Zeit für eine sorgfältig
  geplante und sauber integrierte Lösung nehmen. Häufiges Überprüfen der Zahl
  der vorzeitigen Abbrüche durch Auflegen muss dabei zu den Routineaufgaben
  gehören. Und IVRs sind weder ein Selbstzweck noch ein Allheilmittel: Denken
  Sie an Ihre Kunden!</para>

  <section id="einfache-ivr">
    <title id="eine-einfache-ivr">Eine einfache IVR</title>

    <para>Bei den Standardsprachbausteinen gibt es eine Datei
    <filename>marryme.gsm</filename>, die den Text "Will you marry me? Press 1
    for yes or 2 for no."<footnote>
        <para>Übersetzung: Möchtest Du mich heiraten? Drücke 1 für Ja und 2
        für Nein.</para>
      </footnote> enthält. Um hiermit eine Heiratsantrags-IVR zu realisieren,
    reicht folgender Dialplan:<footnote>
        <para>Es sollte auch dem größten Geek unter den Lesern klar sein, dass
        eine solche IVR nur als Beispiel dient und niemals als reale
        Möglichkeit eines Heiratsantrags in Betracht gezogen werden sollte!
        ;-)</para>
      </footnote><programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()</programlisting>Wird die 30 angerufen, hebt Asterisk
    ab und spielt das Soundfile <filename>marryme.gsm</filename> ab. Während
    der Ansage kann der Benutzer jederzeit eine Eingabe machen. Diese Eingabe
    wird als weitere Extension gewertet und abgerufen. Wer also die 1 drückt,
    bekommt die Ansage "Thank you for your cooperation." abgespielt. Danach
    legt Asterisk auf.</para>

    <section id="ivr-unterschied-playback-und-background">
      <title id="unterschied-playback-und-background">Unterschied zwischen
      Playback() und Background()</title>

      <para>Mit der Applikation <code>Playback()</code> (siehe <xref
      linkend="applications-playback" />) können Soundfiles nur abgespielt
      werden. Jegliche Eingabe während des Abspielens wird nicht beachtet.
      <code>Background()</code> (siehe <xref
      linkend="applications-background" />) hingegen spielt die Datei ab und
      wartet während des Abspielens auf eine Eingabe. Diese wird dann als
      Extension interpretiert, als wenn sie im aktuellen Context auch so
      gewählt worden wäre.</para>
    </section>

    <section id="ivr-unterschied-10-und-1000">
      <title id="unterschied-10-und-1000">Unterschied zwischen 10 und
      1000</title>

      <para>Nehmen wir als Beispiel für die Problematik der gleich anfangenden
      Extensions den folgenden Dialplan:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 10,1,NoOp(Test mit 10)
exten =&gt; 10,2,Hangup()

exten =&gt; 100,1,NoOp(Test mit 100)
exten =&gt; 100,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()</programlisting></para>

      <para>Damit Asterisk zwischen den Eingaben 1, 10 und 100 unterschieden
      kann, wartet <code>Background()</code> nach jeder Eingabe eine bestimmte
      Zeit. Ist diese Zeit (<parameter>TIMEOUT</parameter>) abgelaufen, so
      gilt die Eingabe als beendet.<tip>
          <para>Mit <parameter>TIMEOUT</parameter> können noch andere Timeouts
          definiert werden. Informationen dazu bekommen Sie im CLI mit der
          Eingabe <command>show function TIMEOUT</command>. Weitere
          Informationen zu <code>TIMEOUT</code> finden Sie bei <xref
          linkend="functions-timeout" />.</para>
        </tip>Den <parameter>TIMEOUT</parameter> kann man in Sekunden angeben
      und wie folgt im Dialplan setzen:<programlisting>exten =&gt; 123,1,Set(TIMEOUT(digit)=3)</programlisting></para>

      <section id="ivr-extension-matching">
        <title>Eigenintelligenz</title>

        <para>Asterisk wird beim obigen Dialplan bei der Eingabe der Ziffer 2
        direkt und bei der Eingabe der Ziffer 1 erst nach dem Ende des
        <code>TIMEOUT</code>s reagieren. Es erkennt also selbstständig, wann
        eine Eingabe bereits logisch gültig ist, und agiert
        entsprechend.</para>
      </section>
    </section>

    <section id="ivr-falscheingaben">
      <title id="falscheingabe-i-extension">Falscheingaben (die
      i-Extension)</title>

      <para>Eine Falscheingabe (also eine nicht im Dialplan definierte
      Eingabe) kann mit der <code>i</code>-Extension (i wie
      <emphasis>invalid</emphasis>) abgefangen werden. Ein einfaches Beispiel
      würde folgendermaßen aussehen:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()

; Bei allen anderen Eingaben wird diese
; i-Extension aufgerufen.
exten =&gt; i,1,Background(sorry)
exten =&gt; i,2,Hangup()</programlisting></para>
    </section>

    <section id="ivr-pausen">
      <title id="pausen-silence">Pausen</title>

      <para>Die einfachste Möglichkeit, kurze Pausen für die Eingabe zu
      realisieren, ist das Abspielen von Soundfiles ohne Inhalt. Im
      Verzeichnis <filename>/var/lib/asterisk/sounds/silence/</filename> gibt
      es 1 bis 9 Sekunden lange Dateien, die nur Stille abspielen. Soll in
      unserem Heiratsantragsbeispiel noch 5 Sekunden auf eine Antwort gewartet
      werden, so kann man das wie folgt erreichen:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Background(silence/5)
exten =&gt; 30,4,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()

exten =&gt; i,1,Background(marryme)
exten =&gt; i,2,Hangup()</programlisting></para>
    </section>
  </section>

  <section id="mehrstufige-ivr">
    <title id="mehrstufig-ivr">Mehrstufige IVR-Systeme</title>

    <para>Das Problem bei mehrstufigen IVRs ist, dass der Benutzer je nach
    Menüstruktur mehrmals eine einstellige Zahl (eventuell sogar die gleiche)
    drücken soll, aber jeweils ein anderes Ergebnis erhält oder eine andere
    Aktion erfolgt. Da innerhalb eines Contextes eine Zahl aber nur einmal
    vergeben werden kann, bliebe der Anrufer immer auf dieser Menüebene
    hängen. Sollen mehrere Menüs hintereinander geschaltet werden und sollen
    in jedem Menü gleiche Eingaben andere Ergebnisse bringen, so muss man
    diese Untermenüs in andere Contexte (in unserem Beispiel
    <code>[kantine]</code>) legen. Der Sprung zwischen den einzelnen
    Positionen erfolgt dann mit <code>Goto()</code> (siehe <xref
    linkend="applications-goto" />). Nehmen wir an, Sie haben folgende
    Soundfiles im Verzeichnis <filename>/var/lib/asterisk/sounds/</filename>
    abgespeichert:</para>

    <itemizedlist>
      <listitem>
        <para><filename>grundmenue.gsm</filename></para>

        <para>Bitte drücken Sie die 1 für den Verkauf, die 2 für den
        Hausmeister und die 3 für die Kantine.</para>
      </listitem>

      <listitem>
        <para><filename>kantine.gsm</filename></para>

        <para>Drücken Sie die 1 für den Essensplan dieser Woche und die 2 für
        den Essensplan der nächsten Woche.</para>
      </listitem>

      <listitem>
        <para><filename>essensplan-diese-woche.gsm</filename></para>

        <para>Montag gibt es Nudeln mit Tomatensoße, Dienstag gibt es
        Jägerschnitzel, ...</para>
      </listitem>

      <listitem>
        <para><filename>essensplan-naechste-woche.gsm</filename></para>

        <para>Montag gibt es Eintopf, Dienstag gibt es Jägerschnitzel,
        ...</para>
      </listitem>
    </itemizedlist>

    <para>Wenn der Verkauf unter der Extension 100 und der Hausmeister unter
    der Extension 150 erreichbar ist, sieht der Dialplan für diese IVR
    folgendermaßen aus:<programlisting>[beispiel-ivr]
; Das Menü wird ständig wiederholt.
;
exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(grundmenue)
exten =&gt; 30,3,Background(silence/3)
exten =&gt; 30,4,Goto(2)

exten =&gt; 1,1,Dial(SIP/100)

exten =&gt; 2,1,Dial(SIP/150)

; Goto() springt in einen anderen 
; Context ([kantine])
;
exten =&gt; 3,1,Goto(kantine,100,1)

exten =&gt; i,1,Goto(30,2)

[kantine]
exten =&gt; 100,1,Background(kantine)
exten =&gt; 100,2,Background(silence/3)
exten =&gt; 100,3,Goto(1)

exten =&gt; 1,1,Playback(essensplan-diese-woche)
exten =&gt; 1,2,Wait(2)
exten =&gt; 1,3,Goto(1)

exten =&gt; 2,1,Playback(essensplan-naechste-woche)
exten =&gt; 2,2,Wait(2)
exten =&gt; 2,3,Goto(1)

; Bei einer Falscheingabe wird 
; wieder in das Start-Menü 
; gesprungen.
;
exten =&gt; i,1,Goto(beispiel-ivr,30,2)</programlisting></para>

    <section id="ivr-tiefe">
      <title>Tiefe der IVR</title>

      <para>Auch wenn es technisch möglich ist, beliebig tiefe
      Verschachtelungen zu realisieren, so ist es in der Praxis ratsam, nicht
      mehr als drei Ebenen an Menüs hintereinanderzuschalten. Viele Anrufer
      legen nach der dritten Eingabe-Ebene auf.</para>
    </section>
  </section>

  <section id="text2speech">
    <title id="tts">Text-to-Speech (TTS)</title>

    <para>Text-to-Speech beschreibt die Umwandlung von geschriebenem Text in
    gesprochenen Text (Sprachsynthese) auf Computersystemen. Auf unserem
    Asterisk-System bedeutet das, dass ein Programm anhand einer Textdatei
    (meist in ASCII) eine entsprechende Audiodatei (Soundfile) erzeugt. Diese
    kann wie jede andere Multimediadatei abgespielt werden, und man hört den
    Text dann gesprochen. Wie bei vielen Software-Projekten wird die englische
    Sprache meist besser unterstützt als die deutsche.</para>

    <para>Darüber hinaus gibt es große Qualitätsunterschiede zwischen den
    offenen und freien (meist GPL) Engines und entsprechenden kommerziellen
    Lösungen. Das Sprach-Synthese-System <quote>Festival</quote> (<ulink
    url="http://www.cstr.ed.ac.uk/projects/festival/">http://www.cstr.ed.ac.uk/projects/festival/</ulink>)
    eignet sich gerade noch so für englischen Text, aber spätestens bei
    deutschen Texten lässt die Qualität sehr zu wünschen übrig. Als guten
    Kompromiss kann man die Software der amerikanischen Firma
    <emphasis>Cepstral</emphasis> (<ulink
    url="http://www.cepstral.com/">http://www.cepstral.com/</ulink>) nehmen.
    Es gibt dort eine kostenlose Probeversion und eine recht günstige
    Vollversion. <footnote>
        <para>Auch hier gibt es eine Online-Testversion unter <ulink
        url="http://www.cepstral.com/demos/">http://www.cepstral.com/demos/</ulink>.</para>
      </footnote>Die hier vorgestellte Lösung baut auf der Cepstral-Engine
    auf.<footnote>
        <para>Wer sich ein wenig mit Festival beschäftigt, kann die hier
        gezeigten Beispiele leicht auf Festival übertragen. Dies gilt in
        gleicher Weise auch für jede andere Text-to-Speech-Engine.</para>
      </footnote></para>

    <warning>
      <para>Cepstral und Festival sind beides keine qualitativ hochwertigen
      Text-to-Speech-Engines! Leider gibt es in diesem Bereich nur im
      Hochpreissegment wirklich gute Lösungen.</para>
    </warning>

    <section id="installation-cepstral-tts">
      <title id="installation-cepstral">Installation von Cepstral
      Text-to-Speech</title>

      <para>Auf der Webseite <ulink
      url="http://www.cepstral.com/downloads/">http://www.cepstral.com/downloads/</ulink>
      können Sie die deutsche Sprach-Engine herunterladen (eventuell müssen
      Sie auf den Link <quote>Additional Voices</quote> klicken). Die
      entsprechende Datei (hier im Beispiel immer als
      <filename>Cepstral_Matthias_i386-linux_4.1.2.tar.gz</filename>
      bezeichnet) wird wie folgt installiert:<programlisting>tar xvzf Cepstral_Matthias_i386-linux_4.1.2.tar.gz
cd Cepstral_Matthias_i386-linux_4.1.2
./install</programlisting></para>
    </section>

    <section id="cepstral-beispiel">
      <title id="beispiele-und-tests">Beispiele und Tests</title>

      <para>Falls Sie bei der Installation nichts anderes angeben, wird die
      Engine als <filename>/opt/swift/bin/swift</filename> installiert. Testen
      können Sie dies mit folgender Eingabe auf der
      Linux-Kommandozeile:<screen><emphasis role="bold"><command>/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Dies ist ein Test."</command></emphasis></screen>Das
      Ergebnis kann man sich entweder mit einem Audioplayer oder mit Asterisk
      anhören. Dazu fügen Sie einfach in der
      <filename>extensions.conf</filename> folgenden Eintrag
      hinzu:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Playback(/tmp/test)
exten =&gt; 1234,3,Hangup()</programlisting>Um einen beliebigen Text ausgeben
      zu lassen, benutzen wir die <code>System()</code>-Applikation im
      Dialplan. Hier sehen Sie ein Beispiel:<programlisting>exten =&gt; 1222,1,Answer()
exten =&gt; 1222,2,System(rm -rf /tmp/test.wav)
exten =&gt; 1222,3,System(/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Noch ein Test.")
exten =&gt; 1222,4,Playback(/tmp/test)
exten =&gt; 1222,5,Hangup()</programlisting></para>
    </section>

    <section id="cepstral-pausen">
      <title id="pausen">Pausen in Texten</title>

      <para>Cepstral benutzt SSML (<emphasis>Speech Synthesis Markup
      Language</emphasis>) innerhalb der Engine. So kann eine Pause im obigen
      Beispiel wie folgt eingefügt werden:<programlisting>exten =&gt; 1222,1,Answer()
exten =&gt; 1222,2,System(rm -rf /tmp/test.wav)
exten =&gt; 1222,3,System(/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Noch ein Test. &lt;break time='2500ms'/&gt; Ende!")
exten =&gt; 1222,4,Playback(/tmp/test.wav)
exten =&gt; 1222,5,Hangup()</programlisting>Informationen zu SSML finden Sie
      beim W3C unter <ulink
      url="http://www.w3.org/TR/speech-synthesis/">http://www.w3.org/TR/speech-synthesis/</ulink>.</para>
    </section>
  </section>
</chapter>
