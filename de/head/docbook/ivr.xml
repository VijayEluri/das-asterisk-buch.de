<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="kapitel-ivr" lang="de" revision="$Revision$">
  <!--% Copyright (c) 2006 - 2008 by 
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Interactive Voice Response Systeme (IVR)</title>

  <para>In der ursprünglichen Definition ist ein Interactive Voice Response
  System (<acronym>IVR</acronym>) ein Ansagemenüsystem, das durch natürliche
  Sprache des Anrufers gesteuert wird. Allerdings ist diese Definition im
  allgemeinen etwas weischer geworden. Mittlerweile werden auch Systeme die
  nur über Touch-Tone-Erkennung arbeiten allgemein als IVRs bezeichnet.</para>

  <para>IVRs sind automatisierte Dialogsysteme, die einem Anrufer bestimmte
  Informationsangebote oder andere Leistungen in Dialogform anbieten. Das
  grundlegende Prinzip ist bei fast allen Systemen gleich, dem Anrufer wird
  ein Menü vorgelesen, aus dem er dann durch bestimmte Aktionen (meist das
  Drücken einer Taste auf dem Telefon) einzelne auswählen kann. So kann man
  über solche Systeme die aktuellen Börsenkurse oder auch Abfahrtzeiten von
  Zügen der Deutschen Bahn abfragen. Es gibt sogar Systeme, die Buchungen von
  Veranstaltungstickets ermöglichen. Die Dialogsysteme unterscheiden sich
  hierbei in dem Grad der Automation. Voll automatisierte Systeme generieren
  die Sprachansagen (Text-to-Speech) und verfügen über eine maschinelle
  Spracherkennung, um die Benutzereingaben zu erkennen. Solche Systeme bieten
  einen sehr hohen Komfort, sind jedoch technisch derart anspruchsvoll, dass
  sie selten zum Einsatz kommen.<footnote>
      <para>Für Asterisk gibt es von der Firma LumenVox eine
      Spracherkennungsschnittstelle. Diese ist zum Zeitpunkt der Drucklegung
      dieses Buches allerdings noch nicht für die Deutsche Sprache erhältlich.
      Einfach Konstrukte wie die Erkennung von "ja" und "nein" lassen sich
      aber recht einfach nachbilden. Informationen zu LumenVox findet man auf
      <ulink
      url="http://www.lumenvox.com/"><citetitle>http://www.lumenvox.com</citetitle></ulink></para>
    </footnote></para>

  <para>Die einfachste Variante ist zugleich die verbreitetste. Vorher
  aufgenommene Textnachrichten (Soundfiles) werden abgespielt und die
  Nutzereingaben erfolgen durch Drücken der Telefontasten, deren
  charakteristische Frequenz einfach und robust von Asterisk standardmäßig
  erkannt werden kann.</para>

  <para>Die Meinungen über IVRs gehen zum Teil deutlich auseinander, die einen
  empfinden sie als nützliche Hilfe, andere wiederum ärgern sich darüber. Oft
  bieten sie dabei immer wieder Stoff für reichlich Lacher. Meistens liegt das
  an ungeschickten Menüführungen oder bei Systemen mit einer maschinellen
  Spracherkennung an einer schlechten Erkennungsrate. Eine gut funktionierende
  IVR kann dem Kunden eine echte Hilfe sein, aber eine schlecht umgesetzte
  kann einen Kunden auch abschrecken. Deshalb sollte man dieses Mittel mit
  Bedacht einsetzen und sich Zeit für eine sorgfältig geplante und sauber
  integrierte Lösung nehmen. Häufiges Überprüfen der Zahl der vorzeitigen
  Abbrüche durch Auflegen muss dabei zu den Routineaufgaben gehören. Und &#8211;
  IVRs sind weder ein Selbstzweck noch ein Allheilmittel &#8211; denken Sie an Ihre
  Kunden!</para>

  <section id="einfache-ivr">
    <title id="eine-einfache-ivr">Eine einfache IVR</title>

    <para>Bei den Standardsprachbausteinen gibt es eine Datei
    <filename>marryme.gsm</filename>, die den Text "Will you marry me? Press 1
    for yes or 2 for no."<footnote>
        <para>Übersetzung: Möchtest Du mich heiraten? Drücke 1 für ja und 2
        für nein.</para>
      </footnote> enthält. Um hiermit eine Heiratsantrags-IVR zu realisieren,
    reicht folgender Dialplan.<footnote>
        <para>Es sollte auch dem größten Geek unter den Lesern klar sein, dass
        eine solche IVR nur als Beispiel und niemals als reale Möglichkeit
        eines Heiratsantrages in Betracht gezogen werden sollte! ;-)</para>
      </footnote><programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()</programlisting>Wird die 30 angerufen, hebt Asterisk
    ab und spielt das Soundfile <filename>marryme.gsm</filename> ab. Während
    der Ansage kann jederzeit vom Benutzer eine Eingabe gemacht werden. Diese
    Eingabe wird als weitere Extension gewertet und abgerufen. Wer also die 1
    drückt, bekommt die Ansage "Thank you for your cooperation." abgespielt.
    Danach legt Asterisk auf.</para>

    <section id="ivr-unterschied-playback-und-background">
      <title id="unterschied-playback-und-background">Unterschied zwischen
      Playback() und Background()</title>

      <para>Mit der Applikation <application>Playback()</application> (siehe
      <xref linkend="applications-playback" />) können Soundfiles nur
      abgespielt werden, jegliche Eingabe während des Abspielens wird nicht
      beachtet. <application>Background()</application> (siehe <xref
      linkend="applications-background" />) hingegen spielt die Datei ab und
      wartet während des Abspielens auf eine Eingabe. Diese wird dann als
      Extension interpretiert, als wenn Sie im aktuellen Context auch so
      gewählt worden wäre.</para>
    </section>

    <section id="ivr-unterschied-10-und-1000">
      <title id="unterschied-10-und-1000">Unterschied zwischen 10 und
      1000</title>

      <para>Nehmen wir als Beispiel für die Problematik der gleich anfangenden
      Extensions den folgenden Dialplan:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 10,1,NoOp(Test mit 10)
exten =&gt; 10,2,Hangup()

exten =&gt; 100,1,NoOp(Test mit 100)
exten =&gt; 100,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()</programlisting></para>

      <para>Damit Asterisk zwischen den Eingaben 1, 10 und 100 unterschieden
      kann, wartet <application>Background()</application> nach jeder Eingabe
      eine bestimmte Zeit. Ist diese Zeit (<parameter>TIMEOUT</parameter>)
      abgelaufen, so gilt die Eingabe als beendet.<tip>
          <para>Mit <parameter>TIMEOUT</parameter> können noch andere Timeouts
          definiert werden, Informationen dazu bekommen Sie im CLI mit der
          Eingabe <command>show function TIMEOUT</command>. Weitere
          Informationen zu TIMEOUT finden Sie bei <xref
          linkend="functions-timeout" /></para>
        </tip>Den <parameter>TIMEOUT</parameter> kann man in Sekunden angeben
      und wie folgt im Dialplan setzen:<programlisting>exten =&gt; 123,1,Set(TIMEOUT(digit)=3)</programlisting></para>

      <section id="ivr-extension-matching">
        <title>Eigenintelligenz</title>

        <para>Asterisk wird beim obigen Dialplan bei der Eingabe der Ziffer 2
        direkt und bei der Eingabe der Ziffer 1 erst nach dem Ende des
        TIMEOUTs reagieren. Es erkennt also selbstständig, wann eine Eingabe
        bereits logisch gültig ist und agiert entsprechend.</para>
      </section>
    </section>

    <section id="ivr-falscheingaben">
      <title id="falscheingabe-i-extension">Falscheingaben (die
      i-Extension)</title>

      <para>Eine Falscheingabe (also eine nicht im Dialplan definierte
      Eingabe) kann mit der <code>i</code>-Extension (i wie invalid)
      abgefangen werden. Das einfache Beispiel würde folgendermaßen
      aussehen:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()

; Bei allen anderen Eingaben wird diese
; i-Extension aufgerufen.
exten =&gt; i,1,Background(sorry)
exten =&gt; i,2,Hangup()</programlisting></para>
    </section>

    <section id="ivr-pausen">
      <title id="pausen-silence">Pausen</title>

      <para>Die einfachste Möglichkeit, kurze Pausen für die Eingabe zu
      realisieren, ist das Abspielen von Soundfiles ohne Inhalt. Im
      Verzeichnis <filename>/var/lib/asterisk/sounds/silence/</filename> gibt
      es 1 bis 9 Sekunden lange Dateien, die nur Stille abspielen. Soll in
      unserem Heiratsantragsbeispiel noch 5 Sekunden auf eine Antwort gewartet
      werden, so kann man das wie folgt erreichen:<programlisting>exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(marryme)
exten =&gt; 30,3,Background(silence/5)
exten =&gt; 30,4,Hangup()

exten =&gt; 1,1,Playback(thank-you-cooperation)
exten =&gt; 1,2,Hangup()

exten =&gt; 2,1,Playback(sorry)
exten =&gt; 2,2,Hangup()

exten =&gt; i,1,Background(marryme)
exten =&gt; i,2,Hangup()</programlisting></para>
    </section>
  </section>

  <section id="mehrstufige-ivr">
    <title id="mehrstufig-ivr">Mehrstufige IVR-Systeme</title>

    <para>Das Problem bei mehrstufigen IVRs ist, dass der Benutzer je nach
    Menüstruktur mehrmals eine einstellige Zahl (evtl. sogar die gleiche)
    drücken soll, aber jeweils ein anderes Ergebnis erhält oder eine andere
    Aktion erfolgt. Da innerhalb eines Contextes eine Zahl aber nur einmal
    vergeben werden kann, bliebe der Anrufer immer auf dieser Menüebene
    hängen. Sollen mehrere Menüs hintereinander geschaltet werden und in jedem
    Menü gleiche Eingaben andere Ergebnisse bringen, so muss man diese
    Untermenüs in andere Contexte (in unserem Beispiel <code>[kantine]</code>)
    legen. Der Sprung zwischen den einzelnen Positionen erfolgt dann mit
    <application>Goto()</application> (siehe <xref
    linkend="applications-goto" />). Nehmen wir an, Sie haben folgende
    Soundfiles im Verzeichnis <filename>/var/lib/asterisk/sounds/</filename>
    abgespeichert:</para>

    <itemizedlist>
      <listitem>
        <para><filename>grundmenue.gsm</filename></para>

        <para>Bitte drücken Sie die 1 für den Verkauf, die 2 für den
        Hausmeister und die 3 für die Kantine.</para>
      </listitem>

      <listitem>
        <para><filename>kantine.gsm</filename></para>

        <para>Drücken Sie die 1 für den Essensplan dieser Woche und die 2 für
        den Essensplan der nächsten Woche.</para>
      </listitem>

      <listitem>
        <para><filename>essensplan-diese-woche.gsm</filename></para>

        <para>Montag gibt es Nudeln mit Tomatensoße, Dienstag gibt es
        Jägerschnitzel, ...</para>
      </listitem>

      <listitem>
        <para><filename>essensplan-naechste-woche.gsm</filename></para>

        <para>Montag gibt es Eintopf, Dienstag gibt es Jägerschnitzel,
        ...</para>
      </listitem>
    </itemizedlist>

    <para>Wenn der Verkauf unter der Extension 100 und der Hausmeister unter
    der Extension 150 erreichbar ist, sieht der Dialplan für diese IVR
    folgendermaßen aus:<programlisting>[beispiel-ivr]
; Das Menue wird staendig wiederholt.
;
exten =&gt; 30,1,Answer()
exten =&gt; 30,2,Background(grundmenue)
exten =&gt; 30,3,Background(silence/3)
exten =&gt; 30,4,Goto(2)

exten =&gt; 1,1,Dial(SIP/100)

exten =&gt; 2,1,Dial(SIP/150)

; Goto() springt in einen anderen 
; Context ([kantine])
;
exten =&gt; 3,1,Goto(kantine,100,1)

exten =&gt; i,1,Goto(30,2)

[kantine]
exten =&gt; 100,1,Background(kantine)
exten =&gt; 100,2,Background(silence/3)
exten =&gt; 100,3,Goto(1)

exten =&gt; 1,1,Playback(essensplan-diese-woche)
exten =&gt; 1,2,Wait(2)
exten =&gt; 1,3,Goto(1)

exten =&gt; 2,1,Playback(essensplan-naechste-woche)
exten =&gt; 2,2,Wait(2)
exten =&gt; 2,3,Goto(1)

; Bei einer Falscheingabe wird 
; wieder in das Start-Menue 
; gesprungen.
;
exten =&gt; i,1,Goto(beispiel-ivr,30,2)</programlisting></para>

    <section id="ivr-tiefe">
      <title>Tiefe der IVR</title>

      <para>Auch wenn es technisch möglich ist beliebig tiefe
      Verschachtelungen zu realisieren, so ist es in der Praxis ratsam nicht
      mehr als drei Ebenen an Menüs hintereinander zu schalten. Viele Anrufer
      legen nach der dritten Eingabeebene auf.</para>
    </section>
  </section>

  <section id="text2speech">
    <title id="tts">Text-to-Speech (TTS)</title>

    <para>Text-to-Speech beschreibt die Umwandlung von geschriebenem Text in
    gesprochenen Text (Sprachsynthese) auf Computersystemen. Auf unserem
    Asterisk-System bedeutet das, dass ein Programm anhand einer Textdatei
    (meist in ASCII) eine entsprechende Audiodatei (Soundfile) erzeugt. Diese
    kann wie jede andere Multimediadatei abgespielt werden und man hört den
    Text dann gesprochen. Wie bei vielen Software-Projekten wird die englische
    Sprache meist besser unterstützt als die deutsche.</para>

    <para>Darüber hinaus gibt es große Qualitätsunterschiede zwischen den
    offenen und freien (meist GPL) Engines und entsprechenden kommerziellen
    Lösungen. Das Speech Synthesis System Festival (<ulink
    url="http://www.cstr.ed.ac.uk/projects/festival/">http://www.cstr.ed.ac.uk/projects/festival/</ulink>)
    eignet sich gerade noch so für englischen Text, aber spätestens bei
    deutschen Texten lässt die Qualität sehr zu wünschen übrig. Als guten
    Kompromiss kann man die Software der amerikanischen Firma Cepstral (<ulink
    url="http://www.cepstral.com/">http://www.cepstral.com/</ulink>) nehmen.
    Es gibt dort eine kostenlose Probeversion und eine recht günstige
    Vollversion. <footnote>
        <para>Auch hier gibt es eine Online-Testversion unter <ulink
        url="http://www.cepstral.com/demos/">http://www.cepstral.com/demos/</ulink>.</para>
      </footnote>Die hier vorgestellte Lösung baut auf der Cepstral Engine
    auf.<footnote>
        <para>Wer sich ein wenig mit Festival beschäftigt, kann die hier
        gezeigten Beispiele leicht auf Festival übertragen. Dies gilt in
        gleicher Weise auch für jede andere Text-to-Speech-Engine.</para>
      </footnote></para>

    <warning>
      <para>Cepstral und Festival sind beides keine qualitativ hochwertigen
      Text-to-Speech-Engines! Leider gibt es in diesem Feld nur im
      Hochpreissegment wirklich gute Lösungen.</para>
    </warning>

    <section id="installation-cepstral-tts">
      <title id="installation-cepstral">Installation Cepstral
      Text-to-Speech</title>

      <para>Auf der Webseite <ulink
      url="http://www.cepstral.com/downloads/">http://www.cepstral.com/downloads/</ulink>
      kann man die deutsche Sprach-Engine herunterladen (evtl. auf den Link
      ''Additional Voices'' klicken). Die entsprechende Datei (hier
      beispielhaft immer als
      <filename>Cepstral_Matthias_i386-linux_4.1.2.tar.gz</filename>
      bezeichnet) wird wie folgt installiert:<programlisting>tar xvzf Cepstral_Matthias_i386-linux_4.1.2.tar.gz
cd Cepstral_Matthias_i386-linux_4.1.2
./install</programlisting></para>
    </section>

    <section id="cepstral-beispiel">
      <title id="beispiele-und-tests">Beispiele und Tests</title>

      <para>Falls bei der Installation nicht anders angegeben, wird die Engine
      als <filename>/opt/swift/bin/swift</filename> installiert. Testen kann
      man dies mit folgender Eingabe auf der Linux-Kommandozeile:<screen>/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Dies ist ein Test."</screen>Das
      Ergebnis kann man sich entweder mit einem Audioplayer oder mit Asterisk
      anhören. Dazu einfach in der <filename>extensions.conf</filename>
      folgenden Eintrag hinzufügen:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Playback(/tmp/test)
exten =&gt; 1234,3,Hangup()</programlisting>Um einen beliebigen Text ausgeben
      zu lassen, benutzen wir die
      <application>System()</application>-Applikation im Dialplan. Hier ein
      Beispiel:<programlisting>exten =&gt; 1222,1,Answer()
exten =&gt; 1222,2,System(rm -rf /tmp/test.wav)
exten =&gt; 1222,3,System(/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Noch ein Test.")
exten =&gt; 1222,4,Playback(/tmp/test)
exten =&gt; 1222,5,Hangup()</programlisting></para>
    </section>

    <section id="cepstral-pausen">
      <title id="pausen">Pausen in Texten</title>

      <para>Cepstral benutzt SSML (Speech Synthesis Markup Language) innerhalb
      der Engine. So kann eine Pause im obigen Beispiel wie folgt eingefügt
      werden:<programlisting>exten =&gt; 1222,1,Answer()
exten =&gt; 1222,2,System(rm -rf /tmp/test.wav)
exten =&gt; 1222,3,System(/opt/swift/bin/swift -o /tmp/test.wav -p audio/sampling-rate=8000,audio/channels=1 "Noch ein Test. &lt;break time='2500ms'/&gt; Ende!")
exten =&gt; 1222,4,Playback(/tmp/test.wav)
exten =&gt; 1222,5,Hangup()</programlisting>Information zu SSML findet man
      beim W3C unter <ulink
      url="http://www.w3.org/TR/speech-synthesis/">http://www.w3.org/TR/speech-synthesis/</ulink>.</para>
    </section>
  </section>
</chapter>