<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="ael" lang="de" revision="$Revision$">
  <!--
% Copyright (c) 2009 - Philipp Kempgen <philipp.kempgen@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de
-->

  <chapterinfo>
    <date>$Revision$</date>

    <author>
      <firstname>Philipp</firstname>

      <surname>Kempgen</surname>
    </author>

    <keywordset>
      <keyword>AEL</keyword>

      <keyword>Asterisk Extension Language</keyword>
    </keywordset>
  </chapterinfo>

  <title>AEL</title>

  <subtitle>Asterisk Extension Language</subtitle>

  <indexterm significance="preferred">
    <primary>AEL</primary>
  </indexterm>

  <indexterm significance="preferred">
    <primary>Asterisk Extension Language</primary>
  </indexterm>

  <indexterm>
    <primary>Dialplan</primary>

    <secondary>AEL</secondary>
  </indexterm>

  <indexterm>
    <primary>extensions.ael</primary>
  </indexterm>

  <para>Seit Asterisk 1.4 hat man die Möglichkeit den aus <xref
  linkend="dialplan-grundlagen" /> und <xref
  linkend="kapitel-programmieren" /> bekannten <quote>Dialplan</quote> nicht
  nur im Format <filename>extensions.conf</filename> zu schreiben sondern kann
  sich alternativ auch für AEL, die <quote>Asterisk Extension
  Language</quote>, entscheiden. Die Datei dafür heißt
  <filename>extensions.ael</filename>.</para>

  <para>AEL ist vor allem für diejenigen interessant die sich immer schon
  geärgert haben daß eine größere <filename>extensions.conf</filename> schwer
  zu lesen ist. AEL ähnelt mehr einer <quote>richtigen</quote>
  Skript-Programmiersprache. Übrigens schließen sich
  <filename>extensions.conf</filename> und <filename>extensions.ael</filename>
  nicht gegenseitig aus, man kann auch beide benutzen, also Kontexte in der
  einen oder in der anderen Datei definieren.</para>

  <para>Kleiner Vorgeschmack als <quote>Teaser</quote>:<informaltable
      colsep="0" frame="none" pgwide="1" rowsep="0" tocentry="0">
      <tgroup cols="2">
        <colspec align="left" colnum="1" colwidth="5*" />

        <colspec align="left" colnum="2" colwidth="4*" />

        <thead valign="middle">
          <row>
            <entry align="center"><filename>extensions.conf</filename></entry>

            <entry align="center"><filename>extensions.ael</filename></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><programlisting><emphasis role="bold">[meine-telefone]</emphasis>


<emphasis role="bold">exten =&gt; 20,1,</emphasis>Answer()
<emphasis role="bold">exten =&gt; 20,n,</emphasis>Playback(beep)
<emphasis role="bold">exten =&gt; 20,n,</emphasis>Hangup()

 </programlisting></entry>

            <entry><programlisting><emphasis role="bold">context meine-telefone {</emphasis>
  
  <emphasis role="bold">20 =&gt; {</emphasis>
    Answer();
    Playback(beep);
    Hangup();
  <emphasis role="bold">}</emphasis>
<emphasis role="bold">}</emphasis></programlisting></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable></para>

  <para>Es sei auch auf das bei Asterisk mitgelieferte Kommandozeilen-Werkzeug
  <command><filename>aelparse</filename></command><indexterm
      significance="preferred">
      <primary>aelparse</primary>
    </indexterm> hingewiesen mit dem man jederzeit seine
  <filename>extensions.ael</filename> wieder in das
  <filename>extensions.conf</filename>-Format konvertieren könnte. Wir werden
  später noch darauf eingehen (siehe <xref linkend="aelparse" />).</para>

  <para>Für erfahrende Leser sei noch gesagt dass hier wie üblich mit AEL
  immer AEL2 gemeint ist, denn die erste Version war nur ein experimenteller
  Versuch.</para>

  <section id="ael-cli">
    <sectioninfo>
      <keywordset>
        <keyword>ael</keyword>

        <keyword>cli</keyword>
      </keywordset>
    </sectioninfo>

    <title>CLI-Befehle für AEL</title>

    <indexterm>
      <primary>AEL</primary>

      <secondary>CLI</secondary>
    </indexterm>

    <para>Der wichtigste Befehl auf dem Asterisk-CLI für AEL ist
    <command><literal>ael reload</literal></command><indexterm>
        <primary>AEL</primary>

        <secondary>reload</secondary>
      </indexterm>, was die <filename>extensions.ael</filename> neu einliest
    wenn man etwas geändert hat.</para>

    <screen>*CLI&gt; <command>ael reload</command> </screen>

    <para>Der aus <xref linkend="dialplan-show" /> bekannte Befehl
    <command><literal>dialplan show</literal></command> zeigt den Dialplan an,
    so wie Asterisk ihn aus <filename>extensions.conf</filename> und
    <filename>extensions.ael</filename> eingelesen und ggf. kombiniert hat. In
    Klammern wird für jede Zeile auch immer <literal>pbx_config</literal> bzw.
    <literal>pbx_ael</literal> angezeigt, je nachdem woher die Zeile
    stammt.</para>
  </section>

  <section id="aelparse">
    <sectioninfo>
      <keywordset>
        <keyword>aelparse</keyword>

        <keyword>AEL</keyword>
      </keywordset>
    </sectioninfo>

    <title>aelparse</title>

    <indexterm significance="preferred">
      <primary>aelparse</primary>
    </indexterm>

    <para>Bei Asterisk wird das Kommandozeilen-Werkzeug
    <command><filename>aelparse</filename></command> mitgeliefert, mit dem man
    jederzeit seine <filename>extensions.ael</filename> wieder in das
    <filename>extensions.conf</filename>-Format konvertieren könnte falls man
    das jemals wollen sollte. <command><filename>aelparse</filename></command>
    ist also so eine Art Test-Compiler für die im Vergleich zu
    <filename>extensions.conf</filename> etwas höhere Programmiersprache
    AEL.</para>

    <para><literal>aelparse</literal> liest immer automatisch die Datei
    <filename>/etc/asterisk/extensions.ael</filename>, außer man ruft es mit
    der Option <literal>-d</literal> auf, dann wird in dem Verzeichnis in dem
    man sich gerade befindet nach der <filename>extensions.ael</filename>
    gesucht.</para>

    <para>Ohne die Option <literal>-n</literal> werde viele Informationen
    ausgegeben die hauptsächlich für die Entwickler von Asterisk interessant
    sind. Für eine übersichtliche Ausgabe ruft man <literal>aelparse</literal>
    immer mit <literal>-n</literal> auf, oder mit <literal>-q</literal> für
    noch weniger Zeilen.</para>

    <para>Mit der Option <literal>-w</literal> wird der eingelesene Dialplan
    in die Datei <filename>extensions.conf.aeldump</filename> im aktuellen
    Verzeichnis ausgegeben.<screen>asterisk:/etc/asterisk# <command>aelparse -q -w</command>
LOG: lev:4 file:ael2_parse  line:543 func: main  19 contexts, 25 extensions, 62 priorities</screen></para>
  </section>

  <section id="extensions.ael">
    <sectioninfo>
      <keywordset>
        <keyword>extensions.ael</keyword>
      </keywordset>
    </sectioninfo>

    <title>extensions.conf &lt;-&gt; extensions.ael</title>

    <indexterm>
      <primary>extensions.ael</primary>
    </indexterm>

    <para>Wir wollen hier übersichtlich darstellen wie AEL im Vergleich zur
    herkömmlichen <filename>extensions.conf</filename> aussieht. Das kann man
    am besten an Beispielen veranschaulichen. Es wird vorausgesetzt dass Sie
    bereits mit der Dialplan-Programmierung vertraut sind.</para>

    <section id="ael-command-termination">
      <title>Zeilenende/Befehlsende</title>

      <para>Befehle müssen in AEL immer mit
      <quote><literal>;</literal></quote> (Semikolon) abgeschlossen werden, da
      theoretisch auch mehrere Befehle in einer Zeile stehen könnten (was
      jedoch unüblich ist).</para>
    </section>

    <section id="ael-contexts-extensions-priorities">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>contexts</keyword>

          <keyword>extensions</keyword>

          <keyword>priorities</keyword>
        </keywordset>
      </sectioninfo>

      <title>Kontexte, Extensions, Prioritäten</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Contexte, Extensions, Prioritäten</secondary>
      </indexterm>

      <para>Der Unterschied in der Schreibweise von Contexten, Extensions und
      Prioritäten bestimmt das ganze Erscheinungsbild. In AEL werden
      geschweifte Klammern (<quote><literal>{</literal> ...
      <literal>}</literal></quote>) verwendet. Die Angabe von Prioritäten
      (<literal>1</literal>, <literal>n</literal>) ist nicht mehr
      erforderlich. In der <filename>extensions.ael</filename> hat man also
      endlich nicht mehr den zweifelhaften Charme früher BASIC-Programme in
      denen man noch die Zeilennummern angeben musste, und man erspart sich
      auch das überflüssige mehrfache Tippen der gleichen Extension für
      mehrere Zeilen bzw. Befehle. Diese Stärke kommt v.a. bei längeren
      Dialplänen zum Tragen, weshalb die kurzen Beispiele hier manchmal etwas
      unfair gegen AEL sind.</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting><emphasis role="bold">[interne-benutzer]</emphasis>


<emphasis role="bold">exten =&gt; 21,1,</emphasis>Dial(SIP/anna)
<emphasis role="bold">exten =&gt; 21,n,</emphasis>VoiceMail(anna)


<emphasis role="bold">exten =&gt; 22,1,</emphasis>Dial(SIP/lisa)
<emphasis role="bold">exten =&gt; 22,n,</emphasis>VoiceMail(lisa)


<emphasis role="bold">exten =&gt; _3X,1,</emphasis>Dial(SIP/${EXTEN})

 </programlisting></entry>

              <entry><programlisting><emphasis role="bold">context interne-benutzer {</emphasis>
  
  <emphasis role="bold">21 =&gt; {</emphasis>
    Dial(SIP/anna);
    VoiceMail(anna);
  <emphasis role="bold">}</emphasis>
  <emphasis role="bold">22 =&gt; {</emphasis>
    Dial(SIP/lisa);
    VoiceMail(lisa);
  <emphasis role="bold">}</emphasis>
  <emphasis role="bold">_3X =&gt; {</emphasis>
    Dial(SIP/${EXTEN});
  <emphasis role="bold">}</emphasis>
<emphasis role="bold">}</emphasis></programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Bei einer Extension in der nur ein Befehl ausgeführt wird könnte
      man in AEL die geschweiften Klammern übrigens auch weglassen und
      nur<informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
          tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="5*" />

            <colspec align="left" colnum="2" colwidth="4*" />

            <tbody valign="top">
              <row>
                <entry> </entry>

                <entry><programlisting>context default {
  23 =&gt; Playback(tt-monkeys);
}</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>schreiben. Gewöhnen Sie sich das bitte aber erst gar
      nicht an, und verwenden Sie immer die volle Schreibweise<informaltable
          colsep="0" frame="none" pgwide="1" rowsep="0" tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="5*" />

            <colspec align="left" colnum="2" colwidth="4*" />

            <tbody valign="top">
              <row>
                <entry> </entry>

                <entry><programlisting>context default {
  23 =&gt; <emphasis role="bold">{</emphasis>
    Playback(tt-monkeys);
  <emphasis role="bold">}</emphasis>
}</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>denn man hat ja sowieso bei den meisten Extensions
      mehrere Befehle und erreicht so ein einheitliches Format. Nur in wenigen
      Fällen (<code>goto</code>, <code>jump</code>, siehe FIXME) kann die
      kurze Schreibweise sinnvoll sein.</para>

      <important>
        <para>Die öffnende geschweifte Klammer
        <quote><literal>{</literal></quote> eines Blocks muß immer auf der
        gleichen Zeile stehen, nicht auf einer eigenen!</para>
      </important>
    </section>

    <section id="ael-comments">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>kommentare</keyword>

          <keyword>comments</keyword>
        </keywordset>
      </sectioninfo>

      <title>Kommentare</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Kommentare</secondary>
      </indexterm>

      <para>Kommentare werden in AEL durch
      <quote><literal>//</literal></quote> (zwei Schrägstriche)
      eingeleitet.</para>

      <important>
        <para>Bitte verwenden Sie für Kommentare <emphasis
        role="bold">nicht</emphasis> den C-Stil (<literal>/*</literal> ...
        <literal>*/</literal>). Für mehrzeilige Kommentare leiten Sie bitte
        jede Zeile separat mit <quote><literal>//</literal></quote>
        ein.</para>
      </important>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting><emphasis role="bold">;</emphasis> ein Kommentar

exten =&gt; 10,1,Dial(SIP/anna) <emphasis role="bold">;</emphasis> Dial
 </programlisting></entry>

              <entry><programlisting><emphasis role="bold">//</emphasis> ein Kommentar
10 =&gt; {
  Dial(SIP/anna);  <emphasis role="bold">//</emphasis> Dial
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="ael-include-contexts">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>includes</keyword>

          <keyword>include</keyword>

          <keyword>context</keyword>
        </keywordset>
      </sectioninfo>

      <title>Includes &#8211; Andere contexte einbinden</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Includes</secondary>
      </indexterm>

      <para>Wie aus <xref linkend="includes-im-dialplan" /> und <xref
      linkend="include-zeitgesteuert" /> bekannt kann man in Contexte andere
      Contexte einbinden.</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>[verkauf]

exten =&gt; 2001,1,Dial(SIP/anna)


exten =&gt; 2002,1,Dial(SIP/hans)


[lager]

exten =&gt; 3001,1,Dial(SIP/lisa)


[tag]

<emphasis role="bold">include =&gt;</emphasis> verkauf
<emphasis role="bold">include =&gt;</emphasis> lager


[nacht]

exten =&gt; _.,1,VoiceMail(${EXTEN},u)


[von-extern]

<emphasis role="bold">include =&gt;</emphasis> tag|09:00-17:00|mon-fri|*|*
&#8232;<emphasis role="bold">include =&gt;</emphasis> tag|09:00-14:00|sat|*|*
<emphasis role="bold">include =&gt;</emphasis> nacht

 </programlisting></entry>

              <entry><programlisting>context verkauf {
  2001 =&gt; {
    Dial(SIP/anna);
  }
  2002 =&gt; {
    Dial(SIP/hans);
  }
}
context lager {
  3001 =&gt; {
    Dial(SIP/lisa);
  }
}
context tag {
  <emphasis role="bold">includes {</emphasis>
    verkauf;
    lager;
  <emphasis role="bold">}</emphasis>
}
context nacht {
  _. =&gt; {
    VoiceMail(${EXTEN},u);
  }
}
context von-extern {
  <emphasis role="bold">includes {</emphasis>
    tag|09:00-17:00|mon-fri|*|*;
    tag|09:00-14:00|sat|*|*;
    nacht;
  <emphasis role="bold">}</emphasis>
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Bitte beachten Sie in AEL das <quote><literal>s</literal></quote>
      in <quote><literal>includes</literal></quote>.</para>
    </section>

    <section id="ael-global-variables">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>global</keyword>

          <keyword>variables</keyword>

          <keyword>globals</keyword>
        </keywordset>
      </sectioninfo>

      <title>Globale Variablen</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Globale Variablen</secondary>
      </indexterm>

      <para>Globale Variablen (siehe <xref
      linkend="programmierer-howto-variablen" />) können in AEL im speziellen
      Block <literal>globals</literal> gesetzt werden.</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting><emphasis role="bold">[globals]</emphasis>
KUCHEN=Marmorkuchen
KLINGELZEIT=60
 </programlisting></entry>

              <entry><programlisting><emphasis role="bold">globals {</emphasis>
  KUCHEN=Marmorkuchen;
  KLINGELZEIT=60;
<emphasis role="bold">}</emphasis></programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="ael-expressions-assignments">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>expressions</keyword>

          <keyword>assignments</keyword>

          <keyword>ausdrücke</keyword>

          <keyword>zuweisungen</keyword>
        </keywordset>
      </sectioninfo>

      <title>Ausdrücke und Zuweisungen</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Ausdrücke und Zuweisungen</secondary>
      </indexterm>

      <para>In AEL werden intern automatisch die Ausdrücke (expressions) in
      Kontroll-Strukturen wie <literal>if()</literal>,
      <literal>while()</literal>, der (mittleren) Abbruchbedingung in
      <literal>for()</literal> sowie der rechten Seite von Zuweisungen
      (assignments) so behandelt als stünden sie in einem
      <literal>$[<replaceable>...</replaceable>]</literal> Ausdruck.</para>

      <para>Das klingt zuerst kompliziert, entspicht aber dem ganz normalen
      Verhalten wie man es von anderen Programmiersprachen kennt. Bei
      Zuweisungen ist dieses Verhalten allerdings untypisch für Asterisk und
      kann leicht so merkwürdigen Fehlern führen. Man muss bedenken dass auch
      AEL eben keine <quote>richtige</quote> Programmiersprache ist und z.B.
      Strings nie als solche mit Anführungszeichen gekennzeichnet werden. Wir
      empfehlen daher, Zuweisungen nicht so zu schreiben:<informaltable
          colsep="0" frame="none" pgwide="1" rowsep="0" tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="5*" />

            <colspec align="left" colnum="2" colwidth="4*" />

            <tbody valign="top">
              <row>
                <entry> </entry>

                <entry><programlisting>context test {
  123 =&gt; {
    <emphasis role="bold">ergebnis=10/2</emphasis>;
    NoOp(ergebnis ist ${ergebnis});
  }
}</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>sondern nach wie vor die Applikation
      <literal>Set()</literal> (siehe <xref linkend="applications-set" />) zu
      verwenden:<informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
          tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="5*" />

            <colspec align="left" colnum="2" colwidth="4*" />

            <tbody valign="top">
              <row>
                <entry> </entry>

                <entry><programlisting>context test {
  123 =&gt; {
    <emphasis role="bold">Set(ergebnis=$[ 10 / 2 ])</emphasis>;
    NoOp(ergebnis ist ${ergebnis});
  }
}</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Für Sprachkonstrukte wie <literal>if()</literal>,
      <literal>while()</literal>, usw. ist dieses Verhalten allerdings
      gut:</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>
exten =&gt; 50,1,Set(a=test)
exten =&gt; 50,n,<emphasis role="bold">ExecIf($["${a}" = "101"]</emphasis>,SayDigits,123)


 </programlisting></entry>

              <entry><programlisting>50 =&gt; {
  Set(a=test);
  <emphasis role="bold">if ("${a}" = "test")</emphasis> {
    SayDigits(123);
  }
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="ael-labels-goto-jump">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>label</keyword>

          <keyword>labels</keyword>
        </keywordset>
      </sectioninfo>

      <title>Labels, goto und jump</title>

      <para>Als hartgesottener
      <filename>extensions.conf</filename>-Programmierer ist man (zwangsweise)
      daran gewöhnt mit <code>Goto()</code>, <code>GotoIf()</code>,
      <code>Gosub()</code> und <code>GosubIf()</code> zu
      <quote>Prioritäten</quote> oder Labels (Markern) zu springen.
      (Eigentlich ist das aber nur eine Behelfslösung weil es in der
      <filename>extensions.conf</filename> keine sauberen Kontroll-Strukturen
      für den Programmablauf gibt.)</para>

      <para>Labels befinden sich immer innerhalb einer Extension und werden in
      AEL auf einer eigenen Zeile geschrieben. Bitte beachten Sie den
      Doppelpunkt (<quote><code>:</code></quote>) am Zeilenende:</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>[beispiel]

exten =&gt; 10,1<emphasis role="bold">(anfang)</emphasis>,NoOp()
exten =&gt; 10,n,Wait(1)
exten =&gt; 10,n,SayNumber(1)
exten =&gt; 10,n,NoOp(Endlosschleife)
; zu einem Label in der
; gleichen Extension gehen:
exten =&gt; 10,n,<emphasis role="bold">Goto(anfang)</emphasis>


exten =&gt; 20,1,SayNumber(20)
; zu einem Label in einer
; anderen Extension im
; gleichen Kontext gehen:
exten =&gt; 20,n,<emphasis role="bold">Goto(10,anfang)</emphasis>


exten =&gt; 30,1,SayNumber(30)
; zu einem Label in einem
; anderen Kontext gehen:
exten =&gt; 30,n,<emphasis role="bold">Goto(cntxt2,40,vierzig)</emphasis>


[cntxt2]

exten =&gt; 40,1<emphasis role="bold">(vierzig)</emphasis>,NoOp()
exten =&gt; 40,n,SayNumber(40)

 </programlisting></entry>

              <entry><programlisting>context beispiel {
  10 =&gt; {
   <emphasis role="bold">anfang:</emphasis>
    Wait(1);
    SayNumber(10);
    NoOp(Endlosschleife);
    // zu einem Label in der
    // gleichen Extension gehen:
    <emphasis role="bold">goto anfang</emphasis>;
  }
  20 =&gt; {
    SayNumber(20);
    // zu einem Label in einer
    // anderen Extension im
    // gleichen Kontext gehen:
    <emphasis role="bold">goto 10|anfang</emphasis>;
  }
  30 =&gt; {
    SayNumber(30);
    // zu einem Label in einem
    // anderen Kontext gehen:
    <emphasis role="bold">goto cntxt2|40|vierzig</emphasis>;
  }
}
context cntxt2 {
  40 =&gt; {
   <emphasis role="bold">vierzig:</emphasis>
    SayNumber(40);
  }
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>In dem obigen Beispiel sehen wir auch eine andere Syntax für die
      Sprünge. Während man in der <filename>extensions.conf</filename> auf die
      Applikation <code>Goto()</code> (siehe <xref
      linkend="applications-goto" />) angewiesen ist sollte man diese in AEL
      nicht mehr verwenden (kann man aber problemlos). Dafür gibt es jetzt das
      neue Sprachkonstrukt <code>goto</code>.</para>

      <para>Ein Vergleich der Syntax von <code>Goto()</code> und
      <code>goto</code> zeigt, dass es hier keinen großen Erklärungsbedarf
      gibt:<informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
          tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="1*" />

            <colspec align="left" colnum="2" colwidth="2*" />

            <tbody valign="top">
              <row>
                <entry><filename>.conf</filename></entry>

                <entry><synopsis><emphasis role="bold"><code>Goto(</code></emphasis>[[<replaceable>context</replaceable><emphasis
                      role="bold"><code>,</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>,</code></emphasis>]<replaceable>label</replaceable><emphasis
                      role="bold"><code>)</code></emphasis></synopsis></entry>
              </row>

              <row>
                <entry><filename>.ael</filename></entry>

                <entry><synopsis><emphasis role="bold"><code>goto </code></emphasis>[[<replaceable>context</replaceable><emphasis
                      role="bold"><code>|</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>|</code></emphasis>]<replaceable>label</replaceable></synopsis></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Dass man in AEL natürlich nicht auf Idee kommen sollte zu einer
      Priorität anhand ihrer Nummer zu springen versteht sich auch von selbst,
      denn wie der AEL-Kompiler die Befehlszeilen in Prioritäten umsetzt solle
      beim Schreiben von AEL nicht interessieren. Weil es aber vorkommt dass
      man zu einer anderen Extension (im gleichen oder in einem anderen
      Context) springen will gibt es in AEL zusätzlich zu <code>goto</code>
      auch noch die Anweisung <code>jump</code>.<informaltable colsep="0"
          frame="none" pgwide="1" rowsep="0" tocentry="0">
          <tgroup cols="2">
            <colspec align="left" colnum="1" colwidth="1*" />

            <colspec align="left" colnum="2" colwidth="2*" />

            <tbody valign="top">
              <row>
                <entry><filename>.conf</filename></entry>

                <entry><synopsis><emphasis role="bold"><code>Goto(</code></emphasis>[<replaceable>context</replaceable><emphasis
                      role="bold"><code>,</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>,</code></emphasis><emphasis
                      role="bold"><code>1</code></emphasis><emphasis
                      role="bold"><code>)</code></emphasis></synopsis></entry>
              </row>

              <row>
                <entry><filename>.ael</filename> (schlecht)</entry>

                <entry><synopsis><emphasis role="bold"><code>goto </code></emphasis>[<replaceable>context</replaceable><emphasis
                      role="bold"><code>|</code></emphasis>]<replaceable>extension</replaceable><emphasis
                      role="bold"><code>|</code></emphasis><emphasis
                      role="bold"><code>1</code></emphasis></synopsis></entry>
              </row>

              <row>
                <entry><filename>.ael</filename> (gut)</entry>

                <entry><synopsis><emphasis role="bold"><code>jump </code></emphasis><replaceable>extension</replaceable>[<emphasis
                      role="bold"><code>@</code></emphasis><replaceable>context</replaceable>]</synopsis></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Im folgenden (<xref linkend="ael-conditionals" /> und <xref
      linkend="ael-loops" />) werden wir aber lernen dass man in AEL eh nicht
      mehr darauf angewiesen ist den Kontrolfluss (control flow) des Programms
      durch goto-Sprünge zu definieren da es echte Kontrollstrukturen
      gibt.</para>
    </section>

    <section id="ael-conditionals">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>bedingungen</keyword>

          <keyword>conditionals</keyword>
        </keywordset>
      </sectioninfo>

      <title>Bedingte Anweisungen (conditionals)</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Bedingte Anweisungen (conditionals)</secondary>
      </indexterm>

      <para>Bedingte Anweisungen<footnote>
          <para><ulink
          url="http://de.wikipedia.org/wiki/Bedingte_Anweisung">http://de.wikipedia.org/wiki/Bedingte_Anweisung</ulink></para>
        </footnote> (conditionals<footnote>
          <para><ulink
          url="http://en.wikipedia.org/wiki/Conditional_(programming)">http://en.wikipedia.org/wiki/Conditional_(programming)</ulink></para>
        </footnote>) gehören zu den Kontrollstrukturen (control structures)
      eines Programmablaufs.</para>

      <para>In AEL gibt es sowohl <emphasis
      role="bold"><code>if</code></emphasis>- als auch <emphasis
      role="bold"><code>switch</code></emphasis>-Blöcke. Das ist ein riesiger
      Vorteil, denn es erleichtert die Lesbarkeit ganz entscheidend.
      Vergleichen Sie selbst:</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>
exten =&gt; 20,1,Set(x=5)
exten =&gt; 20,n,GotoIf($[ ${x} = 5 ]?ok:nein)

exten =&gt; 20,10(ok),Playback(tt-monkeys)
exten =&gt; 20,11,Playback(beep)
exten =&gt; 20,12,Goto(ende)

exten =&gt; 20,20(nein),Playback(tt-weasels)
exten =&gt; 20,21,Playback(beeperr)
exten =&gt; 20,22,Goto(ende)

exten =&gt; 20,30(ende),NoOp(Ende)
 </programlisting></entry>

              <entry><programlisting>20 =&gt; {
    Set(x=5);
    GotoIf($[ ${x} = 5 ]?ok:nein);
  ok:
    Playback(tt-monkeys);
    Playback(beep);
    Goto(ende);
  nein:
    Playback(tt-weasels);
    Playback(beeperr);
    Goto(ende);
  ende:
    NoOp(Ende);
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>
exten =&gt; 20,1,Set(x=5)
exten =&gt; 20,n,GotoIf($[ ${x} = 5 ]?ok:nein)
exten =&gt; 20,10(ok),Playback(tt-monkeys)
exten =&gt; 20,11,Playback(beep)
exten =&gt; 20,12,Goto(ende)

exten =&gt; 20,20(nein),Playback(tt-weasels)
exten =&gt; 20,21,Playback(beeperr)
exten =&gt; 20,22,Goto(ende)
exten =&gt; 20,30(ende),NoOp(Ende)
 </programlisting></entry>

              <entry><programlisting>20 =&gt; {
  Set(x=5);
  if (${x} = 5) {
    Playback(tt-monkeys);
    Playback(beep);
  }
  else {
    Playback(tt-weasels);
    Playback(beeperr);
  }
  NoOp(Ende);
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para></para>
    </section>

    <section id="ael-loops">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>schleifen</keyword>

          <keyword>loops</keyword>
        </keywordset>
      </sectioninfo>

      <title>Schleifen (loops)</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Schleifen (loops)</secondary>
      </indexterm>

      <para>Schleifen (loops) gehören &#8211; wie bedingte Anweisungen &#8211;
      zu den Kontrollstrukturen (control structures) eines
      Programmablaufs.</para>

      <para>In AEL gibt es <emphasis role="bold"><code>for</code></emphasis>-
      und <emphasis
      role="bold"><code>while</code></emphasis>-Schleifen.</para>

      <para></para>

      <para></para>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>

    <section id="ael-hints">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>hints</keyword>

          <keyword>hint</keyword>
        </keywordset>
      </sectioninfo>

      <title>Hints</title>

      <indexterm>
        <primary>AEL</primary>

        <secondary>Hints</secondary>
      </indexterm>

      <para>Wie sogenannte <quote>Hints</quote> in AEL geschrieben werden
      erklären wir ausführlich in <xref linkend="blf-hints-pickup" />. Hier
      nur ein einfaches Beispiel:</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>[interne-benutzer]

exten =&gt; 21,<emphasis role="bold">hint,SIP/anna</emphasis>
exten =&gt; 21,1,Dial(SIP/anna)

exten =&gt; 22,<emphasis role="bold">hint,SIP/lisa</emphasis>
exten =&gt; 22,1,Dial(SIP/lisa)

 </programlisting></entry>

              <entry><programlisting>context interne-benutzer {
  
  <emphasis role="bold">hint(SIP/anna)</emphasis> 21 =&gt; {
    Dial(SIP/anna);
  }
  <emphasis role="bold">hint(SIP/lisa)</emphasis> 22 =&gt; {
    Dial(SIP/lisa);
  }
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>... und eines mit Pattern:</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>[interne-benutzer]

exten =&gt; 21,<emphasis role="bold">hint,SIP/21</emphasis>
exten =&gt; 22,<emphasis role="bold">hint,SIP/22</emphasis>

exten =&gt; _2X,1,Dial(SIP/${EXTEN},40)


 </programlisting></entry>

              <entry><programlisting>context interne-benutzer {
  
  <emphasis role="bold">hint(SIP/21)</emphasis> 21 =&gt; {}
  <emphasis role="bold">hint(SIP/22)</emphasis> 22 =&gt; {}
  
  _2X =&gt; {
    Dial(SIP/${EXTEN},40);
  }
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="ael-match-caller-id">
      <sectioninfo>
        <keywordset>
          <keyword>ael</keyword>

          <keyword>caller-id</keyword>
        </keywordset>
      </sectioninfo>

      <title>Filtern nach Anrufernummer</title>

      <para>Man braucht es zwar in der Praxis eher selten, aber die Syntax für
      eine vielzitierte Ex-Girlfriend-Extension sähe so aus:</para>

      <informaltable colsep="0" frame="none" pgwide="1" rowsep="0"
                     tocentry="0">
        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="5*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <thead valign="middle">
            <row>
              <entry
              align="center"><filename>extensions.conf</filename></entry>

              <entry
              align="center"><filename>extensions.ael</filename></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><programlisting>
exten =&gt; 10<emphasis role="bold">/55555</emphasis>,1,NoOp(Ex-Freundin)
exten =&gt; 10<emphasis role="bold">/55555</emphasis>,n,Busy()


exten =&gt; 10,1,Dial(SIP/philipp)
exten =&gt; 10,n,Voicemail(philipp)
 </programlisting></entry>

              <entry><programlisting>10<emphasis role="bold">/55555</emphasis> =&gt; {
  NoOp(Ex-girlfriend);
  Busy();
}
10 =&gt; {
  Dial(SIP/philipp);
  Voicemail(philipp);
}</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Wenn also die Ex-Freundin von der Nummer (Caller-ID) 55555 anruft
      würde sie auf <literal>Busy()</literal> geleitet, alle anderen Anrufer
      jedoch nicht.</para>

      <para>Übrigens sind hier auch Pattern erlaubt. Mit
      <literal>/_0123.</literal> könnte man also direkt einen ganzen
      Vorwahl-Bereich matchen.</para>
    </section>
  </section>
</chapter>
