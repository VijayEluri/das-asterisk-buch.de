<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="kapitel-programmieren" lang="de" revision="$Revision: 472 $">
  <!--% Copyright (c) 2006 - 2007 by
% - Stefan Wintermeyer <sw@amooma.de>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts. A copy of the license is included in the section entitled "GNU
% Free Documentation License".
% Asterisk training and consulting is offered at http://www.amooma.de-->

  <title>Dialplan Grundlagen</title>

  <para>In diesem Kapitel beschäftigen wir uns mit den Grundlagen des
  Dialplanes. Wir benutzen das englische Wort Dialplan und nicht das deutsche
  Wort Wählplan, weil es auch Asterisk intern immer wieder benutzt wird.
  </para>

  <para>Im Verzeichnis <filename>/etc/asterisk</filename> gibt es dafür zwei
  wichtige Dateien. Einmal die <filename>extensions.conf</filename>, die den
  Dialplan noch in den für die Asterisk Versionen 1.2 und 1.4 von Digium
  empfohlenen Prioritäten-Modell abbildet und die
  <filename>extesions.ael</filename> die einen neuen Weg zur Beschreibung des
  Dialplanes geht. Das AEL Modell wird in einem extra Kapitel in diesem Buch
  besprochen. Wir beschäftigen uns hier mit dem traditionellen
  Prioritäten-Modell, weil auch in der Version 1.4 bei jedem Starten von
  Asterisk die <filename>extensions.ael</filename> automatisch in die alte
  Schreibweise konvertiert und dann der <filename>extensions.conf</filename>
  angefügt wird.</para>

  <section id="der-context">
    <title>Context</title>

    <indexterm>
      <primary>Context</primary>
    </indexterm>

    <para>Der Dialplan wird in verschiedene Abschnitte unterteilt. Diese
    Abschnitte heißen im Asterisk-Jargon Contexte. Am Anfang eines Dialplanes
    muss es immer einen <code>[general]</code>-Context für allgemeine
    Konfigurationen geben, die danach folgenden Contexte können beliebig
    benannt werden. Die Contexte bilden das Verbindungsstück zwischen der
    Definition eines Telefones (z.B. SIP oder ISDN) und dem Dialplan. Für ein
    Telefon wird immer ein Context definiert. Ein Beispiel aus einer
    <filename>sip.conf</filename>: <programlisting>[2000]
type=friend
context=interne-telefone
secret=1234
host=dynamic</programlisting>Das SIP-Telefon mit der Nummer 2000 ruft in
    dieser Konfiguration immer den Context <code>interne-telefone</code> auf.
    Wenn also ein Benutzer mit dem Telefon 2000 eine bestimmte Nummer wählt,
    dann sucht Asterisk im Context <code>interne-telefone</code> nach der
    entsprechenden Extension (also der dazu passenden Regel). Ist diese
    Extension nicht vorhanden, passiert auch nichts.</para>

    <section id="context-syntax">
      <title>Syntax</title>

      <para>Ein Context selbst wird eingeleitet durch Text in eckigen
      Klammern. <quote>Text</quote> ist hierbei ein sinnvoller Name, der den
      Context benennt und als spätere Referenz für denselben verwendet wird.
      Alle Zeilen nach einer solchen Einleitung bis zum nächsten Context
      werden als Bestandteil (Regeln, Anweisungen) dieses Contextes
      behandelt:<programlisting>[general]

[interne-telefone]
Regeln, Anweisungen, ...

[apfelmus]
Regeln, Anweisungen, ...</programlisting></para>
    </section>
  </section>

  <section id="die-extension">
    <title>Extension</title>

    <indexterm>
      <primary>Extension</primary>
    </indexterm>

    <para>Die einzelnen Dialplan-Programme werden Asterisk-intern Extensions
    genannt. Eine Extension wird nicht kompiliert, sondern bei jedem Durchlauf
    von Asterisk interpretiert. Das Einlesen erfolgt einmalig automatisch
    während des Startens des Asterisk-Daemons.<footnote>
        <para>Eine Ausnahme stellt hier die Asterisk RealTime Architecture
        (ARA) dar. In einem ARA-System wird der Dialplan in einer Datenbank
        (z.B. MySQL) abgespeichert und dort von Asterisk bei jedem Anruf neu
        eingelesen (also nicht nur einmal beim Starten von Asterisk). So
        können Dialpläne auch im laufenden Betrieb ständig geändert werden.
        Allerdings hat diese Variante viele Nachteile. Nährere Informationen
        zu ARA finden Sie unter <ulink
        url="http://www.voip-info.org/wiki/view/Asterisk+RealTime">
        <citetitle>http://www.voip-info.org/wiki/view/Asterisk+RealTime</citetitle>
        </ulink>.</para>
      </footnote> Das erneute Einlesen des Dialplanes kann aber auch im
    laufenden Betrieb im CLI (Command Line Interface) durch den Befehl
    <command>reload now</command> bzw. <command>extensions reload</command>
    forciert werden.</para>

    <section id="extension-syntax">
      <title>Syntax</title>

      <para>Eine Extension besteht immer aus folgenden Teilen:</para>

      <itemizedlist>
        <listitem>
          <para>Extension (Nummer oder Name)</para>
        </listitem>

        <listitem>
          <para>Priorität (also der Programmzeilenzähler)</para>
        </listitem>

        <listitem>
          <para>Applikation - das ist die Anweisung, die Asterisk ausführen
          soll.</para>
        </listitem>
      </itemizedlist>

      <para><programlisting>exten =&gt; <replaceable>Extension</replaceable>,<replaceable>Priorität</replaceable>,<replaceable>Applikation</replaceable>()
</programlisting> z.B.<programlisting>exten =&gt; 123,1,Answer()
</programlisting></para>
    </section>

    <section id="grundlegende-applikationen">
      <title>Grundlegende Applikationen</title>

      <para>Um die Programmierbeispiele in diesem Kapitel halbwegs sinnvoll zu
      gestalten, benötigen wir folgende Applikationen:</para>

      <itemizedlist>
        <listitem>
          <para><code>Answer()</code></para>

          <para>Die <code>Answer()</code>-Applikation dient dazu, einen
          Verbindungsversuch zu akzeptieren. Wenn ein Channel klingelt, dann
          kann <code>Answer()</code> den virtuellen Hörer abnehmen.</para>
        </listitem>

        <listitem>
          <para><code>Hangup()</code></para>

          <para><code>Hangup()</code> ist das Gegenstück zu
          <code>Answer()</code>. Die Verbindung wird getrennt, der virtuelle
          Hörer aufgelegt.</para>
        </listitem>

        <listitem>
          <para><code>Playback(Soundfile)</code></para>

          <para>Mit <code>Playback()</code> kann man Sounddateien abspielen.
          Diese finden sich, wenn kein anderes Verzeichnis angegeben worden
          ist, im Verzeichnis <filename>/var/lib/asterisk/sounds/</filename>.
          Die Dateiendung wird dabei nicht angegeben (Asterisk sucht sich den
          optimalen Codec selbstständig raus).</para>
        </listitem>

        <listitem>
          <para><code>Wait(Zahl)</code></para>

          <para>Mit <code>Wait()</code> kann man eine Pause abrufen. Die Zahl
          in der Klammer gibt die Anzahl der zu wartenden Sekunden an.</para>
        </listitem>

        <listitem>
          <para><code>NoOp(String)</code></para>

          <para>Die Applikation <code>NoOp()</code> macht nichts.
          <application>NoOp</application> steht für No-Operation. Sie ist aber
          ein praktisches Tool, um Dialpläne zu debuggen. Der Inhalt des
          übergebenen Strings wird auf dem CLI ausgegeben. Im CLI muss dafür
          aber der Verbose Level auf mindestens 3 eingestellt sein (einfach im
          CLI <command>set verbose 3</command> eingeben).</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="die-prioritaet">
      <title>Priorität</title>

      <indexterm>
        <primary>Priorität</primary>
      </indexterm>

      <para>Eine typische Extension besteht aus mehreren Schritten. Damit
      Asterisk diese Schritte in der richtigen Reihenfolge ausführen kann,
      braucht es eine Art Zähler. Das erinnert ein wenig an frühe
      BASIC-Programme, die auch am Anfang einer jeden Zeile einen solchen
      Zähler hatten. Dieser Zähler heißt bei Asterisk Priorität. Prioritäten
      werden der Reihenfolge nach abgearbeitet (es wird immer +1 gezählt).
      Wenn die nächste logische Priorität (Lücken sind nicht zulässig!) nicht
      definiert ist bricht Asterisk ab - gibt aber leider keine Fehlermeldung
      auf dem CLI aus.</para>

      <section id="prioritaet-hello-world">
        <title>Ein hello-world Beispiel</title>

        <para>Die folgende Extension wird immer ausgelöst, wenn ein Telefon
        mit dem Context <code>apfelmus</code> die Nummer 8888 anruft. Asterisk
        nimmt dann ab, spielt den Sprachbaustein
        <filename>hello-world</filename> ab und legt auf.<programlisting>[apfelmus]
exten =&gt; 8888,1,Answer()
exten =&gt; 8888,2,Playback(hello-world)
exten =&gt; 8888,3,Hangup()</programlisting></para>
      </section>

      <section id="n-prioritaet">
        <title>n-Priorität</title>

        <indexterm>
          <primary>Priorität</primary>

          <secondary>n-Priorität</secondary>
        </indexterm>

        <para>Seit der Asterisk-Version 1.2.0 ist es möglich, Prioritäten
        nicht nur streng mit Zahlen, sondern auch mit dem Platzhalter
        <code>n</code> zu belegen. Der n-Zähler fungiert hierbei als ein
        automatischer Programmzeilenzähler. Jedesmal, wenn die
        Programmsteuerung auf die n-Priorität stößt, addiert sie 1 zum letzten
        Wert der Priorität. Dies ist dann hilfreich, falls Sie viele
        aufeinander folgende Regeln definiert haben und eine weitere Regel
        einfügen möchten, denn dann müssen Sie nicht mehr die Zähler der
        nachfolgenden Regeln neu nummerieren. Wenn eine normale Extension wie
        folgt aussieht:</para>

        <programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Wait(2)
exten =&gt; 1234,3,Playback(hello-world)
exten =&gt; 1234,4,Wait(2)
exten =&gt; 1234,5,Hangup()</programlisting>

        <para>kann man die gleiche Extension auch mit der n-Priorität
        definieren:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,n,Wait(2)
exten =&gt; 1234,n,Play(hello-world)
exten =&gt; 1234,n,Wait(2)
exten =&gt; 1234,n,Hangup()</programlisting></para>

        <para>Dies kann nicht nur an der zweiten Priorität, sondern an einer
        beliebigen Stelle passieren:<programlisting>exten =&gt; 1234,1,Answer()
exten =&gt; 1234,2,Wait(2)
exten =&gt; 1234,3,Play(hello-world)
exten =&gt; 1234,n,Wait(2)
exten =&gt; 1234,n,Hangup()</programlisting></para>
      </section>
    </section>
  </section>

  <section id="includes-im-dialplan">
    <title>Includes im Dialplan</title>

    <indexterm>
      <primary>Include</primary>
    </indexterm>

    <para>Includes bringen Struktur und Ordnung in grosse Dialpläne. Mit einem
    Include können andere Contexte in den aktuellen Context eingebaut (also
    "included") werden.</para>

    <section id="include-syntax">
      <title>Syntax</title>

      <para><programlisting>include =&gt; Name-des-anderen-Contextes</programlisting></para>
    </section>

    <section id="include-beispiel">
      <title>Beispiel</title>

      <para><programlisting>[verkauf]
include =&gt; intern
include =&gt; extern

[intern]
exten =&gt; 2000,1,Dial(SIP/2000)

[extern]
exten =&gt; 03012345678,1,Dial(SIP/03012345678)</programlisting></para>
    </section>

    <section id="include-zeitgesteuert">
      <title>Includes zeitgesteuert</title>

      <para>Durch die Fähigkeit includes auch zeitgesteuert durchzuführen,
      kann man mit diesem Mechanismus sehr leicht Tag- und Nachtschaltungen
      durchführen.</para>

      <section id="include-zeitgesteuert-syntax">
        <title>Syntax</title>

        <para><programlisting>include =&gt; context|&lt;uhrzeit&gt;|&lt;wochentag&gt;|&lt;tag-des-monats&gt;|&lt;monat&gt;</programlisting>Die
        Wochentage und Monate werden immer durch die ersten drei Buchstaben
        des entsprechenden enlischen Begriffes bestimmt. Wochentage: mon, tue,
        wed, thu, fri, sat, sun</para>
      </section>

      <section>
        <title>Beispiel</title>

        <para>Wenn eine Firma an Wochentagen von 9:00 bis 17:00 Uhr und
        samstags von 9:00 bis 14:00 Uhr geöffnet hat. Dann kann ein Dialplan
        dafür wie folgt aussehen:<programlisting>; Tag
&#8232;include =&gt; tagschaltung|09:00-17:00|mon-fri|*|*
&#8232;include =&gt; tagschaltung|09:00-14:00|sat|*|*
include =&gt; anrufbeantworter

[tagschaltung]
exten =&gt; 2000,1,Dial(SIP/2000)

[anrufbeantworter]
exten =&gt; 2000,1,VoiceMail(2000,u)&#8232;</programlisting></para>
      </section>
    </section>

    <section id="reihenfolge-beim-include">
      <title>Reihenfolge beim Include</title>

      <para>Asterisk sucht bevor es einen anderen Context einbindet (include)
      immer erst im aktuellen Context nach einem Treffer (einem Match). Gibt
      es einen Treffer, wird dieser benutzt. Gibt es keinen Treffer, wird das
      erste Include vollzogen und dort nach einem Treffer gesucht. Dies
      funktioniert rekursiv nach unten - auch verschachtelt - es können also
      auch Includes innerhalb von Includes abgearbeitet werden.</para>

      <para>Im Zweifelsfall können Sie zum Debuggen auch hier die Applikation
      <command>dialplan show nummer@name-des-contextes</command> benutzen, um
      heraus zu finden, welche Regel von Asterisk angewendet wird.</para>
    </section>
  </section>
</chapter>